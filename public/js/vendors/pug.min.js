require = (function e(t, n, r) { function i(s, a) { if (!n[s]) { if (!t[s]) { const u = typeof require === 'function' && require; if (!a && u) return u(s, !0); if (o) return o(s, !0); const c = new Error(`Cannot find module '${s}'`); throw c.code = 'MODULE_NOT_FOUND', c; } const l = n[s] = { exports: {} }; t[s][0].call(l.exports, (e) => { const n = t[s][1][e]; return i(n || e); }, l, l.exports, e, t, n, r); } return n[s].exports; } for (var o = typeof require === 'function' && require, s = 0; s < r.length; s++)i(r[s]); return i; }({
  1: [function (e, t, n) {
    function r(e) { return e.type === 'FunctionExpression' || e.type === 'FunctionDeclaration' || e.type === 'ArrowFunctionExpression' || e.type === 'Program'; } function i(e) { return e.type === 'BlockStatement' || r(e); } function o(e) { return e.type === 'FunctionExpression' || e.type === 'FunctionDeclaration'; } function s(e) { return e.type === 'FunctionExpression' || e.type === 'FunctionDeclaration'; } function a(e) { return u.parse(e, { allowReturnOutsideFunction: !0, allowImportExportEverywhere: !0, allowHashBang: !0 }); } var u = e('acorn'); const c = e('acorn/dist/walk'); t.exports = function (e) {
      function t(e, t) { const n = e.name; if (n !== 'undefined') { for (let r = 0; r < t.length; r++) { if (n === 'arguments' && o(t[r])) return; if (t[r].locals && n in t[r].locals) return; }e.parents = t, u.push(e); } } let n; var u = []; if (!(n = typeof e === 'string' ? a(e) : e) || typeof n !== 'object' || n.type !== 'Program') throw new TypeError('Source must be either a string of JavaScript or an acorn AST'); const l = function (e) { const t = e; t.locals = t.locals || {}, e.params.forEach((e) => { p(e, t); }), e.id && (t.locals[e.id.name] = !0); }; var p = function (e, t) { switch (e.type) { case 'Identifier': t.locals[e.name] = !0; break; case 'ObjectPattern': e.properties.forEach((e) => { p(e.value, t); }); break; case 'ArrayPattern': e.elements.forEach((e) => { e && p(e, t); }); break; case 'RestElement': p(e.argument, t); break; case 'AssignmentPattern': p(e.left, t); break; default: throw new Error(`Unrecognized pattern type: ${e.type}`); } }; const h = function (e, t) { n.locals = n.locals || {}, n.locals[e.local.name] = !0; }; c.ancestor(n, {
        VariableDeclaration(e, t) { for (var n = null, o = t.length - 1; o >= 0 && n === null; o--)(e.kind === 'var' ? r(t[o]) : i(t[o])) && (n = t[o]); n.locals = n.locals || {}, e.declarations.forEach((e) => { p(e.id, n); }); }, FunctionDeclaration(e, t) { for (var n = null, i = t.length - 2; i >= 0 && n === null; i--)r(t[i]) && (n = t[i]); n.locals = n.locals || {}, n.locals[e.id.name] = !0, l(e); }, Function: l, ClassDeclaration(e, t) { for (var n = null, i = t.length - 2; i >= 0 && n === null; i--)r(t[i]) && (n = t[i]); n.locals = n.locals || {}, n.locals[e.id.name] = !0; }, TryStatement(e) { e.handler !== null && (e.handler.locals = e.handler.locals || {}, e.handler.locals[e.handler.param.name] = !0); }, ImportDefaultSpecifier: h, ImportSpecifier: h, ImportNamespaceSpecifier: h,
      }), c.ancestor(n, { VariablePattern: t, Identifier: t, ThisExpression(e, t) { for (let n = 0; n < t.length; n++) if (s(t[n])) return; e.parents = t, u.push(e); } }); const f = {}; return u.forEach((e) => { const t = e.type === 'ThisExpression' ? 'this' : e.name; f[t] = f[t] || [], f[t].push(e); }), Object.keys(f).sort().map(e => ({ name: e, nodes: f[e] }));
    }, t.exports.parse = a;
  }, { acorn: 2, 'acorn/dist/walk': 3 }],
  2: [function (e, t, n) {
    !(function (e, r) { typeof n === 'object' && void 0 !== t ? r(n) : typeof define === 'function' && define.amd ? define(['exports'], r) : r(e.acorn = e.acorn || {}); }(this, (e) => {
      function t(e, t) { for (let n = 65536, r = 0; r < t.length; r += 2) { if ((n += t[r]) > e) return !1; if ((n += t[r + 1]) >= e) return !0; } } function n(e, n) { return e < 65 ? e === 36 : e < 91 || (e < 97 ? e === 95 : e < 123 || (e <= 65535 ? e >= 170 && x.test(String.fromCharCode(e)) : !1 !== n && t(e, k))); } function r(e, n) { return e < 48 ? e === 36 : e < 58 || !(e < 65) && (e < 91 || (e < 97 ? e === 95 : e < 123 || (e <= 65535 ? e >= 170 && w.test(String.fromCharCode(e)) : !1 !== n && (t(e, k) || t(e, E))))); } function i(e, t) { return new A(e, { beforeExpr: !0, binop: t }); } function o(e, t) { return void 0 === t && (t = {}), t.keyword = e, T[e] = new A(e, t); } function s(e) { return e === 10 || e === 13 || e === 8232 || e === 8233; } function a(e) { return Object.prototype.toString.call(e) === '[object Array]'; } function u(e, t) { return Object.prototype.hasOwnProperty.call(e, t); } function c(e, t) { for (let n = 1, r = 0; ;) { B.lastIndex = r; const i = B.exec(e); if (!(i && i.index < t)) return new N(n, t - r); ++n, r = i.index + i[0].length; } } function l(e) { const t = {}; for (const n in R)t[n] = e && u(e, n) ? e[n] : R[n]; if (t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), a(t.onToken)) { const r = t.onToken; t.onToken = function (e) { return r.push(e); }; } return a(t.onComment) && (t.onComment = p(t, t.onComment)), t; } function p(e, t) {
        return function (n, r, i, o, s, a) {
          const u = {
            type: n ? 'Block' : 'Line', value: r, start: i, end: o,
          }; e.locations && (u.loc = new M(this, s, a)), e.ranges && (u.range = [i, o]), t.push(u);
        };
      } function h(e) { return new RegExp(`^(${e.replace(/ /g, '|')})$`); } function f(e, t, n, r) { return e.type = t, e.end = n, this.options.locations && (e.loc.end = r), this.options.ranges && (e.range[1] = n), e; } function d(e, t, n, r) { try { return new RegExp(e, t); } catch (e) { if (void 0 !== n) throw e instanceof SyntaxError && r.raise(n, `Error parsing regular expression: ${e.message}`), e; } } function m(e) { return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e))); } const g = {
        3: 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile', 5: 'class enum extends super const export import', 6: 'enum', strict: 'implements interface let package private protected public static yield', strictBind: 'eval arguments',
      }; const v = 'break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this'; const y = { 5: v, 6: `${v} const class extends export import super` }; let b = 'ÂªÂµÂºÃ€-Ã–Ã˜-Ã¶Ã¸-ËË†-Ë‘Ë -Ë¤Ë¬Ë®Í°-Í´Í¶Í·Íº-Í½Í¿Î†Îˆ-ÎŠÎŒÎŽ-Î¡Î£-ÏµÏ·-ÒÒŠ-Ô¯Ô±-Õ–Õ™Õ¡-Ö‡×-×ª×°-×²Ø -ÙŠÙ®Ù¯Ù±-Û“Û•Û¥Û¦Û®Û¯Ûº-Û¼Û¿ÜÜ’-Ü¯Ý-Þ¥Þ±ßŠ-ßªß´ßµßºà €-à •à šà ¤à ¨à¡€-à¡˜à¢ -à¢´à¢¶-à¢½à¤„-à¤¹à¤½à¥à¥˜-à¥¡à¥±-à¦€à¦…-à¦Œà¦à¦à¦“-à¦¨à¦ª-à¦°à¦²à¦¶-à¦¹à¦½à§Žà§œà§à§Ÿ-à§¡à§°à§±à¨…-à¨Šà¨à¨à¨“-à¨¨à¨ª-à¨°à¨²à¨³à¨µà¨¶à¨¸à¨¹à©™-à©œà©žà©²-à©´àª…-àªàª-àª‘àª“-àª¨àªª-àª°àª²àª³àªµ-àª¹àª½à«à« à«¡à«¹à¬…-à¬Œà¬à¬à¬“-à¬¨à¬ª-à¬°à¬²à¬³à¬µ-à¬¹à¬½à­œà­à­Ÿ-à­¡à­±à®ƒà®…-à®Šà®Ž-à®à®’-à®•à®™à®šà®œà®žà®Ÿà®£à®¤à®¨-à®ªà®®-à®¹à¯à°…-à°Œà°Ž-à°à°’-à°¨à°ª-à°¹à°½à±˜-à±šà± à±¡à²€à²…-à²Œà²Ž-à²à²’-à²¨à²ª-à²³à²µ-à²¹à²½à³žà³ à³¡à³±à³²à´…-à´Œà´Ž-à´à´’-à´ºà´½àµŽàµ”-àµ–àµŸ-àµ¡àµº-àµ¿à¶…-à¶–à¶š-à¶±à¶³-à¶»à¶½à·€-à·†à¸-à¸°à¸²à¸³à¹€-à¹†àºàº‚àº„àº‡àºˆàºŠàºàº”-àº—àº™-àºŸàº¡-àº£àº¥àº§àºªàº«àº­-àº°àº²àº³àº½à»€-à»„à»†à»œ-à»Ÿà¼€à½€-à½‡à½‰-à½¬à¾ˆ-à¾Œá€€-á€ªá€¿á-á•áš-áá¡á¥á¦á®-á°áµ-á‚á‚Žá‚ -áƒ…áƒ‡áƒáƒ-áƒºáƒ¼-á‰ˆá‰Š-á‰á‰-á‰–á‰˜á‰š-á‰á‰ -áŠˆáŠŠ-áŠáŠ-áŠ°áŠ²-áŠµáŠ¸-áŠ¾á‹€á‹‚-á‹…á‹ˆ-á‹–á‹˜-áŒáŒ’-áŒ•áŒ˜-ášáŽ€-áŽáŽ -áµá¸-á½á-á™¬á™¯-á™¿áš-áššáš -á›ªá›®-á›¸áœ€-áœŒáœŽ-áœ‘áœ -áœ±á€-á‘á -á¬á®-á°áž€-áž³áŸ—áŸœá  -á¡·á¢€-á¢¨á¢ªá¢°-á£µá¤€-á¤žá¥-á¥­á¥°-á¥´á¦€-á¦«á¦°-á§‰á¨€-á¨–á¨ -á©”áª§á¬…-á¬³á­…-á­‹á®ƒ-á® á®®á®¯á®º-á¯¥á°€-á°£á±-á±á±š-á±½á²€-á²ˆá³©-á³¬á³®-á³±á³µá³¶á´€-á¶¿á¸€-á¼•á¼˜-á¼á¼ -á½…á½ˆ-á½á½-á½—á½™á½›á½á½Ÿ-á½½á¾€-á¾´á¾¶-á¾¼á¾¾á¿‚-á¿„á¿†-á¿Œá¿-á¿“á¿–-á¿›á¿ -á¿¬á¿²-á¿´á¿¶-á¿¼â±â¿â‚-â‚œâ„‚â„‡â„Š-â„“â„•â„˜-â„â„¤â„¦â„¨â„ª-â„¹â„¼-â„¿â……-â…‰â…Žâ… -â†ˆâ°€-â°®â°°-â±žâ± -â³¤â³«-â³®â³²â³³â´€-â´¥â´§â´­â´°-âµ§âµ¯â¶€-â¶–â¶ -â¶¦â¶¨-â¶®â¶°-â¶¶â¶¸-â¶¾â·€-â·†â·ˆ-â·Žâ·-â·–â·˜-â·žã€…-ã€‡ã€¡-ã€©ã€±-ã€µã€¸-ã€¼ã-ã‚–ã‚›-ã‚Ÿã‚¡-ãƒºãƒ¼-ãƒ¿ã„…-ã„­ã„±-ã†Žã† -ã†ºã‡°-ã‡¿ã€-ä¶µä¸€-é¿•ê€€-ê’Œê“-ê“½ê”€-ê˜Œê˜-ê˜Ÿê˜ªê˜«ê™€-ê™®ê™¿-êšêš -ê›¯êœ—-êœŸêœ¢-êžˆêž‹-êž®êž°-êž·êŸ·-ê ê ƒ-ê …ê ‡-ê Šê Œ-ê ¢ê¡€-ê¡³ê¢‚-ê¢³ê£²-ê£·ê£»ê£½ê¤Š-ê¤¥ê¤°-ê¥†ê¥ -ê¥¼ê¦„-ê¦²ê§ê§ -ê§¤ê§¦-ê§¯ê§º-ê§¾ê¨€-ê¨¨ê©€-ê©‚ê©„-ê©‹ê© -ê©¶ê©ºê©¾-êª¯êª±êªµêª¶êª¹-êª½ê«€ê«‚ê«›-ê«ê« -ê«ªê«²-ê«´ê¬-ê¬†ê¬‰-ê¬Žê¬‘-ê¬–ê¬ -ê¬¦ê¬¨-ê¬®ê¬°-ê­šê­œ-ê­¥ê­°-ê¯¢ê°€-íž£íž°-íŸ†íŸ‹-íŸ»ï¤€-ï©­ï©°-ï«™ï¬€-ï¬†ï¬“-ï¬—ï¬ï¬Ÿ-ï¬¨ï¬ª-ï¬¶ï¬¸-ï¬¼ï¬¾ï­€ï­ï­ƒï­„ï­†-ï®±ï¯“-ï´½ïµ-ï¶ï¶’-ï·‡ï·°-ï·»ï¹°-ï¹´ï¹¶-ï»¼ï¼¡-ï¼ºï½-ï½šï½¦-ï¾¾ï¿‚-ï¿‡ï¿Š-ï¿ï¿’-ï¿—ï¿š-ï¿œ'; let _ = 'â€Œâ€Â·Ì€-Í¯Î‡Òƒ-Ò‡Ö‘-Ö½Ö¿××‚×„×…×‡Ø-ØšÙ‹-Ù©Ù°Û–-ÛœÛŸ-Û¤Û§Û¨Ûª-Û­Û°-Û¹Ü‘Ü°-ÝŠÞ¦-Þ°ß€-ß‰ß«-ß³à –-à ™à ›-à £à ¥-à §à ©-à ­à¡™-à¡›à£”-à£¡à££-à¤ƒà¤º-à¤¼à¤¾-à¥à¥‘-à¥—à¥¢à¥£à¥¦-à¥¯à¦-à¦ƒà¦¼à¦¾-à§„à§‡à§ˆà§‹-à§à§—à§¢à§£à§¦-à§¯à¨-à¨ƒà¨¼à¨¾-à©‚à©‡à©ˆà©‹-à©à©‘à©¦-à©±à©µàª-àªƒàª¼àª¾-à«…à«‡-à«‰à«‹-à«à«¢à«£à«¦-à«¯à¬-à¬ƒà¬¼à¬¾-à­„à­‡à­ˆà­‹-à­à­–à­—à­¢à­£à­¦-à­¯à®‚à®¾-à¯‚à¯†-à¯ˆà¯Š-à¯à¯—à¯¦-à¯¯à°€-à°ƒà°¾-à±„à±†-à±ˆà±Š-à±à±•à±–à±¢à±£à±¦-à±¯à²-à²ƒà²¼à²¾-à³„à³†-à³ˆà³Š-à³à³•à³–à³¢à³£à³¦-à³¯à´-à´ƒà´¾-àµ„àµ†-àµˆàµŠ-àµàµ—àµ¢àµ£àµ¦-àµ¯à¶‚à¶ƒà·Šà·-à·”à·–à·˜-à·Ÿà·¦-à·¯à·²à·³à¸±à¸´-à¸ºà¹‡-à¹Žà¹-à¹™àº±àº´-àº¹àº»àº¼à»ˆ-à»à»-à»™à¼˜à¼™à¼ -à¼©à¼µà¼·à¼¹à¼¾à¼¿à½±-à¾„à¾†à¾‡à¾-à¾—à¾™-à¾¼à¿†á€«-á€¾á€-á‰á–-á™áž-á á¢-á¤á§-á­á±-á´á‚‚-á‚á‚-á‚á-áŸá©-á±áœ’-áœ”áœ²-áœ´á’á“á²á³áž´-áŸ“áŸáŸ -áŸ©á ‹-á á -á ™á¢©á¤ -á¤«á¤°-á¤»á¥†-á¥á§-á§šá¨—-á¨›á©•-á©žá© -á©¼á©¿-áª‰áª-áª™áª°-áª½á¬€-á¬„á¬´-á­„á­-á­™á­«-á­³á®€-á®‚á®¡-á®­á®°-á®¹á¯¦-á¯³á°¤-á°·á±€-á±‰á±-á±™á³-á³’á³”-á³¨á³­á³²-á³´á³¸á³¹á·€-á·µá·»-á·¿â€¿â€â”âƒ-âƒœâƒ¡âƒ¥-âƒ°â³¯-â³±âµ¿â· -â·¿ã€ª-ã€¯ã‚™ã‚šê˜ -ê˜©ê™¯ê™´-ê™½êšžêšŸê›°ê›±ê ‚ê †ê ‹ê £-ê §ê¢€ê¢ê¢´-ê£…ê£-ê£™ê£ -ê£±ê¤€-ê¤‰ê¤¦-ê¤­ê¥‡-ê¥“ê¦€-ê¦ƒê¦³-ê§€ê§-ê§™ê§¥ê§°-ê§¹ê¨©-ê¨¶ê©ƒê©Œê©ê©-ê©™ê©»-ê©½êª°êª²-êª´êª·êª¸êª¾êª¿ê«ê««-ê«¯ê«µê«¶ê¯£-ê¯ªê¯¬ê¯­ê¯°-ê¯¹ï¬žï¸€-ï¸ï¸ -ï¸¯ï¸³ï¸´ï¹-ï¹ï¼-ï¼™ï¼¿'; var x = new RegExp(`[${b}]`); var w = new RegExp(`[${b}${_}]`); b = _ = null; var k = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541]; var E = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; var A = function (e, t) { void 0 === t && (t = {}), this.label = e, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop || null, this.updateContext = null; }; const C = { beforeExpr: !0 }; const S = { startsExpr: !0 }; var T = {}; const O = {
        num: new A('num', S),
        regexp: new A('regexp', S),
        string: new A('string', S),
        name: new A('name', S),
        eof: new A('eof'),
        bracketL: new A('[', { beforeExpr: !0, startsExpr: !0 }),
        bracketR: new A(']'),
        braceL: new A('{', { beforeExpr: !0, startsExpr: !0 }),
        braceR: new A('}'),
        parenL: new A('(', { beforeExpr: !0, startsExpr: !0 }),
        parenR: new A(')'),
        comma: new A(',', C),
        semi: new A(';', C),
        colon: new A(':', C),
        dot: new A('.'),
        question: new A('?', C),
        arrow: new A('=>', C),
        template: new A('template'),
        ellipsis: new A('...', C),
        backQuote: new A('`', S),
        dollarBraceL: new A('${', { beforeExpr: !0, startsExpr: !0 }),
        eq: new A('=', { beforeExpr: !0, isAssign: !0 }),
        assign: new A('_=', { beforeExpr: !0, isAssign: !0 }),
        incDec: new A('++/--', { prefix: !0, postfix: !0, startsExpr: !0 }),
        prefix: new A('prefix', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        logicalOR: i('||', 1),
        logicalAND: i('&&', 2),
        bitwiseOR: i('|', 3),
        bitwiseXOR: i('^', 4),
        bitwiseAND: i('&', 5),
        equality: i('==/!=', 6),
        relational: i('</>', 7),
        bitShift: i('<</>>', 8),
        plusMin: new A('+/-', {
          beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0,
        }),
        modulo: i('%', 10),
        star: i('*', 10),
        slash: i('/', 10),
        starstar: new A('**', { beforeExpr: !0 }),
        _break: o('break'),
        _case: o('case', C),
        _catch: o('catch'),
        _continue: o('continue'),
        _debugger: o('debugger'),
        _default: o('default', C),
        _do: o('do', { isLoop: !0, beforeExpr: !0 }),
        _else: o('else', C),
        _finally: o('finally'),
        _for: o('for', { isLoop: !0 }),
        _function: o('function', S),
        _if: o('if'),
        _return: o('return', C),
        _switch: o('switch'),
        _throw: o('throw', C),
        _try: o('try'),
        _var: o('var'),
        _const: o('const'),
        _while: o('while', { isLoop: !0 }),
        _with: o('with'),
        _new: o('new', { beforeExpr: !0, startsExpr: !0 }),
        _this: o('this', S),
        _super: o('super', S),
        _class: o('class'),
        _extends: o('extends', C),
        _export: o('export'),
        _import: o('import'),
        _null: o('null', S),
        _true: o('true', S),
        _false: o('false', S),
        _in: o('in', { beforeExpr: !0, binop: 7 }),
        _instanceof: o('instanceof', { beforeExpr: !0, binop: 7 }),
        _typeof: o('typeof', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _void: o('void', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _delete: o('delete', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
      }; const F = /\r\n?|\n|\u2028|\u2029/; var B = new RegExp(F.source, 'g'); const D = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; const L = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g; var N = function (e, t) { this.line = e, this.column = t; }; N.prototype.offset = function (e) { return new N(this.line, this.column + e); }; var M = function (e, t, n) { this.start = t, this.end = n, e.sourceFile !== null && (this.source = e.sourceFile); }; var R = {
        ecmaVersion: 7, sourceType: 'script', onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowHashBang: !1, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1, plugins: {},
      }; const P = {}; const I = function (e, t, n) { this.options = e = l(e), this.sourceFile = e.sourceFile, this.keywords = h(y[e.ecmaVersion >= 6 ? 6 : 5]); let r = ''; if (!e.allowReserved) { for (let i = e.ecmaVersion; !(r = g[i]); i--);e.sourceType == 'module' && (r += ' await'); } this.reservedWords = h(r); const o = (r ? `${r} ` : '') + g.strict; this.reservedWordsStrict = h(o), this.reservedWordsStrictBind = h(`${o} ${g.strictBind}`), this.input = String(t), this.containsEsc = !1, this.loadPlugins(e.plugins), n ? (this.pos = n, this.lineStart = this.input.lastIndexOf('\n', n - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(F).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = O.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = e.sourceType === 'module', this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.inFunction = this.inGenerator = this.inAsync = !1, this.yieldPos = this.awaitPos = 0, this.labels = [], this.pos === 0 && e.allowHashBang && this.input.slice(0, 2) === '#!' && this.skipLineComment(2); }; I.prototype.isKeyword = function (e) { return this.keywords.test(e); }, I.prototype.isReservedWord = function (e) { return this.reservedWords.test(e); }, I.prototype.extend = function (e, t) { this[e] = t(this[e]); }, I.prototype.loadPlugins = function (e) { const t = this; for (const n in e) { const r = P[n]; if (!r) throw new Error(`Plugin '${n}' not found`); r(t, e[n]); } }, I.prototype.parse = function () { const e = this.options.program || this.startNode(); return this.nextToken(), this.parseTopLevel(e); }; const j = I.prototype; const V = /^(?:'((?:[^\']|\.)*)'|"((?:[^\"]|\.)*)"|;)/; j.strictDirective = function (e) { for (let t = this; ;) { L.lastIndex = e, e += L.exec(t.input)[0].length; const n = V.exec(t.input.slice(e)); if (!n) return !1; if ((n[1] || n[2]) == 'use strict') return !0; e += n[0].length; } }, j.eat = function (e) { return this.type === e && (this.next(), !0); }, j.isContextual = function (e) { return this.type === O.name && this.value === e; }, j.eatContextual = function (e) { return this.value === e && this.eat(O.name); }, j.expectContextual = function (e) { this.eatContextual(e) || this.unexpected(); }, j.canInsertSemicolon = function () { return this.type === O.eof || this.type === O.braceR || F.test(this.input.slice(this.lastTokEnd, this.start)); }, j.insertSemicolon = function () { if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0; }, j.semicolon = function () { this.eat(O.semi) || this.insertSemicolon() || this.unexpected(); }, j.afterTrailingComma = function (e, t) { if (this.type == e) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0; }, j.expect = function (e) { this.eat(e) || this.unexpected(); }, j.unexpected = function (e) { this.raise(e != null ? e : this.start, 'Unexpected token'); }; const z = function () { this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1; }; j.checkPatternErrors = function (e, t) { if (e) { e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, 'Comma is not permitted after the rest element'); const n = t ? e.parenthesizedAssign : e.parenthesizedBind; n > -1 && this.raiseRecoverable(n, 'Parenthesized pattern'); } }, j.checkExpressionErrors = function (e, t) { const n = e ? e.shorthandAssign : -1; if (!t) return n >= 0; n > -1 && this.raise(n, 'Shorthand property assignments are valid only in destructuring patterns'); }, j.checkYieldAwaitInDefaultParams = function () { this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, 'Yield expression cannot be a default value'), this.awaitPos && this.raise(this.awaitPos, 'Await expression cannot be a default value'); }, j.isSimpleAssignTarget = function (e) { return e.type === 'ParenthesizedExpression' ? this.isSimpleAssignTarget(e.expression) : e.type === 'Identifier' || e.type === 'MemberExpression'; }; const U = I.prototype; U.parseTopLevel = function (e) { const t = this; const n = {}; for (e.body || (e.body = []); this.type !== O.eof;) { const r = t.parseStatement(!0, !0, n); e.body.push(r); } return this.next(), this.options.ecmaVersion >= 6 && (e.sourceType = this.options.sourceType), this.finishNode(e, 'Program'); }; const $ = { kind: 'loop' }; const q = { kind: 'switch' }; U.isLet = function () { if (this.type !== O.name || this.options.ecmaVersion < 6 || this.value != 'let') return !1; L.lastIndex = this.pos; const e = L.exec(this.input); const t = this.pos + e[0].length; const i = this.input.charCodeAt(t); if (i === 91 || i == 123) return !0; if (n(i, !0)) { for (var o = t + 1; r(this.input.charCodeAt(o), !0); ++o);const s = this.input.slice(t, o); if (!this.isKeyword(s)) return !0; } return !1; }, U.isAsyncFunction = function () { if (this.type !== O.name || this.options.ecmaVersion < 8 || this.value != 'async') return !1; L.lastIndex = this.pos; const e = L.exec(this.input); const t = this.pos + e[0].length; return !(F.test(this.input.slice(this.pos, t)) || this.input.slice(t, t + 8) !== 'function' || t + 8 != this.input.length && r(this.input.charAt(t + 8))); }, U.parseStatement = function (e, t, n) { let r; let i = this.type; const o = this.startNode(); switch (this.isLet() && (i = O._var, r = 'let'), i) { case O._break: case O._continue: return this.parseBreakContinueStatement(o, i.keyword); case O._debugger: return this.parseDebuggerStatement(o); case O._do: return this.parseDoStatement(o); case O._for: return this.parseForStatement(o); case O._function: return !e && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(o, !1); case O._class: return e || this.unexpected(), this.parseClass(o, !0); case O._if: return this.parseIfStatement(o); case O._return: return this.parseReturnStatement(o); case O._switch: return this.parseSwitchStatement(o); case O._throw: return this.parseThrowStatement(o); case O._try: return this.parseTryStatement(o); case O._const: case O._var: return r = r || this.value, e || r == 'var' || this.unexpected(), this.parseVarStatement(o, r); case O._while: return this.parseWhileStatement(o); case O._with: return this.parseWithStatement(o); case O.braceL: return this.parseBlock(); case O.semi: return this.parseEmptyStatement(o); case O._export: case O._import: return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), i === O._import ? this.parseImport(o) : this.parseExport(o, n); default: if (this.isAsyncFunction() && e) return this.next(), this.parseFunctionStatement(o, !0); var s = this.value; var a = this.parseExpression(); return i === O.name && a.type === 'Identifier' && this.eat(O.colon) ? this.parseLabeledStatement(o, s, a) : this.parseExpressionStatement(o, a); } }, U.parseBreakContinueStatement = function (e, t) { const n = this; const r = t == 'break'; this.next(), this.eat(O.semi) || this.insertSemicolon() ? e.label = null : this.type !== O.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon()); for (var i = 0; i < this.labels.length; ++i) { const o = n.labels[i]; if (e.label == null || o.name === e.label.name) { if (o.kind != null && (r || o.kind === 'loop')) break; if (e.label && r) break; } } return i === this.labels.length && this.raise(e.start, `Unsyntactic ${t}`), this.finishNode(e, r ? 'BreakStatement' : 'ContinueStatement'); }, U.parseDebuggerStatement = function (e) { return this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement'); }, U.parseDoStatement = function (e) { return this.next(), this.labels.push($), e.body = this.parseStatement(!1), this.labels.pop(), this.expect(O._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(O.semi) : this.semicolon(), this.finishNode(e, 'DoWhileStatement'); }, U.parseForStatement = function (e) {
        if (this.next(), this.labels.push($), this.expect(O.parenL), this.type === O.semi) return this.parseFor(e, null); const t = this.isLet(); if (this.type === O._var || this.type === O._const || t) { const n = this.startNode(); const r = t ? 'let' : this.value; return this.next(), this.parseVar(n, !0, r), this.finishNode(n, 'VariableDeclaration'), !(this.type === O._in || this.options.ecmaVersion >= 6 && this.isContextual('of')) || n.declarations.length !== 1 || r !== 'var' && n.declarations[0].init ? this.parseFor(e, n) : this.parseForIn(e, n); } const i = new z();


        const o = this.parseExpression(!0, i); return this.type === O._in || this.options.ecmaVersion >= 6 && this.isContextual('of') ? (this.toAssignable(o), this.checkLVal(o), this.checkPatternErrors(i, !0), this.parseForIn(e, o)) : (this.checkExpressionErrors(i, !0), this.parseFor(e, o));
      }, U.parseFunctionStatement = function (e, t) { return this.next(), this.parseFunction(e, !0, !1, t); }, U.isFunction = function () { return this.type === O._function || this.isAsyncFunction(); }, U.parseIfStatement = function (e) { return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement(!this.strict && this.isFunction()), e.alternate = this.eat(O._else) ? this.parseStatement(!this.strict && this.isFunction()) : null, this.finishNode(e, 'IfStatement'); }, U.parseReturnStatement = function (e) { return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(O.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, 'ReturnStatement'); }, U.parseSwitchStatement = function (e) { const t = this; this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(O.braceL), this.labels.push(q); for (var n, r = !1; this.type != O.braceR;) if (t.type === O._case || t.type === O._default) { const i = t.type === O._case; n && t.finishNode(n, 'SwitchCase'), e.cases.push(n = t.startNode()), n.consequent = [], t.next(), i ? n.test = t.parseExpression() : (r && t.raiseRecoverable(t.lastTokStart, 'Multiple default clauses'), r = !0, n.test = null), t.expect(O.colon); } else n || t.unexpected(), n.consequent.push(t.parseStatement(!0)); return n && this.finishNode(n, 'SwitchCase'), this.next(), this.labels.pop(), this.finishNode(e, 'SwitchStatement'); }, U.parseThrowStatement = function (e) { return this.next(), F.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, 'Illegal newline after throw'), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, 'ThrowStatement'); }; const H = []; U.parseTryStatement = function (e) { if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === O._catch) { const t = this.startNode(); this.next(), this.expect(O.parenL), t.param = this.parseBindingAtom(), this.checkLVal(t.param, !0), this.expect(O.parenR), t.body = this.parseBlock(), e.handler = this.finishNode(t, 'CatchClause'); } return e.finalizer = this.eat(O._finally) ? this.parseBlock() : null, e.handler || e.finalizer || this.raise(e.start, 'Missing catch or finally clause'), this.finishNode(e, 'TryStatement'); }, U.parseVarStatement = function (e, t) { return this.next(), this.parseVar(e, !1, t), this.semicolon(), this.finishNode(e, 'VariableDeclaration'); }, U.parseWhileStatement = function (e) { return this.next(), e.test = this.parseParenExpression(), this.labels.push($), e.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(e, 'WhileStatement'); }, U.parseWithStatement = function (e) { return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement(!1), this.finishNode(e, 'WithStatement'); }, U.parseEmptyStatement = function (e) { return this.next(), this.finishNode(e, 'EmptyStatement'); }, U.parseLabeledStatement = function (e, t, n) { for (var r = this, i = 0; i < this.labels.length; ++i)r.labels[i].name === t && r.raise(n.start, `Label '${t}' is already declared`); for (var o = this.type.isLoop ? 'loop' : this.type === O._switch ? 'switch' : null, s = this.labels.length - 1; s >= 0; s--) { const a = r.labels[s]; if (a.statementStart != e.start) break; a.statementStart = r.start, a.kind = o; } return this.labels.push({ name: t, kind: o, statementStart: this.start }), e.body = this.parseStatement(!0), (e.body.type == 'ClassDeclaration' || e.body.type == 'VariableDeclaration' && (this.strict || e.body.kind != 'var') || e.body.type == 'FunctionDeclaration' && (this.strict || e.body.generator)) && this.raiseRecoverable(e.body.start, 'Invalid labeled declaration'), this.labels.pop(), e.label = n, this.finishNode(e, 'LabeledStatement'); }, U.parseExpressionStatement = function (e, t) { return e.expression = t, this.semicolon(), this.finishNode(e, 'ExpressionStatement'); }, U.parseBlock = function () { const e = this; const t = this.startNode(); for (t.body = [], this.expect(O.braceL); !this.eat(O.braceR);) { const n = e.parseStatement(!0); t.body.push(n); } return this.finishNode(t, 'BlockStatement'); }, U.parseFor = function (e, t) { return e.init = t, this.expect(O.semi), e.test = this.type === O.semi ? null : this.parseExpression(), this.expect(O.semi), e.update = this.type === O.parenR ? null : this.parseExpression(), this.expect(O.parenR), e.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(e, 'ForStatement'); }, U.parseForIn = function (e, t) { const n = this.type === O._in ? 'ForInStatement' : 'ForOfStatement'; return this.next(), e.left = t, e.right = this.parseExpression(), this.expect(O.parenR), e.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(e, n); }, U.parseVar = function (e, t, n) { const r = this; for (e.declarations = [], e.kind = n; ;) { const i = r.startNode(); if (r.parseVarId(i), r.eat(O.eq) ? i.init = r.parseMaybeAssign(t) : n !== 'const' || r.type === O._in || r.options.ecmaVersion >= 6 && r.isContextual('of') ? i.id.type == 'Identifier' || t && (r.type === O._in || r.isContextual('of')) ? i.init = null : r.raise(r.lastTokEnd, 'Complex binding patterns require an initialization value') : r.unexpected(), e.declarations.push(r.finishNode(i, 'VariableDeclarator')), !r.eat(O.comma)) break; } return e; }, U.parseVarId = function (e) { e.id = this.parseBindingAtom(), this.checkLVal(e.id, !0); }, U.parseFunction = function (e, t, n, r) { this.initFunction(e), this.options.ecmaVersion >= 6 && !r && (e.generator = this.eat(O.star)), this.options.ecmaVersion >= 8 && (e.async = !!r), t == null && (t = this.type == O.name), t && (e.id = this.parseIdent()); const i = this.inGenerator; const o = this.inAsync; const s = this.yieldPos; const a = this.awaitPos; const u = this.inFunction; return this.inGenerator = e.generator, this.inAsync = e.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, t || this.type !== O.name || (e.id = this.parseIdent()), this.parseFunctionParams(e), this.parseFunctionBody(e, n), this.inGenerator = i, this.inAsync = o, this.yieldPos = s, this.awaitPos = a, this.inFunction = u, this.finishNode(e, t ? 'FunctionDeclaration' : 'FunctionExpression'); }, U.parseFunctionParams = function (e) { this.expect(O.parenL), e.params = this.parseBindingList(O.parenR, !1, this.options.ecmaVersion >= 8, !0), this.checkYieldAwaitInDefaultParams(); }, U.parseClass = function (e, t) { const n = this; this.next(), t == null && (t = this.type === O.name), this.parseClassId(e, t), this.parseClassSuper(e); const r = this.startNode(); let i = !1; for (r.body = [], this.expect(O.braceL); !this.eat(O.braceR);) if (!n.eat(O.semi)) { const o = n.startNode(); let s = n.eat(O.star); let a = !1; const u = n.type === O.name && n.value === 'static'; n.parsePropertyName(o), o.static = u && n.type !== O.parenL, o.static && (s && n.unexpected(), s = n.eat(O.star), n.parsePropertyName(o)), n.options.ecmaVersion >= 8 && !s && !o.computed && o.key.type === 'Identifier' && o.key.name === 'async' && n.type !== O.parenL && !n.canInsertSemicolon() && (a = !0, n.parsePropertyName(o)), o.kind = 'method'; let c = !1; if (!o.computed) { let l = o.key; s || a || l.type !== 'Identifier' || n.type === O.parenL || l.name !== 'get' && l.name !== 'set' || (c = !0, o.kind = l.name, l = n.parsePropertyName(o)), !o.static && (l.type === 'Identifier' && l.name === 'constructor' || l.type === 'Literal' && l.value === 'constructor') && (i && n.raise(l.start, 'Duplicate constructor in the same class'), c && n.raise(l.start, "Constructor can't have get/set modifier"), s && n.raise(l.start, "Constructor can't be a generator"), a && n.raise(l.start, "Constructor can't be an async method"), o.kind = 'constructor', i = !0); } if (n.parseClassMethod(r, o, s, a), c) { const p = o.kind === 'get' ? 0 : 1; if (o.value.params.length !== p) { const h = o.value.start; o.kind === 'get' ? n.raiseRecoverable(h, 'getter should have no params') : n.raiseRecoverable(h, 'setter should have exactly one param'); } else o.kind === 'set' && o.value.params[0].type === 'RestElement' && n.raiseRecoverable(o.value.params[0].start, 'Setter cannot use rest params'); } } return e.body = this.finishNode(r, 'ClassBody'), this.finishNode(e, t ? 'ClassDeclaration' : 'ClassExpression'); }, U.parseClassMethod = function (e, t, n, r) { t.value = this.parseMethod(n, r), e.body.push(this.finishNode(t, 'MethodDefinition')); }, U.parseClassId = function (e, t) { e.id = this.type === O.name ? this.parseIdent() : t ? this.unexpected() : null; }, U.parseClassSuper = function (e) { e.superClass = this.eat(O._extends) ? this.parseExprSubscripts() : null; }, U.parseExport = function (e, t) { const n = this; if (this.next(), this.eat(O.star)) return this.expectContextual('from'), e.source = this.type === O.string ? this.parseExprAtom() : this.unexpected(), this.semicolon(), this.finishNode(e, 'ExportAllDeclaration'); if (this.eat(O._default)) { this.checkExport(t, 'default', this.lastTokStart); let r; if (this.type === O._function || (r = this.isAsyncFunction())) { const i = this.startNode(); this.next(), r && this.next(), e.declaration = this.parseFunction(i, null, !1, r); } else if (this.type === O._class) { const o = this.startNode(); e.declaration = this.parseClass(o, null); } else e.declaration = this.parseMaybeAssign(), this.semicolon(); return this.finishNode(e, 'ExportDefaultDeclaration'); } if (this.shouldParseExportStatement())e.declaration = this.parseStatement(!0), e.declaration.type === 'VariableDeclaration' ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id.name, e.declaration.id.start), e.specifiers = [], e.source = null; else { if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual('from'))e.source = this.type === O.string ? this.parseExprAtom() : this.unexpected(); else { for (let s = 0; s < e.specifiers.length; s++)(n.keywords.test(e.specifiers[s].local.name) || n.reservedWords.test(e.specifiers[s].local.name)) && n.unexpected(e.specifiers[s].local.start); e.source = null; } this.semicolon(); } return this.finishNode(e, 'ExportNamedDeclaration'); }, U.checkExport = function (e, t, n) { e && (Object.prototype.hasOwnProperty.call(e, t) && this.raiseRecoverable(n, `Duplicate export '${t}'`), e[t] = !0); }, U.checkPatternExport = function (e, t) { const n = this; const r = t.type; if (r == 'Identifier') this.checkExport(e, t.name, t.start); else if (r == 'ObjectPattern') for (let i = 0; i < t.properties.length; ++i)n.checkPatternExport(e, t.properties[i].value); else if (r == 'ArrayPattern') for (let o = 0; o < t.elements.length; ++o) { const s = t.elements[o]; s && n.checkPatternExport(e, s); } else r == 'AssignmentPattern' ? this.checkPatternExport(e, t.left) : r == 'ParenthesizedExpression' && this.checkPatternExport(e, t.expression); }, U.checkVariableExport = function (e, t) { const n = this; if (e) for (let r = 0; r < t.length; r++)n.checkPatternExport(e, t[r].id); }, U.shouldParseExportStatement = function () { return this.type.keyword === 'var' || this.type.keyword === 'const' || this.type.keyword === 'class' || this.type.keyword === 'function' || this.isLet() || this.isAsyncFunction(); }, U.parseExportSpecifiers = function (e) { const t = this; const n = []; let r = !0; for (this.expect(O.braceL); !this.eat(O.braceR);) { if (r)r = !1; else if (t.expect(O.comma), t.afterTrailingComma(O.braceR)) break; const i = t.startNode(); i.local = t.parseIdent(!0), i.exported = t.eatContextual('as') ? t.parseIdent(!0) : i.local, t.checkExport(e, i.exported.name, i.exported.start), n.push(t.finishNode(i, 'ExportSpecifier')); } return n; }, U.parseImport = function (e) { return this.next(), this.type === O.string ? (e.specifiers = H, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual('from'), e.source = this.type === O.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e, 'ImportDeclaration'); }, U.parseImportSpecifiers = function () { const e = this; const t = []; let n = !0; if (this.type === O.name) { const r = this.startNode(); if (r.local = this.parseIdent(), this.checkLVal(r.local, !0), t.push(this.finishNode(r, 'ImportDefaultSpecifier')), !this.eat(O.comma)) return t; } if (this.type === O.star) { const i = this.startNode(); return this.next(), this.expectContextual('as'), i.local = this.parseIdent(), this.checkLVal(i.local, !0), t.push(this.finishNode(i, 'ImportNamespaceSpecifier')), t; } for (this.expect(O.braceL); !this.eat(O.braceR);) { if (n)n = !1; else if (e.expect(O.comma), e.afterTrailingComma(O.braceR)) break; const o = e.startNode(); o.imported = e.parseIdent(!0), e.eatContextual('as') ? o.local = e.parseIdent() : (o.local = o.imported, e.isKeyword(o.local.name) && e.unexpected(o.local.start), e.reservedWordsStrict.test(o.local.name) && e.raiseRecoverable(o.local.start, `The keyword '${o.local.name}' is reserved`)), e.checkLVal(o.local, !0), t.push(e.finishNode(o, 'ImportSpecifier')); } return t; }; const W = I.prototype; W.toAssignable = function (e, t) { const n = this; if (this.options.ecmaVersion >= 6 && e) switch (e.type) { case 'Identifier': this.inAsync && e.name === 'await' && this.raise(e.start, "Can not use 'await' as identifier inside an async function"); break; case 'ObjectPattern': case 'ArrayPattern': break; case 'ObjectExpression': e.type = 'ObjectPattern'; for (let r = 0; r < e.properties.length; r++) { const i = e.properties[r]; i.kind !== 'init' && n.raise(i.key.start, "Object pattern can't contain getter or setter"), n.toAssignable(i.value, t); } break; case 'ArrayExpression': e.type = 'ArrayPattern', this.toAssignableList(e.elements, t); break; case 'AssignmentExpression': if (e.operator !== '=') { this.raise(e.left.end, "Only '=' operator can be used for specifying default value."); break; }e.type = 'AssignmentPattern', delete e.operator, this.toAssignable(e.left, t); case 'AssignmentPattern': break; case 'ParenthesizedExpression': e.expression = this.toAssignable(e.expression, t); break; case 'MemberExpression': if (!t) break; default: this.raise(e.start, 'Assigning to rvalue'); } return e; }, W.toAssignableList = function (e, t) { const n = this; let r = e.length; if (r) { const i = e[r - 1]; if (i && i.type == 'RestElement')--r; else if (i && i.type == 'SpreadElement') { i.type = 'RestElement'; const o = i.argument; this.toAssignable(o, t), o.type !== 'Identifier' && o.type !== 'MemberExpression' && o.type !== 'ArrayPattern' && this.unexpected(o.start), --r; }t && i && i.type === 'RestElement' && i.argument.type !== 'Identifier' && this.unexpected(i.argument.start); } for (let s = 0; s < r; s++) { const a = e[s]; a && n.toAssignable(a, t); } return e; }, W.parseSpread = function (e) { const t = this.startNode(); return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, 'SpreadElement'); }, W.parseRest = function (e) { const t = this.startNode(); return this.next(), t.argument = e ? this.type === O.name ? this.parseIdent() : this.unexpected() : this.type === O.name || this.type === O.bracketL ? this.parseBindingAtom() : this.unexpected(), this.finishNode(t, 'RestElement'); }, W.parseBindingAtom = function () { if (this.options.ecmaVersion < 6) return this.parseIdent(); switch (this.type) { case O.name: return this.parseIdent(); case O.bracketL: var e = this.startNode(); return this.next(), e.elements = this.parseBindingList(O.bracketR, !0, !0), this.finishNode(e, 'ArrayPattern'); case O.braceL: return this.parseObj(!0); default: this.unexpected(); } }, W.parseBindingList = function (e, t, n, r) { for (var i = this, o = [], s = !0; !this.eat(e);) if (s ? s = !1 : i.expect(O.comma), t && i.type === O.comma)o.push(null); else { if (n && i.afterTrailingComma(e)) break; if (i.type === O.ellipsis) { const a = i.parseRest(r); i.parseBindingListItem(a), o.push(a), i.type === O.comma && i.raise(i.start, 'Comma is not permitted after the rest element'), i.expect(e); break; } const u = i.parseMaybeDefault(i.start, i.startLoc); i.parseBindingListItem(u), o.push(u); } return o; }, W.parseBindingListItem = function (e) { return e; }, W.parseMaybeDefault = function (e, t, n) { if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(O.eq)) return n; const r = this.startNodeAt(e, t); return r.left = n, r.right = this.parseMaybeAssign(), this.finishNode(r, 'AssignmentPattern'); }, W.checkLVal = function (e, t, n) { const r = this; switch (e.type) { case 'Identifier': this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, `${(t ? 'Binding ' : 'Assigning to ') + e.name} in strict mode`), n && (u(n, e.name) && this.raiseRecoverable(e.start, 'Argument name clash'), n[e.name] = !0); break; case 'MemberExpression': t && this.raiseRecoverable(e.start, `${t ? 'Binding' : 'Assigning to'} member expression`); break; case 'ObjectPattern': for (let i = 0; i < e.properties.length; i++)r.checkLVal(e.properties[i].value, t, n); break; case 'ArrayPattern': for (let o = 0; o < e.elements.length; o++) { const s = e.elements[o]; s && r.checkLVal(s, t, n); } break; case 'AssignmentPattern': this.checkLVal(e.left, t, n); break; case 'RestElement': this.checkLVal(e.argument, t, n); break; case 'ParenthesizedExpression': this.checkLVal(e.expression, t, n); break; default: this.raise(e.start, `${t ? 'Binding' : 'Assigning to'} rvalue`); } }; const G = I.prototype; G.checkPropClash = function (e, t) { if (!(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) { let n; const r = e.key; switch (r.type) { case 'Identifier': n = r.name; break; case 'Literal': n = String(r.value); break; default: return; } const i = e.kind; if (this.options.ecmaVersion >= 6)n === '__proto__' && i === 'init' && (t.proto && this.raiseRecoverable(r.start, 'Redefinition of __proto__ property'), t.proto = !0); else { let o = t[n = `$${n}`]; if (o) { const s = i !== 'init'; (!this.strict && !s || !o[i]) && s ^ o.init || this.raiseRecoverable(r.start, 'Redefinition of property'); } else o = t[n] = { init: !1, get: !1, set: !1 }; o[i] = !0; } } }, G.parseExpression = function (e, t) { const n = this; const r = this.start; const i = this.startLoc; const o = this.parseMaybeAssign(e, t); if (this.type === O.comma) { const s = this.startNodeAt(r, i); for (s.expressions = [o]; this.eat(O.comma);)s.expressions.push(n.parseMaybeAssign(e, t)); return this.finishNode(s, 'SequenceExpression'); } return o; }, G.parseMaybeAssign = function (e, t, n) { if (this.inGenerator && this.isContextual('yield')) return this.parseYield(); let r = !1; let i = -1; t ? (i = t.parenthesizedAssign, t.parenthesizedAssign = -1) : (t = new z(), r = !0); const o = this.start; const s = this.startLoc; this.type != O.parenL && this.type != O.name || (this.potentialArrowAt = this.start); let a = this.parseMaybeConditional(e, t); if (n && (a = n.call(this, a, o, s)), this.type.isAssign) { this.checkPatternErrors(t, !0), r || z.call(t); const u = this.startNodeAt(o, s); return u.operator = this.value, u.left = this.type === O.eq ? this.toAssignable(a) : a, t.shorthandAssign = -1, this.checkLVal(a), this.next(), u.right = this.parseMaybeAssign(e), this.finishNode(u, 'AssignmentExpression'); } return r && this.checkExpressionErrors(t, !0), i > -1 && (t.parenthesizedAssign = i), a; }, G.parseMaybeConditional = function (e, t) { const n = this.start; const r = this.startLoc; const i = this.parseExprOps(e, t); if (this.checkExpressionErrors(t)) return i; if (this.eat(O.question)) { const o = this.startNodeAt(n, r); return o.test = i, o.consequent = this.parseMaybeAssign(), this.expect(O.colon), o.alternate = this.parseMaybeAssign(e), this.finishNode(o, 'ConditionalExpression'); } return i; }, G.parseExprOps = function (e, t) { const n = this.start; const r = this.startLoc; const i = this.parseMaybeUnary(t, !1); return this.checkExpressionErrors(t) ? i : this.parseExprOp(i, n, r, -1, e); }, G.parseExprOp = function (e, t, n, r, i) { const o = this.type.binop; if (o != null && (!i || this.type !== O._in) && o > r) { const s = this.type === O.logicalOR || this.type === O.logicalAND; const a = this.value; this.next(); const u = this.start; const c = this.startLoc; const l = this.parseExprOp(this.parseMaybeUnary(null, !1), u, c, o, i); const p = this.buildBinary(t, n, e, l, a, s); return this.parseExprOp(p, t, n, r, i); } return e; }, G.buildBinary = function (e, t, n, r, i, o) { const s = this.startNodeAt(e, t); return s.left = n, s.operator = i, s.right = r, this.finishNode(s, o ? 'LogicalExpression' : 'BinaryExpression'); }, G.parseMaybeUnary = function (e, t) { let n; const r = this; const i = this.start; const o = this.startLoc; if (this.inAsync && this.isContextual('await'))n = this.parseAwait(e), t = !0; else if (this.type.prefix) { const s = this.startNode(); const a = this.type === O.incDec; s.operator = this.value, s.prefix = !0, this.next(), s.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), a ? this.checkLVal(s.argument) : this.strict && s.operator === 'delete' && s.argument.type === 'Identifier' ? this.raiseRecoverable(s.start, 'Deleting local variable in strict mode') : t = !0, n = this.finishNode(s, a ? 'UpdateExpression' : 'UnaryExpression'); } else { if (n = this.parseExprSubscripts(e), this.checkExpressionErrors(e)) return n; for (;this.type.postfix && !this.canInsertSemicolon();) { const u = r.startNodeAt(i, o); u.operator = r.value, u.prefix = !1, u.argument = n, r.checkLVal(n), r.next(), n = r.finishNode(u, 'UpdateExpression'); } } return !t && this.eat(O.starstar) ? this.buildBinary(i, o, n, this.parseMaybeUnary(null, !1), '**', !1) : n; }, G.parseExprSubscripts = function (e) { const t = this.start; const n = this.startLoc; const r = this.parseExprAtom(e); const i = r.type === 'ArrowFunctionExpression' && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ')'; if (this.checkExpressionErrors(e) || i) return r; const o = this.parseSubscripts(r, t, n); return e && o.type === 'MemberExpression' && (e.parenthesizedAssign >= o.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= o.start && (e.parenthesizedBind = -1)), o; }, G.parseSubscripts = function (e, t, n, r) {
        for (var i, o = this, s = this.options.ecmaVersion >= 8 && e.type === 'Identifier' && e.name === 'async' && this.lastTokEnd == e.end && !this.canInsertSemicolon(); ;) {
          if ((i = o.eat(O.bracketL)) || o.eat(O.dot)) { const a = o.startNodeAt(t, n); a.object = e, a.property = i ? o.parseExpression() : o.parseIdent(!0), a.computed = !!i, i && o.expect(O.bracketR), e = o.finishNode(a, 'MemberExpression'); } else if (!r && o.eat(O.parenL)) {
            const u = new z();


            const c = o.yieldPos;


            const l = o.awaitPos; o.yieldPos = 0, o.awaitPos = 0; const p = o.parseExprList(O.parenR, o.options.ecmaVersion >= 8, !1, u); if (s && !o.canInsertSemicolon() && o.eat(O.arrow)) return o.checkPatternErrors(u, !1), o.checkYieldAwaitInDefaultParams(), o.yieldPos = c, o.awaitPos = l, o.parseArrowExpression(o.startNodeAt(t, n), p, !0); o.checkExpressionErrors(u, !0), o.yieldPos = c || o.yieldPos, o.awaitPos = l || o.awaitPos; const h = o.startNodeAt(t, n); h.callee = e, h.arguments = p, e = o.finishNode(h, 'CallExpression');
          } else { if (o.type !== O.backQuote) return e; const f = o.startNodeAt(t, n); f.tag = e, f.quasi = o.parseTemplate(), e = o.finishNode(f, 'TaggedTemplateExpression'); }
        }
      }, G.parseExprAtom = function (e) { let t; const n = this.potentialArrowAt == this.start; switch (this.type) { case O._super: this.inFunction || this.raise(this.start, "'super' outside of function or class"); case O._this: var r = this.type === O._this ? 'ThisExpression' : 'Super'; return t = this.startNode(), this.next(), this.finishNode(t, r); case O.name: var i = this.start; var o = this.startLoc; var s = this.parseIdent(this.type !== O.name); if (this.options.ecmaVersion >= 8 && s.name === 'async' && !this.canInsertSemicolon() && this.eat(O._function)) return this.parseFunction(this.startNodeAt(i, o), !1, !1, !0); if (n && !this.canInsertSemicolon()) { if (this.eat(O.arrow)) return this.parseArrowExpression(this.startNodeAt(i, o), [s], !1); if (this.options.ecmaVersion >= 8 && s.name === 'async' && this.type === O.name) return s = this.parseIdent(), !this.canInsertSemicolon() && this.eat(O.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(i, o), [s], !0); } return s; case O.regexp: var a = this.value; return t = this.parseLiteral(a.value), t.regex = { pattern: a.pattern, flags: a.flags }, t; case O.num: case O.string: return this.parseLiteral(this.value); case O._null: case O._true: case O._false: return t = this.startNode(), t.value = this.type === O._null ? null : this.type === O._true, t.raw = this.type.keyword, this.next(), this.finishNode(t, 'Literal'); case O.parenL: var u = this.start; var c = this.parseParenAndDistinguishExpression(n); return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(c) && (e.parenthesizedAssign = u), e.parenthesizedBind < 0 && (e.parenthesizedBind = u)), c; case O.bracketL: return t = this.startNode(), this.next(), t.elements = this.parseExprList(O.bracketR, !0, !0, e), this.finishNode(t, 'ArrayExpression'); case O.braceL: return this.parseObj(!1, e); case O._function: return t = this.startNode(), this.next(), this.parseFunction(t, !1); case O._class: return this.parseClass(this.startNode(), !1); case O._new: return this.parseNew(); case O.backQuote: return this.parseTemplate(); default: this.unexpected(); } }, G.parseLiteral = function (e) { const t = this.startNode(); return t.value = e, t.raw = this.input.slice(this.start, this.end), this.next(), this.finishNode(t, 'Literal'); }, G.parseParenExpression = function () { this.expect(O.parenL); const e = this.parseExpression(); return this.expect(O.parenR), e; }, G.parseParenAndDistinguishExpression = function (e) { let t; const n = this; const r = this.start; const i = this.startLoc; const o = this.options.ecmaVersion >= 8; if (this.options.ecmaVersion >= 6) { this.next(); let s; let a; const u = this.start; const c = this.startLoc; const l = []; let p = !0; let h = !1; const f = new z(); const d = this.yieldPos; const m = this.awaitPos; for (this.yieldPos = 0, this.awaitPos = 0; this.type !== O.parenR;) { if (p ? p = !1 : n.expect(O.comma), o && n.afterTrailingComma(O.parenR, !0)) { h = !0; break; } if (n.type === O.ellipsis) { s = n.start, l.push(n.parseParenItem(n.parseRest())), n.type === O.comma && n.raise(n.start, 'Comma is not permitted after the rest element'); break; }n.type !== O.parenL || a || (a = n.start), l.push(n.parseMaybeAssign(!1, f, n.parseParenItem)); } const g = this.start; const v = this.startLoc; if (this.expect(O.parenR), e && !this.canInsertSemicolon() && this.eat(O.arrow)) return this.checkPatternErrors(f, !1), this.checkYieldAwaitInDefaultParams(), a && this.unexpected(a), this.yieldPos = d, this.awaitPos = m, this.parseParenArrowList(r, i, l); l.length && !h || this.unexpected(this.lastTokStart), s && this.unexpected(s), this.checkExpressionErrors(f, !0), this.yieldPos = d || this.yieldPos, this.awaitPos = m || this.awaitPos, l.length > 1 ? ((t = this.startNodeAt(u, c)).expressions = l, this.finishNodeAt(t, 'SequenceExpression', g, v)) : t = l[0]; } else t = this.parseParenExpression(); if (this.options.preserveParens) { const y = this.startNodeAt(r, i); return y.expression = t, this.finishNode(y, 'ParenthesizedExpression'); } return t; }, G.parseParenItem = function (e) { return e; }, G.parseParenArrowList = function (e, t, n) { return this.parseArrowExpression(this.startNodeAt(e, t), n); }; const Y = []; G.parseNew = function () { const e = this.startNode(); const t = this.parseIdent(!0); if (this.options.ecmaVersion >= 6 && this.eat(O.dot)) return e.meta = t, e.property = this.parseIdent(!0), e.property.name !== 'target' && this.raiseRecoverable(e.property.start, 'The only valid meta property for new is new.target'), this.inFunction || this.raiseRecoverable(e.start, 'new.target can only be used in functions'), this.finishNode(e, 'MetaProperty'); const n = this.start; const r = this.startLoc; return e.callee = this.parseSubscripts(this.parseExprAtom(), n, r, !0), this.eat(O.parenL) ? e.arguments = this.parseExprList(O.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = Y, this.finishNode(e, 'NewExpression'); }, G.parseTemplateElement = function () { const e = this.startNode(); return e.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'), cooked: this.value }, this.next(), e.tail = this.type === O.backQuote, this.finishNode(e, 'TemplateElement'); }, G.parseTemplate = function () { const e = this; const t = this.startNode(); this.next(), t.expressions = []; let n = this.parseTemplateElement(); for (t.quasis = [n]; !n.tail;)e.expect(O.dollarBraceL), t.expressions.push(e.parseExpression()), e.expect(O.braceR), t.quasis.push(n = e.parseTemplateElement()); return this.next(), this.finishNode(t, 'TemplateLiteral'); }, G.parseObj = function (e, t) { const n = this; const r = this.startNode(); let i = !0; const o = {}; for (r.properties = [], this.next(); !this.eat(O.braceR);) { if (i)i = !1; else if (n.expect(O.comma), n.afterTrailingComma(O.braceR)) break; var s; var a; var u; var c; const l = n.startNode(); n.options.ecmaVersion >= 6 && (l.method = !1, l.shorthand = !1, (e || t) && (u = n.start, c = n.startLoc), e || (s = n.eat(O.star))), n.parsePropertyName(l), e || !(n.options.ecmaVersion >= 8) || s || l.computed || l.key.type !== 'Identifier' || l.key.name !== 'async' || n.type === O.parenL || n.type === O.colon || n.canInsertSemicolon() ? a = !1 : (a = !0, n.parsePropertyName(l, t)), n.parsePropertyValue(l, e, s, a, u, c, t), n.checkPropClash(l, o), r.properties.push(n.finishNode(l, 'Property')); } return this.finishNode(r, e ? 'ObjectPattern' : 'ObjectExpression'); }, G.parsePropertyValue = function (e, t, n, r, i, o, s) { if ((n || r) && this.type === O.colon && this.unexpected(), this.eat(O.colon))e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, s), e.kind = 'init'; else if (this.options.ecmaVersion >= 6 && this.type === O.parenL)t && this.unexpected(), e.kind = 'init', e.method = !0, e.value = this.parseMethod(n, r); else if (this.options.ecmaVersion >= 5 && !e.computed && e.key.type === 'Identifier' && (e.key.name === 'get' || e.key.name === 'set') && this.type != O.comma && this.type != O.braceR) { (n || r || t) && this.unexpected(), e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(!1); const a = e.kind === 'get' ? 0 : 1; if (e.value.params.length !== a) { const u = e.value.start; e.kind === 'get' ? this.raiseRecoverable(u, 'getter should have no params') : this.raiseRecoverable(u, 'setter should have exactly one param'); } else e.kind === 'set' && e.value.params[0].type === 'RestElement' && this.raiseRecoverable(e.value.params[0].start, 'Setter cannot use rest params'); } else this.options.ecmaVersion >= 6 && !e.computed && e.key.type === 'Identifier' ? ((this.keywords.test(e.key.name) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(e.key.name) || this.inGenerator && e.key.name == 'yield' || this.inAsync && e.key.name == 'await') && this.raiseRecoverable(e.key.start, `'${e.key.name}' can not be used as shorthand property`), e.kind = 'init', t ? e.value = this.parseMaybeDefault(i, o, e.key) : this.type === O.eq && s ? (s.shorthandAssign < 0 && (s.shorthandAssign = this.start), e.value = this.parseMaybeDefault(i, o, e.key)) : e.value = e.key, e.shorthand = !0) : this.unexpected(); }, G.parsePropertyName = function (e) { if (this.options.ecmaVersion >= 6) { if (this.eat(O.bracketL)) return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(O.bracketR), e.key; e.computed = !1; } return e.key = this.type === O.num || this.type === O.string ? this.parseExprAtom() : this.parseIdent(!0); }, G.initFunction = function (e) { e.id = null, this.options.ecmaVersion >= 6 && (e.generator = !1, e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1); }, G.parseMethod = function (e, t) { const n = this.startNode(); const r = this.inGenerator; const i = this.inAsync; const o = this.yieldPos; const s = this.awaitPos; const a = this.inFunction; return this.initFunction(n), this.options.ecmaVersion >= 6 && (n.generator = e), this.options.ecmaVersion >= 8 && (n.async = !!t), this.inGenerator = n.generator, this.inAsync = n.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, this.expect(O.parenL), n.params = this.parseBindingList(O.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(n, !1), this.inGenerator = r, this.inAsync = i, this.yieldPos = o, this.awaitPos = s, this.inFunction = a, this.finishNode(n, 'FunctionExpression'); }, G.parseArrowExpression = function (e, t, n) { const r = this.inGenerator; const i = this.inAsync; const o = this.yieldPos; const s = this.awaitPos; const a = this.inFunction; return this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!n), this.inGenerator = !1, this.inAsync = e.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0), this.inGenerator = r, this.inAsync = i, this.yieldPos = o, this.awaitPos = s, this.inFunction = a, this.finishNode(e, 'ArrowFunctionExpression'); }, G.parseFunctionBody = function (e, t) { const n = t && this.type !== O.braceL; const r = this.strict; let i = !1; if (n)e.body = this.parseMaybeAssign(), e.expression = !0; else { const o = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params); r && !o || (i = this.strictDirective(this.end)) && o && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"); const s = this.labels; this.labels = [], i && (this.strict = !0), e.body = this.parseBlock(!0), e.expression = !1, this.labels = s; }r || i ? (this.strict = !0, e.id && this.checkLVal(e.id, !0), this.checkParams(e), this.strict = r) : !t && this.isSimpleParamList(e.params) || this.checkParams(e); }, G.isSimpleParamList = function (e) { for (let t = 0; t < e.length; t++) if (e[t].type !== 'Identifier') return !1; return !0; }, G.checkParams = function (e) { for (let t = this, n = {}, r = 0; r < e.params.length; r++)t.checkLVal(e.params[r], !0, n); }, G.parseExprList = function (e, t, n, r) { for (var i = this, o = [], s = !0; !this.eat(e);) { if (s)s = !1; else if (i.expect(O.comma), t && i.afterTrailingComma(e)) break; var a; n && i.type === O.comma ? a = null : i.type === O.ellipsis ? (a = i.parseSpread(r), r && i.type === O.comma && r.trailingComma < 0 && (r.trailingComma = i.start)) : a = i.parseMaybeAssign(!1, r), o.push(a); } return o; }, G.parseIdent = function (e) { const t = this.startNode(); return e && this.options.allowReserved == 'never' && (e = !1), this.type === O.name ? (!e && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf('\\') == -1) && this.raiseRecoverable(this.start, `The keyword '${this.value}' is reserved`), this.inGenerator && this.value === 'yield' && this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator"), this.inAsync && this.value === 'await' && this.raiseRecoverable(this.start, "Can not use 'await' as identifier inside an async function"), t.name = this.value) : e && this.type.keyword ? t.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(t, 'Identifier'); }, G.parseYield = function () { this.yieldPos || (this.yieldPos = this.start); const e = this.startNode(); return this.next(), this.type == O.semi || this.canInsertSemicolon() || this.type != O.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat(O.star), e.argument = this.parseMaybeAssign()), this.finishNode(e, 'YieldExpression'); }, G.parseAwait = function () { this.awaitPos || (this.awaitPos = this.start); const e = this.startNode(); return this.next(), e.argument = this.parseMaybeUnary(null, !0), this.finishNode(e, 'AwaitExpression'); }; const X = I.prototype; X.raise = function (e, t) { const n = c(this.input, e); t += ` (${n.line}:${n.column})`; const r = new SyntaxError(t); throw r.pos = e, r.loc = n, r.raisedAt = this.pos, r; }, X.raiseRecoverable = X.raise, X.curPosition = function () { if (this.options.locations) return new N(this.curLine, this.pos - this.lineStart); }; const K = function (e, t, n) { this.type = '', this.start = t, this.end = 0, e.options.locations && (this.loc = new M(e, n)), e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile), e.options.ranges && (this.range = [t, 0]); }; const J = I.prototype; J.startNode = function () { return new K(this, this.start, this.startLoc); }, J.startNodeAt = function (e, t) { return new K(this, e, t); }, J.finishNode = function (e, t) { return f.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc); }, J.finishNodeAt = function (e, t, n, r) { return f.call(this, e, t, n, r); }; const Q = function (e, t, n, r) { this.token = e, this.isExpr = !!t, this.preserveSpace = !!n, this.override = r; }; const Z = {
        b_stat: new Q('{', !1), b_expr: new Q('{', !0), b_tmpl: new Q('${', !0), p_stat: new Q('(', !1), p_expr: new Q('(', !0), q_tmpl: new Q('`', !0, !0, (e => e.readTmplToken())), f_expr: new Q('function', !0),
      }; const ee = I.prototype; ee.initialContext = function () { return [Z.b_stat]; }, ee.braceIsBlock = function (e) { if (e === O.colon) { const t = this.curContext(); if (t === Z.b_stat || t === Z.b_expr) return !t.isExpr; } return e === O._return ? F.test(this.input.slice(this.lastTokEnd, this.start)) : e === O._else || e === O.semi || e === O.eof || e === O.parenR || (e == O.braceL ? this.curContext() === Z.b_stat : !this.exprAllowed); }, ee.updateContext = function (e) { let t; const n = this.type; n.keyword && e == O.dot ? this.exprAllowed = !1 : (t = n.updateContext) ? t.call(this, e) : this.exprAllowed = n.beforeExpr; }, O.parenR.updateContext = O.braceR.updateContext = function () { if (this.context.length != 1) { const e = this.context.pop(); e === Z.b_stat && this.curContext() === Z.f_expr ? (this.context.pop(), this.exprAllowed = !1) : this.exprAllowed = e === Z.b_tmpl || !e.isExpr; } else this.exprAllowed = !0; }, O.braceL.updateContext = function (e) { this.context.push(this.braceIsBlock(e) ? Z.b_stat : Z.b_expr), this.exprAllowed = !0; }, O.dollarBraceL.updateContext = function () { this.context.push(Z.b_tmpl), this.exprAllowed = !0; }, O.parenL.updateContext = function (e) { const t = e === O._if || e === O._for || e === O._with || e === O._while; this.context.push(t ? Z.p_stat : Z.p_expr), this.exprAllowed = !0; }, O.incDec.updateContext = function () {}, O._function.updateContext = function (e) { e.beforeExpr && e !== O.semi && e !== O._else && (e !== O.colon && e !== O.braceL || this.curContext() !== Z.b_stat) && this.context.push(Z.f_expr), this.exprAllowed = !1; }, O.backQuote.updateContext = function () { this.curContext() === Z.q_tmpl ? this.context.pop() : this.context.push(Z.q_tmpl), this.exprAllowed = !1; }; const te = function (e) { this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, e.options.locations && (this.loc = new M(e, e.startLoc, e.endLoc)), e.options.ranges && (this.range = [e.start, e.end]); }; const ne = I.prototype; const re = typeof Packages === 'object' && Object.prototype.toString.call(Packages) == '[object JavaPackage]'; ne.next = function () { this.options.onToken && this.options.onToken(new te(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken(); }, ne.getToken = function () { return this.next(), new te(this); }, typeof Symbol !== 'undefined' && (ne[Symbol.iterator] = function () { const e = this; return { next() { const t = e.getToken(); return { done: t.type === O.eof, value: t }; } }; }), ne.curContext = function () { return this.context[this.context.length - 1]; }, ne.nextToken = function () { const e = this.curContext(); return e && e.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(O.eof) : e.override ? e.override(this) : void this.readToken(this.fullCharCodeAtPos()); }, ne.readToken = function (e) { return n(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e); }, ne.fullCharCodeAtPos = function () { const e = this.input.charCodeAt(this.pos); return e <= 55295 || e >= 57344 ? e : (e << 10) + this.input.charCodeAt(this.pos + 1) - 56613888; }, ne.skipBlockComment = function () { const e = this; const t = this.options.onComment && this.curPosition(); const n = this.pos; const r = this.input.indexOf('*/', this.pos += 2); if (r === -1 && this.raise(this.pos - 2, 'Unterminated comment'), this.pos = r + 2, this.options.locations) { B.lastIndex = n; for (var i; (i = B.exec(this.input)) && i.index < this.pos;)++e.curLine, e.lineStart = i.index + i[0].length; } this.options.onComment && this.options.onComment(!0, this.input.slice(n + 2, r), n, this.pos, t, this.curPosition()); }, ne.skipLineComment = function (e) { for (var t = this, n = this.pos, r = this.options.onComment && this.curPosition(), i = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && i !== 10 && i !== 13 && i !== 8232 && i !== 8233;)++t.pos, i = t.input.charCodeAt(t.pos); this.options.onComment && this.options.onComment(!1, this.input.slice(n + e, this.pos), n, this.pos, r, this.curPosition()); }, ne.skipSpace = function () { const e = this; e:for (;this.pos < this.input.length;) { const t = e.input.charCodeAt(e.pos); switch (t) { case 32: case 160: ++e.pos; break; case 13: e.input.charCodeAt(e.pos + 1) === 10 && ++e.pos; case 10: case 8232: case 8233: ++e.pos, e.options.locations && (++e.curLine, e.lineStart = e.pos); break; case 47: switch (e.input.charCodeAt(e.pos + 1)) { case 42: e.skipBlockComment(); break; case 47: e.skipLineComment(2); break; default: break e; } break; default: if (!(t > 8 && t < 14 || t >= 5760 && D.test(String.fromCharCode(t)))) break e; ++e.pos; } } }, ne.finishToken = function (e, t) { this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition()); const n = this.type; this.type = e, this.value = t, this.updateContext(n); }, ne.readToken_dot = function () { const e = this.input.charCodeAt(this.pos + 1); if (e >= 48 && e <= 57) return this.readNumber(!0); const t = this.input.charCodeAt(this.pos + 2); return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(O.ellipsis)) : (++this.pos, this.finishToken(O.dot)); }, ne.readToken_slash = function () { const e = this.input.charCodeAt(this.pos + 1); return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(O.assign, 2) : this.finishOp(O.slash, 1); }, ne.readToken_mult_modulo_exp = function (e) { let t = this.input.charCodeAt(this.pos + 1); let n = 1; let r = e === 42 ? O.star : O.modulo; return this.options.ecmaVersion >= 7 && t === 42 && (++n, r = O.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(O.assign, n + 1) : this.finishOp(r, n); }, ne.readToken_pipe_amp = function (e) { const t = this.input.charCodeAt(this.pos + 1); return t === e ? this.finishOp(e === 124 ? O.logicalOR : O.logicalAND, 2) : t === 61 ? this.finishOp(O.assign, 2) : this.finishOp(e === 124 ? O.bitwiseOR : O.bitwiseAND, 1); }, ne.readToken_caret = function () { return this.input.charCodeAt(this.pos + 1) === 61 ? this.finishOp(O.assign, 2) : this.finishOp(O.bitwiseXOR, 1); }, ne.readToken_plus_min = function (e) { const t = this.input.charCodeAt(this.pos + 1); return t === e ? t == 45 && this.input.charCodeAt(this.pos + 2) == 62 && F.test(this.input.slice(this.lastTokEnd, this.pos)) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(O.incDec, 2) : t === 61 ? this.finishOp(O.assign, 2) : this.finishOp(O.plusMin, 1); }, ne.readToken_lt_gt = function (e) { const t = this.input.charCodeAt(this.pos + 1); let n = 1; return t === e ? (n = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + n) === 61 ? this.finishOp(O.assign, n + 1) : this.finishOp(O.bitShift, n)) : t == 33 && e == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45 ? (this.inModule && this.unexpected(), this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (n = 2), this.finishOp(O.relational, n)); }, ne.readToken_eq_excl = function (e) { const t = this.input.charCodeAt(this.pos + 1); return t === 61 ? this.finishOp(O.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(O.arrow)) : this.finishOp(e === 61 ? O.eq : O.prefix, 1); }, ne.getTokenFromCode = function (e) { switch (e) { case 46: return this.readToken_dot(); case 40: return ++this.pos, this.finishToken(O.parenL); case 41: return ++this.pos, this.finishToken(O.parenR); case 59: return ++this.pos, this.finishToken(O.semi); case 44: return ++this.pos, this.finishToken(O.comma); case 91: return ++this.pos, this.finishToken(O.bracketL); case 93: return ++this.pos, this.finishToken(O.bracketR); case 123: return ++this.pos, this.finishToken(O.braceL); case 125: return ++this.pos, this.finishToken(O.braceR); case 58: return ++this.pos, this.finishToken(O.colon); case 63: return ++this.pos, this.finishToken(O.question); case 96: if (this.options.ecmaVersion < 6) break; return ++this.pos, this.finishToken(O.backQuote); case 48: var t = this.input.charCodeAt(this.pos + 1); if (t === 120 || t === 88) return this.readRadixNumber(16); if (this.options.ecmaVersion >= 6) { if (t === 111 || t === 79) return this.readRadixNumber(8); if (t === 98 || t === 66) return this.readRadixNumber(2); } case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.readNumber(!1); case 34: case 39: return this.readString(e); case 47: return this.readToken_slash(); case 37: case 42: return this.readToken_mult_modulo_exp(e); case 124: case 38: return this.readToken_pipe_amp(e); case 94: return this.readToken_caret(); case 43: case 45: return this.readToken_plus_min(e); case 60: case 62: return this.readToken_lt_gt(e); case 61: case 33: return this.readToken_eq_excl(e); case 126: return this.finishOp(O.prefix, 1); } this.raise(this.pos, `Unexpected character '${m(e)}'`); }, ne.finishOp = function (e, t) { const n = this.input.slice(this.pos, this.pos + t); return this.pos += t, this.finishToken(e, n); }; const ie = !!d('ï¿¿', 'u'); ne.readRegexp = function () { for (var e, t, n = this, r = this.pos; ;) { n.pos >= n.input.length && n.raise(r, 'Unterminated regular expression'); const i = n.input.charAt(n.pos); if (F.test(i) && n.raise(r, 'Unterminated regular expression'), e)e = !1; else { if (i === '[')t = !0; else if (i === ']' && t)t = !1; else if (i === '/' && !t) break; e = i === '\\'; }++n.pos; } const o = this.input.slice(r, this.pos); ++this.pos; const s = this.readWord1(); let a = o; let u = ''; if (s) { let c = /^[gim]*$/; this.options.ecmaVersion >= 6 && (c = /^[gimuy]*$/), c.test(s) || this.raise(r, 'Invalid regular expression flag'), s.indexOf('u') >= 0 && (ie ? u = 'u' : (a = (a = a.replace(/\\u\{([0-9a-fA-F]+)\}/g, (e, t, i) => (t = Number(`0x${t}`)) > 1114111 && n.raise(r + i + 3, 'Code point out of bounds'), 'x')).replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x'), u = u.replace('u', ''))); } let l = null; return re || (d(a, u, r, this), l = d(o, s)), this.finishToken(O.regexp, { pattern: o, flags: s, value: l }); }, ne.readInt = function (e, t) { for (var n = this, r = this.pos, i = 0, o = 0, s = t == null ? 1 / 0 : t; o < s; ++o) { var a; const u = n.input.charCodeAt(n.pos); if ((a = u >= 97 ? u - 97 + 10 : u >= 65 ? u - 65 + 10 : u >= 48 && u <= 57 ? u - 48 : 1 / 0) >= e) break; ++n.pos, i = i * e + a; } return this.pos === r || t != null && this.pos - r !== t ? null : i; }, ne.readRadixNumber = function (e) { this.pos += 2; const t = this.readInt(e); return t == null && this.raise(this.start + 2, `Expected number in radix ${e}`), n(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'), this.finishToken(O.num, t); }, ne.readNumber = function (e) { const t = this.pos; let r = !1; let i = this.input.charCodeAt(this.pos) === 48; e || this.readInt(10) !== null || this.raise(t, 'Invalid number'), i && this.pos == t + 1 && (i = !1); let o = this.input.charCodeAt(this.pos); o !== 46 || i || (++this.pos, this.readInt(10), r = !0, o = this.input.charCodeAt(this.pos)), o !== 69 && o !== 101 || i || ((o = this.input.charCodeAt(++this.pos)) !== 43 && o !== 45 || ++this.pos, this.readInt(10) === null && this.raise(t, 'Invalid number'), r = !0), n(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'); let s; const a = this.input.slice(t, this.pos); return r ? s = parseFloat(a) : i && a.length !== 1 ? /[89]/.test(a) || this.strict ? this.raise(t, 'Invalid number') : s = parseInt(a, 8) : s = parseInt(a, 10), this.finishToken(O.num, s); }, ne.readCodePoint = function () { let e; if (this.input.charCodeAt(this.pos) === 123) { this.options.ecmaVersion < 6 && this.unexpected(); const t = ++this.pos; e = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos), ++this.pos, e > 1114111 && this.raise(t, 'Code point out of bounds'); } else e = this.readHexChar(4); return e; }, ne.readString = function (e) { for (var t = this, n = '', r = ++this.pos; ;) { t.pos >= t.input.length && t.raise(t.start, 'Unterminated string constant'); const i = t.input.charCodeAt(t.pos); if (i === e) break; i === 92 ? (n += t.input.slice(r, t.pos), n += t.readEscapedChar(!1), r = t.pos) : (s(i) && t.raise(t.start, 'Unterminated string constant'), ++t.pos); } return n += this.input.slice(r, this.pos++), this.finishToken(O.string, n); }, ne.readTmplToken = function () { for (let e = this, t = '', n = this.pos; ;) { e.pos >= e.input.length && e.raise(e.start, 'Unterminated template'); const r = e.input.charCodeAt(e.pos); if (r === 96 || r === 36 && e.input.charCodeAt(e.pos + 1) === 123) return e.pos === e.start && e.type === O.template ? r === 36 ? (e.pos += 2, e.finishToken(O.dollarBraceL)) : (++e.pos, e.finishToken(O.backQuote)) : (t += e.input.slice(n, e.pos), e.finishToken(O.template, t)); if (r === 92)t += e.input.slice(n, e.pos), t += e.readEscapedChar(!0), n = e.pos; else if (s(r)) { switch (t += e.input.slice(n, e.pos), ++e.pos, r) { case 13: e.input.charCodeAt(e.pos) === 10 && ++e.pos; case 10: t += '\n'; break; default: t += String.fromCharCode(r); }e.options.locations && (++e.curLine, e.lineStart = e.pos), n = e.pos; } else ++e.pos; } }, ne.readEscapedChar = function (e) { const t = this.input.charCodeAt(++this.pos); switch (++this.pos, t) { case 110: return '\n'; case 114: return '\r'; case 120: return String.fromCharCode(this.readHexChar(2)); case 117: return m(this.readCodePoint()); case 116: return '\t'; case 98: return '\b'; case 118: return '\v'; case 102: return '\f'; case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), ''; default: if (t >= 48 && t <= 55) { let n = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]; let r = parseInt(n, 8); return r > 255 && (n = n.slice(0, -1), r = parseInt(n, 8)), n !== '0' && (this.strict || e) && this.raise(this.pos - 2, 'Octal literal in strict mode'), this.pos += n.length - 1, String.fromCharCode(r); } return String.fromCharCode(t); } }, ne.readHexChar = function (e) { const t = this.pos; const n = this.readInt(16, e); return n === null && this.raise(t, 'Bad character escape sequence'), n; }, ne.readWord1 = function () { const e = this; this.containsEsc = !1; for (var t = '', i = !0, o = this.pos, s = this.options.ecmaVersion >= 6; this.pos < this.input.length;) { const a = e.fullCharCodeAtPos(); if (r(a, s))e.pos += a <= 65535 ? 1 : 2; else { if (a !== 92) break; e.containsEsc = !0, t += e.input.slice(o, e.pos); const u = e.pos; e.input.charCodeAt(++e.pos) != 117 && e.raise(e.pos, 'Expecting Unicode escape sequence \\uXXXX'), ++e.pos; const c = e.readCodePoint(); (i ? n : r)(c, s) || e.raise(u, 'Invalid Unicode escape'), t += m(c), o = e.pos; }i = !1; } return t + this.input.slice(o, this.pos); }, ne.readWord = function () { const e = this.readWord1(); let t = O.name; return this.keywords.test(e) && (this.containsEsc && this.raiseRecoverable(this.start, `Escape sequence in keyword ${e}`), t = T[e]), this.finishToken(t, e); }; e.version = '4.0.11', e.parse = function (e, t) { return new I(t, e).parse(); }, e.parseExpressionAt = function (e, t, n) { const r = new I(n, e, t); return r.nextToken(), r.parseExpression(); }, e.tokenizer = function (e, t) { return new I(t, e); }, e.addLooseExports = function (t, n, r) { e.parse_dammit = t, e.LooseParser = n, e.pluginsLoose = r; }, e.Parser = I, e.plugins = P, e.defaultOptions = R, e.Position = N, e.SourceLocation = M, e.getLineInfo = c, e.Node = K, e.TokenType = A, e.tokTypes = O, e.keywordTypes = T, e.TokContext = Q, e.tokContexts = Z, e.isIdentifierChar = r, e.isIdentifierStart = n, e.Token = te, e.isNewLine = s, e.lineBreak = F, e.lineBreakG = B, Object.defineProperty(e, '__esModule', { value: !0 });
    }));
  }, {}],
  3: [function (e, t, n) {
    !(function (e, r) { typeof n === 'object' && void 0 !== t ? r(n) : typeof define === 'function' && define.amd ? define(['exports'], r) : r((e.acorn = e.acorn || {}, e.acorn.walk = e.acorn.walk || {})); }(this, (e) => {
      function t(e) { return typeof e === 'string' ? function (t) { return t == e; } : e || function () { return !0; }; } function n(e, t, n) { n(e, t); } function r(e, t, n) {} const i = function (e, t) { this.node = e, this.state = t; }; const o = Object.create || function (e) { function t() {} return t.prototype = e, new t(); }; const s = {}; s.Program = s.BlockStatement = function (e, t, n) { for (let r = 0; r < e.body.length; ++r)n(e.body[r], t, 'Statement'); }, s.Statement = n, s.EmptyStatement = r, s.ExpressionStatement = s.ParenthesizedExpression = function (e, t, n) { return n(e.expression, t, 'Expression'); }, s.IfStatement = function (e, t, n) { n(e.test, t, 'Expression'), n(e.consequent, t, 'Statement'), e.alternate && n(e.alternate, t, 'Statement'); }, s.LabeledStatement = function (e, t, n) { return n(e.body, t, 'Statement'); }, s.BreakStatement = s.ContinueStatement = r, s.WithStatement = function (e, t, n) { n(e.object, t, 'Expression'), n(e.body, t, 'Statement'); }, s.SwitchStatement = function (e, t, n) { n(e.discriminant, t, 'Expression'); for (let r = 0; r < e.cases.length; ++r) { const i = e.cases[r]; i.test && n(i.test, t, 'Expression'); for (let o = 0; o < i.consequent.length; ++o)n(i.consequent[o], t, 'Statement'); } }, s.ReturnStatement = s.YieldExpression = s.AwaitExpression = function (e, t, n) { e.argument && n(e.argument, t, 'Expression'); }, s.ThrowStatement = s.SpreadElement = function (e, t, n) { return n(e.argument, t, 'Expression'); }, s.TryStatement = function (e, t, n) { n(e.block, t, 'Statement'), e.handler && n(e.handler, t), e.finalizer && n(e.finalizer, t, 'Statement'); }, s.CatchClause = function (e, t, n) { n(e.param, t, 'Pattern'), n(e.body, t, 'ScopeBody'); }, s.WhileStatement = s.DoWhileStatement = function (e, t, n) { n(e.test, t, 'Expression'), n(e.body, t, 'Statement'); }, s.ForStatement = function (e, t, n) { e.init && n(e.init, t, 'ForInit'), e.test && n(e.test, t, 'Expression'), e.update && n(e.update, t, 'Expression'), n(e.body, t, 'Statement'); }, s.ForInStatement = s.ForOfStatement = function (e, t, n) { n(e.left, t, 'ForInit'), n(e.right, t, 'Expression'), n(e.body, t, 'Statement'); }, s.ForInit = function (e, t, n) { e.type == 'VariableDeclaration' ? n(e, t) : n(e, t, 'Expression'); }, s.DebuggerStatement = r, s.FunctionDeclaration = function (e, t, n) { return n(e, t, 'Function'); }, s.VariableDeclaration = function (e, t, n) { for (let r = 0; r < e.declarations.length; ++r)n(e.declarations[r], t); }, s.VariableDeclarator = function (e, t, n) { n(e.id, t, 'Pattern'), e.init && n(e.init, t, 'Expression'); }, s.Function = function (e, t, n) { e.id && n(e.id, t, 'Pattern'); for (let r = 0; r < e.params.length; r++)n(e.params[r], t, 'Pattern'); n(e.body, t, e.expression ? 'ScopeExpression' : 'ScopeBody'); }, s.ScopeBody = function (e, t, n) { return n(e, t, 'Statement'); }, s.ScopeExpression = function (e, t, n) { return n(e, t, 'Expression'); }, s.Pattern = function (e, t, n) { e.type == 'Identifier' ? n(e, t, 'VariablePattern') : e.type == 'MemberExpression' ? n(e, t, 'MemberPattern') : n(e, t); }, s.VariablePattern = r, s.MemberPattern = n, s.RestElement = function (e, t, n) { return n(e.argument, t, 'Pattern'); }, s.ArrayPattern = function (e, t, n) { for (let r = 0; r < e.elements.length; ++r) { const i = e.elements[r]; i && n(i, t, 'Pattern'); } }, s.ObjectPattern = function (e, t, n) { for (let r = 0; r < e.properties.length; ++r)n(e.properties[r].value, t, 'Pattern'); }, s.Expression = n, s.ThisExpression = s.Super = s.MetaProperty = r, s.ArrayExpression = function (e, t, n) { for (let r = 0; r < e.elements.length; ++r) { const i = e.elements[r]; i && n(i, t, 'Expression'); } }, s.ObjectExpression = function (e, t, n) { for (let r = 0; r < e.properties.length; ++r)n(e.properties[r], t); }, s.FunctionExpression = s.ArrowFunctionExpression = s.FunctionDeclaration, s.SequenceExpression = s.TemplateLiteral = function (e, t, n) { for (let r = 0; r < e.expressions.length; ++r)n(e.expressions[r], t, 'Expression'); }, s.UnaryExpression = s.UpdateExpression = function (e, t, n) { n(e.argument, t, 'Expression'); }, s.BinaryExpression = s.LogicalExpression = function (e, t, n) { n(e.left, t, 'Expression'), n(e.right, t, 'Expression'); }, s.AssignmentExpression = s.AssignmentPattern = function (e, t, n) { n(e.left, t, 'Pattern'), n(e.right, t, 'Expression'); }, s.ConditionalExpression = function (e, t, n) { n(e.test, t, 'Expression'), n(e.consequent, t, 'Expression'), n(e.alternate, t, 'Expression'); }, s.NewExpression = s.CallExpression = function (e, t, n) { if (n(e.callee, t, 'Expression'), e.arguments) for (let r = 0; r < e.arguments.length; ++r)n(e.arguments[r], t, 'Expression'); }, s.MemberExpression = function (e, t, n) { n(e.object, t, 'Expression'), e.computed && n(e.property, t, 'Expression'); }, s.ExportNamedDeclaration = s.ExportDefaultDeclaration = function (e, t, n) { e.declaration && n(e.declaration, t, e.type == 'ExportNamedDeclaration' || e.declaration.id ? 'Statement' : 'Expression'), e.source && n(e.source, t, 'Expression'); }, s.ExportAllDeclaration = function (e, t, n) { n(e.source, t, 'Expression'); }, s.ImportDeclaration = function (e, t, n) { for (let r = 0; r < e.specifiers.length; r++)n(e.specifiers[r], t); n(e.source, t, 'Expression'); }, s.ImportSpecifier = s.ImportDefaultSpecifier = s.ImportNamespaceSpecifier = s.Identifier = s.Literal = r, s.TaggedTemplateExpression = function (e, t, n) { n(e.tag, t, 'Expression'), n(e.quasi, t); }, s.ClassDeclaration = s.ClassExpression = function (e, t, n) { return n(e, t, 'Class'); }, s.Class = function (e, t, n) { e.id && n(e.id, t, 'Pattern'), e.superClass && n(e.superClass, t, 'Expression'); for (let r = 0; r < e.body.body.length; r++)n(e.body.body[r], t); }, s.MethodDefinition = s.Property = function (e, t, n) { e.computed && n(e.key, t, 'Expression'), n(e.value, t, 'Expression'); }, e.simple = function (t, n, r, i, o) { r || (r = e.base), (function e(t, i, o) { const s = o || t.type; const a = n[s]; r[s](t, i, e), a && a(t, i); }(t, i, o)); }, e.ancestor = function (t, n, r, i) { r || (r = e.base); const o = []; !(function e(t, i, s) { const a = s || t.type; const u = n[a]; const c = t != o[o.length - 1]; c && o.push(t), r[a](t, i, e), u && u(t, i || o, o), c && o.pop(); }(t, i)); }, e.recursive = function (t, n, r, i, o) { const s = r ? e.make(r, i) : i; !(function e(t, n, r) { s[r || t.type](t, n, e); }(t, n, o)); }, e.findNodeAt = function (n, r, o, s, a, u) { s = t(s), a || (a = e.base); try { !(function e(t, n, u) { const c = u || t.type; if ((r == null || t.start <= r) && (o == null || t.end >= o) && a[c](t, n, e), (r == null || t.start == r) && (o == null || t.end == o) && s(c, t)) throw new i(t, n); }(n, u)); } catch (e) { if (e instanceof i) return e; throw e; } }, e.findNodeAround = function (n, r, o, s, a) { o = t(o), s || (s = e.base); try { !(function e(t, n, a) { const u = a || t.type; if (!(t.start > r || t.end < r) && (s[u](t, n, e), o(u, t))) throw new i(t, n); }(n, a)); } catch (e) { if (e instanceof i) return e; throw e; } }, e.findNodeAfter = function (n, r, o, s, a) { o = t(o), s || (s = e.base); try { !(function e(t, n, a) { if (!(t.end < r)) { const u = a || t.type; if (t.start >= r && o(u, t)) throw new i(t, n); s[u](t, n, e); } }(n, a)); } catch (e) { if (e instanceof i) return e; throw e; } }, e.findNodeBefore = function (n, r, o, s, a) { o = t(o), s || (s = e.base); let u; return (function e(t, n, a) { if (!(t.start > r)) { const c = a || t.type; t.end <= r && (!u || u.node.end < t.end) && o(c, t) && (u = new i(t, n)), s[c](t, n, e); } }(n, a)), u; }, e.make = function (t, n) { n || (n = e.base); const r = o(n); for (const i in t)r[i] = t[i]; return r; }, e.base = s, Object.defineProperty(e, '__esModule', { value: !0 });
    }));
  }, {}],
  4: [function (e, t, n) {
    (function (n, r) {
      t.exports = function (t, i) { function o(e) { let t; let n; for (t = 0; e[t]; t += 1) if ((n = e[t]) === '.')e.splice(t, 1), t -= 1; else if (n === '..') { if (t === 1 && (e[2] === '..' || e[0] === '..')) break; t > 0 && (e.splice(t - 1, 2), t -= 2); } } function s(e, t) { let n; return e && e.charAt(0) === '.' && t && (o(n = (n = (n = t.split('/')).slice(0, n.length - 1)).concat(e.split('/'))), e = n.join('/')), e; } function a(e) { return function (t) { return s(t, e); }; } function u(e) { function t(t) { d[e] = t; } return t.fromText = function (e, t) { throw new Error('amdefine does not implement load.fromText'); }, t; } function c(e, n, o) { let s; let a; let u; let c; if (e)a = d[e] = {}, s = p(i, a, u = { id: e, uri: r, exports: a }, e); else { if (m) throw new Error('amdefine with no module ID cannot be called more than once per file.'); m = !0, a = t.exports, s = p(i, a, u = t, t.id); }n && (n = n.map(e => s(e))), void 0 !== (c = typeof o === 'function' ? o.apply(u.exports, n) : o) && (u.exports = c, e && (d[e] = u.exports)); } function l(e, t, n) { Array.isArray(e) ? (n = t, t = e, e = void 0) : typeof e !== 'string' && (n = e, e = t = void 0), t && !Array.isArray(t) && (n = t, t = void 0), t || (t = ['require', 'exports', 'module']), e ? f[e] = [e, t, n] : c(e, t, n); } let p; let h; var f = {}; var d = {}; var m = !1; const g = e('path'); return p = function (e, t, r, i) { function o(o, s) { if (typeof o === 'string') return h(e, t, r, o, i); o = o.map(n => h(e, t, r, n, i)), s && n.nextTick(() => { s(...o); }); } return o.toUrl = function (e) { return e.indexOf('.') === 0 ? s(e, g.dirname(r.filename)) : e; }, o; }, i = i || function () { return t.require(...arguments); }, h = function (e, t, n, r, i) { let o; let l; const m = r.indexOf('!'); const g = r; if (m === -1) { if ((r = s(r, i)) === 'require') return p(e, t, n, i); if (r === 'exports') return t; if (r === 'module') return n; if (d.hasOwnProperty(r)) return d[r]; if (f[r]) return c(...f[r]), d[r]; if (e) return e(g); throw new Error(`No module with ID: ${r}`); } return o = r.substring(0, m), r = r.substring(m + 1, r.length), l = h(e, t, n, o, i), r = l.normalize ? l.normalize(r, a(i)) : s(r, i), d[r] ? d[r] : (l.load(r, p(e, t, n, i), u(r), {}), d[r]); }, l.require = function (e) { return d[e] ? d[e] : f[e] ? (c(...f[e]), d[e]) : void 0; }, l.amd = {}, l; };
    }).call(this, e('_process'), '/node_modules/amdefine/amdefine.js');
  }, { _process: 31, path: 30 }],
  5: [function (e, t, n) {
    function r(e) { let t; (t = s.length ? s.pop() : new i()).task = e, o(t); } function i() { this.task = null; } var o = e('./raw'); var s = []; const a = []; const u = o.makeRequestCallFromTimer(() => { if (a.length) throw a.shift(); }); t.exports = r, i.prototype.call = function () { try { this.task.call(); } catch (e) { r.onerror ? r.onerror(e) : (a.push(e), u()); } finally { this.task = null, s[s.length] = this; } };
  }, { './raw': 6 }],
  6: [function (e, t, n) {
    (function (e) {
      function n(e) { s.length || (o(), a = !0), s[s.length] = e; } function r() { for (;u < s.length;) { const e = u; if (u += 1, s[e].call(), u > c) { for (let t = 0, n = s.length - u; t < n; t++)s[t] = s[t + u]; s.length -= u, u = 0; } }s.length = 0, u = 0, a = !1; } function i(e) { return function () { function t() { clearTimeout(n), clearInterval(r), e(); } var n = setTimeout(t, 0); var r = setInterval(t, 50); }; }t.exports = n; let o; var s = []; var a = !1; var u = 0; var c = 1024; const l = void 0 !== e ? e : self; const p = l.MutationObserver || l.WebKitMutationObserver; o = typeof p === 'function' ? (function (e) { let t = 1; const n = new p(e); const r = document.createTextNode(''); return n.observe(r, { characterData: !0 }), function () { t = -t, r.data = t; }; }(r)) : i(r), n.requestFlush = o, n.makeRequestCallFromTimer = i;
    }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
  }, {}],
  7: [function (e, t, n) {
    (function (n) {
      function r(e, t) { if (e === t) return 0; for (var n = e.length, r = t.length, i = 0, o = Math.min(n, r); i < o; ++i) if (e[i] !== t[i]) { n = e[i], r = t[i]; break; } return n < r ? -1 : r < n ? 1 : 0; } function i(e) { return n.Buffer && typeof n.Buffer.isBuffer === 'function' ? n.Buffer.isBuffer(e) : !(e == null || !e._isBuffer); } function o(e) { return Object.prototype.toString.call(e); } function s(e) { return !i(e) && (typeof n.ArrayBuffer === 'function' && (typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(e) : !!e && (e instanceof DataView || !!(e.buffer && e.buffer instanceof ArrayBuffer)))); } function a(e) { if (_.isFunction(e)) { if (k) return e.name; const t = e.toString().match(A); return t && t[1]; } } function u(e, t) { return typeof e === 'string' ? e.length < t ? e : e.slice(0, t) : e; } function c(e) { if (k || !_.isFunction(e)) return _.inspect(e); const t = a(e); return `[Function${t ? `: ${t}` : ''}]`; } function l(e) { return `${u(c(e.actual), 128)} ${e.operator} ${u(c(e.expected), 128)}`; } function p(e, t, n, r, i) {
        throw new E.AssertionError({
          message: n, actual: e, expected: t, operator: r, stackStartFunction: i,
        });
      } function h(e, t) { e || p(e, !0, t, '==', E.ok); } function f(e, t, n, a) { if (e === t) return !0; if (i(e) && i(t)) return r(e, t) === 0; if (_.isDate(e) && _.isDate(t)) return e.getTime() === t.getTime(); if (_.isRegExp(e) && _.isRegExp(t)) return e.source === t.source && e.global === t.global && e.multiline === t.multiline && e.lastIndex === t.lastIndex && e.ignoreCase === t.ignoreCase; if (e !== null && typeof e === 'object' || t !== null && typeof t === 'object') { if (s(e) && s(t) && o(e) === o(t) && !(e instanceof Float32Array || e instanceof Float64Array)) return r(new Uint8Array(e.buffer), new Uint8Array(t.buffer)) === 0; if (i(e) !== i(t)) return !1; const u = (a = a || { actual: [], expected: [] }).actual.indexOf(e); return u !== -1 && u === a.expected.indexOf(t) || (a.actual.push(e), a.expected.push(t), m(e, t, n, a)); } return n ? e === t : e == t; } function d(e) { return Object.prototype.toString.call(e) == '[object Arguments]'; } function m(e, t, n, r) { if (e === null || void 0 === e || t === null || void 0 === t) return !1; if (_.isPrimitive(e) || _.isPrimitive(t)) return e === t; if (n && Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1; const i = d(e); const o = d(t); if (i && !o || !i && o) return !1; if (i) return e = w.call(e), t = w.call(t), f(e, t, n); let s; let a; const u = C(e); const c = C(t); if (u.length !== c.length) return !1; for (u.sort(), c.sort(), a = u.length - 1; a >= 0; a--) if (u[a] !== c[a]) return !1; for (a = u.length - 1; a >= 0; a--) if (s = u[a], !f(e[s], t[s], n, r)) return !1; return !0; } function g(e, t, n) { f(e, t, !0) && p(e, t, n, 'notDeepStrictEqual', g); } function v(e, t) { if (!e || !t) return !1; if (Object.prototype.toString.call(t) == '[object RegExp]') return t.test(e); try { if (e instanceof t) return !0; } catch (e) {} return !Error.isPrototypeOf(t) && !0 === t.call({}, e); } function y(e) { let t; try { e(); } catch (e) { t = e; } return t; } function b(e, t, n, r) { let i; if (typeof t !== 'function') throw new TypeError('"block" argument must be a function'); typeof n === 'string' && (r = n, n = null), i = y(t), r = (n && n.name ? ` (${n.name}).` : '.') + (r ? ` ${r}` : '.'), e && !i && p(i, n, `Missing expected exception${r}`); const o = typeof r === 'string'; const s = !e && _.isError(i); const a = !e && i && !n; if ((s && o && v(i, n) || a) && p(i, n, `Got unwanted exception${r}`), e && i && n && !v(i, n) || !e && i) throw i; } var _ = e('util/'); const x = Object.prototype.hasOwnProperty; var w = Array.prototype.slice; var k = function () {}.name === 'foo'; var E = t.exports = h; var A = /\s*function\s+([^\(\s]*)\s*/; E.AssertionError = function (e) { this.name = 'AssertionError', this.actual = e.actual, this.expected = e.expected, this.operator = e.operator, e.message ? (this.message = e.message, this.generatedMessage = !1) : (this.message = l(this), this.generatedMessage = !0); const t = e.stackStartFunction || p; if (Error.captureStackTrace)Error.captureStackTrace(this, t); else { const n = new Error(); if (n.stack) { let r = n.stack; const i = a(t); const o = r.indexOf(`\n${i}`); if (o >= 0) { const s = r.indexOf('\n', o + 1); r = r.substring(s + 1); } this.stack = r; } } }, _.inherits(E.AssertionError, Error), E.fail = p, E.ok = h, E.equal = function (e, t, n) { e != t && p(e, t, n, '==', E.equal); }, E.notEqual = function (e, t, n) { e == t && p(e, t, n, '!=', E.notEqual); }, E.deepEqual = function (e, t, n) { f(e, t, !1) || p(e, t, n, 'deepEqual', E.deepEqual); }, E.deepStrictEqual = function (e, t, n) { f(e, t, !0) || p(e, t, n, 'deepStrictEqual', E.deepStrictEqual); }, E.notDeepEqual = function (e, t, n) { f(e, t, !1) && p(e, t, n, 'notDeepEqual', E.notDeepEqual); }, E.notDeepStrictEqual = g, E.strictEqual = function (e, t, n) { e !== t && p(e, t, n, '===', E.strictEqual); }, E.notStrictEqual = function (e, t, n) { e === t && p(e, t, n, '!==', E.notStrictEqual); }, E.throws = function (e, t, n) { b(!0, e, t, n); }, E.doesNotThrow = function (e, t, n) { b(!1, e, t, n); }, E.ifError = function (e) { if (e) throw e; }; var C = Object.keys || function (e) { const t = []; for (const n in e)x.call(e, n) && t.push(n); return t; };
    }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
  }, { 'util/': 152 }],
  8: [function (e, t, n) {
    function r(e) { const t = e.length; if (t % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4'); return e[t - 2] === '=' ? 2 : e[t - 1] === '=' ? 1 : 0; } function i(e) { return s[e >> 18 & 63] + s[e >> 12 & 63] + s[e >> 6 & 63] + s[63 & e]; } function o(e, t, n) { for (var r, o = [], s = t; s < n; s += 3)r = (e[s] << 16) + (e[s + 1] << 8) + e[s + 2], o.push(i(r)); return o.join(''); }n.byteLength = function (e) { return 3 * e.length / 4 - r(e); }, n.toByteArray = function (e) { let t; let n; let i; let o; let s; const c = e.length; o = r(e), s = new u(3 * c / 4 - o), n = o > 0 ? c - 4 : c; let l = 0; for (t = 0; t < n; t += 4)i = a[e.charCodeAt(t)] << 18 | a[e.charCodeAt(t + 1)] << 12 | a[e.charCodeAt(t + 2)] << 6 | a[e.charCodeAt(t + 3)], s[l++] = i >> 16 & 255, s[l++] = i >> 8 & 255, s[l++] = 255 & i; return o === 2 ? (i = a[e.charCodeAt(t)] << 2 | a[e.charCodeAt(t + 1)] >> 4, s[l++] = 255 & i) : o === 1 && (i = a[e.charCodeAt(t)] << 10 | a[e.charCodeAt(t + 1)] << 4 | a[e.charCodeAt(t + 2)] >> 2, s[l++] = i >> 8 & 255, s[l++] = 255 & i), s; }, n.fromByteArray = function (e) { for (var t, n = e.length, r = n % 3, i = '', a = [], u = 0, c = n - r; u < c; u += 16383)a.push(o(e, u, u + 16383 > c ? c : u + 16383)); return r === 1 ? (t = e[n - 1], i += s[t >> 2], i += s[t << 4 & 63], i += '==') : r === 2 && (t = (e[n - 2] << 8) + e[n - 1], i += s[t >> 10], i += s[t >> 4 & 63], i += s[t << 2 & 63], i += '='), a.push(i), a.join(''); }; for (var s = [], a = [], u = typeof Uint8Array !== 'undefined' ? Uint8Array : Array, c = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', l = 0, p = c.length; l < p; ++l)s[l] = c[l], a[c.charCodeAt(l)] = l; a['-'.charCodeAt(0)] = 62, a['_'.charCodeAt(0)] = 63;
  }, {}],
  9: [function (e, t, n) {}, {}],
  10: [function (e, t, n) { arguments[4][9][0].apply(n, arguments); }, { dup: 9 }],
  11: [function (e, t, n) {
    function r(e) { if (e > X) throw new RangeError('Invalid typed array length'); const t = new Uint8Array(e); return t.__proto__ = i.prototype, t; } function i(e, t, n) { if (typeof e === 'number') { if (typeof t === 'string') throw new Error('If encoding is specified then the first argument must be a string'); return u(e); } return o(e, t, n); } function o(e, t, n) { if (typeof e === 'number') throw new TypeError('"value" argument must not be a number'); return q(e) ? p(e, t, n) : typeof e === 'string' ? c(e, t) : h(e); } function s(e) { if (typeof e !== 'number') throw new TypeError('"size" argument must be a number'); if (e < 0) throw new RangeError('"size" argument must not be negative'); } function a(e, t, n) { return s(e), e <= 0 ? r(e) : void 0 !== t ? typeof n === 'string' ? r(e).fill(t, n) : r(e).fill(t) : r(e); } function u(e) { return s(e), r(e < 0 ? 0 : 0 | f(e)); } function c(e, t) { if (typeof t === 'string' && t !== '' || (t = 'utf8'), !i.isEncoding(t)) throw new TypeError('"encoding" must be a valid string encoding'); const n = 0 | d(e, t); let o = r(n); const s = o.write(e, t); return s !== n && (o = o.slice(0, s)), o; } function l(e) { for (var t = e.length < 0 ? 0 : 0 | f(e.length), n = r(t), i = 0; i < t; i += 1)n[i] = 255 & e[i]; return n; } function p(e, t, n) { if (t < 0 || e.byteLength < t) throw new RangeError("'offset' is out of bounds"); if (e.byteLength < t + (n || 0)) throw new RangeError("'length' is out of bounds"); let r; return r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), r.__proto__ = i.prototype, r; } function h(e) { if (i.isBuffer(e)) { const t = 0 | f(e.length); const n = r(t); return n.length === 0 ? n : (e.copy(n, 0, 0, t), n); } if (e) { if (H(e) || 'length' in e) return typeof e.length !== 'number' || W(e.length) ? r(0) : l(e); if (e.type === 'Buffer' && Array.isArray(e.data)) return l(e.data); } throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'); } function f(e) { if (e >= X) throw new RangeError(`Attempt to allocate Buffer larger than maximum size: 0x${X.toString(16)} bytes`); return 0 | e; } function d(e, t) { if (i.isBuffer(e)) return e.length; if (H(e) || q(e)) return e.byteLength; typeof e !== 'string' && (e = `${e}`); const n = e.length; if (n === 0) return 0; for (let r = !1; ;) switch (t) { case 'ascii': case 'latin1': case 'binary': return n; case 'utf8': case 'utf-8': case void 0: return j(e).length; case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return 2 * n; case 'hex': return n >>> 1; case 'base64': return U(e).length; default: if (r) return j(e).length; t = (`${t}`).toLowerCase(), r = !0; } } function m(e, t, n) { let r = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length) return ''; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ''; if (n >>>= 0, t >>>= 0, n <= t) return ''; for (e || (e = 'utf8'); ;) switch (e) { case 'hex': return F(this, t, n); case 'utf8': case 'utf-8': return C(this, t, n); case 'ascii': return T(this, t, n); case 'latin1': case 'binary': return O(this, t, n); case 'base64': return A(this, t, n); case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return B(this, t, n); default: if (r) throw new TypeError(`Unknown encoding: ${e}`); e = (`${e}`).toLowerCase(), r = !0; } } function g(e, t, n) { const r = e[t]; e[t] = e[n], e[n] = r; } function v(e, t, n, r, o) { if (e.length === 0) return -1; if (typeof n === 'string' ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, W(n) && (n = o ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) { if (o) return -1; n = e.length - 1; } else if (n < 0) { if (!o) return -1; n = 0; } if (typeof t === 'string' && (t = i.from(t, r)), i.isBuffer(t)) return t.length === 0 ? -1 : y(e, t, n, r, o); if (typeof t === 'number') return t &= 255, typeof Uint8Array.prototype.indexOf === 'function' ? o ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : y(e, [t], n, r, o); throw new TypeError('val must be string, number or Buffer'); } function y(e, t, n, r, i) { function o(e, t) { return s === 1 ? e[t] : e.readUInt16BE(t * s); } var s = 1; let a = e.length; let u = t.length; if (void 0 !== r && ((r = String(r).toLowerCase()) === 'ucs2' || r === 'ucs-2' || r === 'utf16le' || r === 'utf-16le')) { if (e.length < 2 || t.length < 2) return -1; s = 2, a /= 2, u /= 2, n /= 2; } let c; if (i) { let l = -1; for (c = n; c < a; c++) if (o(e, c) === o(t, l === -1 ? 0 : c - l)) { if (l === -1 && (l = c), c - l + 1 === u) return l * s; } else l !== -1 && (c -= c - l), l = -1; } else for (n + u > a && (n = a - u), c = n; c >= 0; c--) { for (var p = !0, h = 0; h < u; h++) if (o(e, c + h) !== o(t, h)) { p = !1; break; } if (p) return c; } return -1; } function b(e, t, n, r) { n = Number(n) || 0; const i = e.length - n; r ? (r = Number(r)) > i && (r = i) : r = i; const o = t.length; if (o % 2 != 0) throw new TypeError('Invalid hex string'); r > o / 2 && (r = o / 2); for (var s = 0; s < r; ++s) { const a = parseInt(t.substr(2 * s, 2), 16); if (W(a)) return s; e[n + s] = a; } return s; } function _(e, t, n, r) { return $(j(t, e.length - n), e, n, r); } function x(e, t, n, r) { return $(V(t), e, n, r); } function w(e, t, n, r) { return x(e, t, n, r); } function k(e, t, n, r) { return $(U(t), e, n, r); } function E(e, t, n, r) { return $(z(t, e.length - n), e, n, r); } function A(e, t, n) { return t === 0 && n === e.length ? G.fromByteArray(e) : G.fromByteArray(e.slice(t, n)); } function C(e, t, n) { n = Math.min(e.length, n); for (var r = [], i = t; i < n;) { const o = e[i]; let s = null; let a = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1; if (i + a <= n) { var u; var c; var l; var p; switch (a) { case 1: o < 128 && (s = o); break; case 2: (192 & (u = e[i + 1])) == 128 && (p = (31 & o) << 6 | 63 & u) > 127 && (s = p); break; case 3: u = e[i + 1], c = e[i + 2], (192 & u) == 128 && (192 & c) == 128 && (p = (15 & o) << 12 | (63 & u) << 6 | 63 & c) > 2047 && (p < 55296 || p > 57343) && (s = p); break; case 4: u = e[i + 1], c = e[i + 2], l = e[i + 3], (192 & u) == 128 && (192 & c) == 128 && (192 & l) == 128 && (p = (15 & o) << 18 | (63 & u) << 12 | (63 & c) << 6 | 63 & l) > 65535 && p < 1114112 && (s = p); } }s === null ? (s = 65533, a = 1) : s > 65535 && (s -= 65536, r.push(s >>> 10 & 1023 | 55296), s = 56320 | 1023 & s), r.push(s), i += a; } return S(r); } function S(e) { const t = e.length; if (t <= K) return String.fromCharCode(...e); for (var n = '', r = 0; r < t;)n += String.fromCharCode(...e.slice(r, r += K)); return n; } function T(e, t, n) { let r = ''; n = Math.min(e.length, n); for (let i = t; i < n; ++i)r += String.fromCharCode(127 & e[i]); return r; } function O(e, t, n) { let r = ''; n = Math.min(e.length, n); for (let i = t; i < n; ++i)r += String.fromCharCode(e[i]); return r; } function F(e, t, n) { const r = e.length; (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r); for (var i = '', o = t; o < n; ++o)i += I(e[o]); return i; } function B(e, t, n) { for (var r = e.slice(t, n), i = '', o = 0; o < r.length; o += 2)i += String.fromCharCode(r[o] + 256 * r[o + 1]); return i; } function D(e, t, n) { if (e % 1 != 0 || e < 0) throw new RangeError('offset is not uint'); if (e + t > n) throw new RangeError('Trying to access beyond buffer length'); } function L(e, t, n, r, o, s) { if (!i.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > o || t < s) throw new RangeError('"value" argument is out of bounds'); if (n + r > e.length) throw new RangeError('Index out of range'); } function N(e, t, n, r, i, o) { if (n + r > e.length) throw new RangeError('Index out of range'); if (n < 0) throw new RangeError('Index out of range'); } function M(e, t, n, r, i) { return t = +t, n >>>= 0, i || N(e, t, n, 4, 3.4028234663852886e38, -3.4028234663852886e38), Y.write(e, t, n, r, 23, 4), n + 4; } function R(e, t, n, r, i) { return t = +t, n >>>= 0, i || N(e, t, n, 8, 1.7976931348623157e308, -1.7976931348623157e308), Y.write(e, t, n, r, 52, 8), n + 8; } function P(e) { if ((e = e.trim().replace(J, '')).length < 2) return ''; for (;e.length % 4 != 0;)e += '='; return e; } function I(e) { return e < 16 ? `0${e.toString(16)}` : e.toString(16); } function j(e, t) { t = t || 1 / 0; for (var n, r = e.length, i = null, o = [], s = 0; s < r; ++s) { if ((n = e.charCodeAt(s)) > 55295 && n < 57344) { if (!i) { if (n > 56319) { (t -= 3) > -1 && o.push(239, 191, 189); continue; } if (s + 1 === r) { (t -= 3) > -1 && o.push(239, 191, 189); continue; }i = n; continue; } if (n < 56320) { (t -= 3) > -1 && o.push(239, 191, 189), i = n; continue; }n = 65536 + (i - 55296 << 10 | n - 56320); } else i && (t -= 3) > -1 && o.push(239, 191, 189); if (i = null, n < 128) { if ((t -= 1) < 0) break; o.push(n); } else if (n < 2048) { if ((t -= 2) < 0) break; o.push(n >> 6 | 192, 63 & n | 128); } else if (n < 65536) { if ((t -= 3) < 0) break; o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128); } else { if (!(n < 1114112)) throw new Error('Invalid code point'); if ((t -= 4) < 0) break; o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128); } } return o; } function V(e) { for (var t = [], n = 0; n < e.length; ++n)t.push(255 & e.charCodeAt(n)); return t; } function z(e, t) { for (var n, r, i, o = [], s = 0; s < e.length && !((t -= 2) < 0); ++s)r = (n = e.charCodeAt(s)) >> 8, i = n % 256, o.push(i), o.push(r); return o; } function U(e) { return G.toByteArray(P(e)); } function $(e, t, n, r) { for (var i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i)t[i + n] = e[i]; return i; } function q(e) { return e instanceof ArrayBuffer || e != null && e.constructor != null && e.constructor.name === 'ArrayBuffer' && typeof e.byteLength === 'number'; } function H(e) { return typeof ArrayBuffer.isView === 'function' && ArrayBuffer.isView(e); } function W(e) { return e !== e; } var G = e('base64-js'); var Y = e('ieee754'); n.Buffer = i, n.SlowBuffer = function (e) { return +e != e && (e = 0), i.alloc(+e); }, n.INSPECT_MAX_BYTES = 50; var X = 2147483647; n.kMaxLength = X, i.TYPED_ARRAY_SUPPORT = (function () { try { const e = new Uint8Array(1); return e.__proto__ = { __proto__: Uint8Array.prototype, foo() { return 42; } }, e.foo() === 42; } catch (e) { return !1; } }()), i.TYPED_ARRAY_SUPPORT || typeof console === 'undefined' || typeof console.error !== 'function' || console.error('This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'), typeof Symbol !== 'undefined' && Symbol.species && i[Symbol.species] === i && Object.defineProperty(i, Symbol.species, {
      value: null, configurable: !0, enumerable: !1, writable: !1,
    }), i.poolSize = 8192, i.from = function (e, t, n) { return o(e, t, n); }, i.prototype.__proto__ = Uint8Array.prototype, i.__proto__ = Uint8Array, i.alloc = function (e, t, n) { return a(e, t, n); }, i.allocUnsafe = function (e) { return u(e); }, i.allocUnsafeSlow = function (e) { return u(e); }, i.isBuffer = function (e) { return e != null && !0 === e._isBuffer; }, i.compare = function (e, t) { if (!i.isBuffer(e) || !i.isBuffer(t)) throw new TypeError('Arguments must be Buffers'); if (e === t) return 0; for (var n = e.length, r = t.length, o = 0, s = Math.min(n, r); o < s; ++o) if (e[o] !== t[o]) { n = e[o], r = t[o]; break; } return n < r ? -1 : r < n ? 1 : 0; }, i.isEncoding = function (e) { switch (String(e).toLowerCase()) { case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'latin1': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return !0; default: return !1; } }, i.concat = function (e, t) { if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers'); if (e.length === 0) return i.alloc(0); let n; if (void 0 === t) for (t = 0, n = 0; n < e.length; ++n)t += e[n].length; const r = i.allocUnsafe(t); let o = 0; for (n = 0; n < e.length; ++n) { const s = e[n]; if (!i.isBuffer(s)) throw new TypeError('"list" argument must be an Array of Buffers'); s.copy(r, o), o += s.length; } return r; }, i.byteLength = d, i.prototype._isBuffer = !0, i.prototype.swap16 = function () { const e = this.length; if (e % 2 != 0) throw new RangeError('Buffer size must be a multiple of 16-bits'); for (let t = 0; t < e; t += 2)g(this, t, t + 1); return this; }, i.prototype.swap32 = function () { const e = this.length; if (e % 4 != 0) throw new RangeError('Buffer size must be a multiple of 32-bits'); for (let t = 0; t < e; t += 4)g(this, t, t + 3), g(this, t + 1, t + 2); return this; }, i.prototype.swap64 = function () { const e = this.length; if (e % 8 != 0) throw new RangeError('Buffer size must be a multiple of 64-bits'); for (let t = 0; t < e; t += 8)g(this, t, t + 7), g(this, t + 1, t + 6), g(this, t + 2, t + 5), g(this, t + 3, t + 4); return this; }, i.prototype.toString = function () { const e = this.length; return e === 0 ? '' : arguments.length === 0 ? C(this, 0, e) : m.apply(this, arguments); }, i.prototype.equals = function (e) { if (!i.isBuffer(e)) throw new TypeError('Argument must be a Buffer'); return this === e || i.compare(this, e) === 0; }, i.prototype.inspect = function () { let e = ''; const t = n.INSPECT_MAX_BYTES; return this.length > 0 && (e = this.toString('hex', 0, t).match(/.{2}/g).join(' '), this.length > t && (e += ' ... ')), `<Buffer ${e}>`; }, i.prototype.compare = function (e, t, n, r, o) { if (!i.isBuffer(e)) throw new TypeError('Argument must be a Buffer'); if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), t < 0 || n > e.length || r < 0 || o > this.length) throw new RangeError('out of range index'); if (r >= o && t >= n) return 0; if (r >= o) return -1; if (t >= n) return 1; if (t >>>= 0, n >>>= 0, r >>>= 0, o >>>= 0, this === e) return 0; for (var s = o - r, a = n - t, u = Math.min(s, a), c = this.slice(r, o), l = e.slice(t, n), p = 0; p < u; ++p) if (c[p] !== l[p]) { s = c[p], a = l[p]; break; } return s < a ? -1 : a < s ? 1 : 0; }, i.prototype.includes = function (e, t, n) { return this.indexOf(e, t, n) !== -1; }, i.prototype.indexOf = function (e, t, n) { return v(this, e, t, n, !0); }, i.prototype.lastIndexOf = function (e, t, n) { return v(this, e, t, n, !1); }, i.prototype.write = function (e, t, n, r) { if (void 0 === t)r = 'utf8', n = this.length, t = 0; else if (void 0 === n && typeof t === 'string')r = t, n = this.length, t = 0; else { if (!isFinite(t)) throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported'); t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = 'utf8')) : (r = n, n = void 0); } const i = this.length - t; if ((void 0 === n || n > i) && (n = i), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError('Attempt to write outside buffer bounds'); r || (r = 'utf8'); for (let o = !1; ;) switch (r) { case 'hex': return b(this, e, t, n); case 'utf8': case 'utf-8': return _(this, e, t, n); case 'ascii': return x(this, e, t, n); case 'latin1': case 'binary': return w(this, e, t, n); case 'base64': return k(this, e, t, n); case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': return E(this, e, t, n); default: if (o) throw new TypeError(`Unknown encoding: ${r}`); r = (`${r}`).toLowerCase(), o = !0; } }, i.prototype.toJSON = function () { return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) }; }; var K = 4096; i.prototype.slice = function (e, t) { const n = this.length; e = ~~e, t = void 0 === t ? n : ~~t, e < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), t < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e); const r = this.subarray(e, t); return r.__proto__ = i.prototype, r; }, i.prototype.readUIntLE = function (e, t, n) { e >>>= 0, t >>>= 0, n || D(e, t, this.length); for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i; return r; }, i.prototype.readUIntBE = function (e, t, n) { e >>>= 0, t >>>= 0, n || D(e, t, this.length); for (var r = this[e + --t], i = 1; t > 0 && (i *= 256);)r += this[e + --t] * i; return r; }, i.prototype.readUInt8 = function (e, t) { return e >>>= 0, t || D(e, 1, this.length), this[e]; }, i.prototype.readUInt16LE = function (e, t) { return e >>>= 0, t || D(e, 2, this.length), this[e] | this[e + 1] << 8; }, i.prototype.readUInt16BE = function (e, t) { return e >>>= 0, t || D(e, 2, this.length), this[e] << 8 | this[e + 1]; }, i.prototype.readUInt32LE = function (e, t) { return e >>>= 0, t || D(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]; }, i.prototype.readUInt32BE = function (e, t) { return e >>>= 0, t || D(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]); }, i.prototype.readIntLE = function (e, t, n) { e >>>= 0, t >>>= 0, n || D(e, t, this.length); for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i; return i *= 128, r >= i && (r -= Math.pow(2, 8 * t)), r; }, i.prototype.readIntBE = function (e, t, n) { e >>>= 0, t >>>= 0, n || D(e, t, this.length); for (var r = t, i = 1, o = this[e + --r]; r > 0 && (i *= 256);)o += this[e + --r] * i; return i *= 128, o >= i && (o -= Math.pow(2, 8 * t)), o; }, i.prototype.readInt8 = function (e, t) { return e >>>= 0, t || D(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]; }, i.prototype.readInt16LE = function (e, t) { e >>>= 0, t || D(e, 2, this.length); const n = this[e] | this[e + 1] << 8; return 32768 & n ? 4294901760 | n : n; }, i.prototype.readInt16BE = function (e, t) { e >>>= 0, t || D(e, 2, this.length); const n = this[e + 1] | this[e] << 8; return 32768 & n ? 4294901760 | n : n; }, i.prototype.readInt32LE = function (e, t) { return e >>>= 0, t || D(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24; }, i.prototype.readInt32BE = function (e, t) { return e >>>= 0, t || D(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]; }, i.prototype.readFloatLE = function (e, t) { return e >>>= 0, t || D(e, 4, this.length), Y.read(this, e, !0, 23, 4); }, i.prototype.readFloatBE = function (e, t) { return e >>>= 0, t || D(e, 4, this.length), Y.read(this, e, !1, 23, 4); }, i.prototype.readDoubleLE = function (e, t) { return e >>>= 0, t || D(e, 8, this.length), Y.read(this, e, !0, 52, 8); }, i.prototype.readDoubleBE = function (e, t) { return e >>>= 0, t || D(e, 8, this.length), Y.read(this, e, !1, 52, 8); }, i.prototype.writeUIntLE = function (e, t, n, r) { e = +e, t >>>= 0, n >>>= 0, r || L(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); let i = 1; let o = 0; for (this[t] = 255 & e; ++o < n && (i *= 256);) this[t + o] = e / i & 255; return t + n; }, i.prototype.writeUIntBE = function (e, t, n, r) { e = +e, t >>>= 0, n >>>= 0, r || L(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); let i = n - 1; let o = 1; for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) this[t + i] = e / o & 255; return t + n; }, i.prototype.writeUInt8 = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1; }, i.prototype.writeUInt16LE = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2; }, i.prototype.writeUInt16BE = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2; }, i.prototype.writeUInt32LE = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4; }, i.prototype.writeUInt32BE = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4; }, i.prototype.writeIntLE = function (e, t, n, r) { if (e = +e, t >>>= 0, !r) { const i = Math.pow(2, 8 * n - 1); L(this, e, t, n, i - 1, -i); } let o = 0; let s = 1; let a = 0; for (this[t] = 255 & e; ++o < n && (s *= 256);)e < 0 && a === 0 && this[t + o - 1] !== 0 && (a = 1), this[t + o] = (e / s >> 0) - a & 255; return t + n; }, i.prototype.writeIntBE = function (e, t, n, r) { if (e = +e, t >>>= 0, !r) { const i = Math.pow(2, 8 * n - 1); L(this, e, t, n, i - 1, -i); } let o = n - 1; let s = 1; let a = 0; for (this[t + o] = 255 & e; --o >= 0 && (s *= 256);)e < 0 && a === 0 && this[t + o + 1] !== 0 && (a = 1), this[t + o] = (e / s >> 0) - a & 255; return t + n; }, i.prototype.writeInt8 = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1; }, i.prototype.writeInt16LE = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2; }, i.prototype.writeInt16BE = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2; }, i.prototype.writeInt32LE = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4; }, i.prototype.writeInt32BE = function (e, t, n) { return e = +e, t >>>= 0, n || L(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4; }, i.prototype.writeFloatLE = function (e, t, n) { return M(this, e, t, !0, n); }, i.prototype.writeFloatBE = function (e, t, n) { return M(this, e, t, !1, n); }, i.prototype.writeDoubleLE = function (e, t, n) { return R(this, e, t, !0, n); }, i.prototype.writeDoubleBE = function (e, t, n) { return R(this, e, t, !1, n); }, i.prototype.copy = function (e, t, n, r) { if (n || (n = 0), r || r === 0 || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0; if (e.length === 0 || this.length === 0) return 0; if (t < 0) throw new RangeError('targetStart out of bounds'); if (n < 0 || n >= this.length) throw new RangeError('sourceStart out of bounds'); if (r < 0) throw new RangeError('sourceEnd out of bounds'); r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n); let i; const o = r - n; if (this === e && n < t && t < r) for (i = o - 1; i >= 0; --i)e[i + t] = this[i + n]; else if (o < 1e3) for (i = 0; i < o; ++i)e[i + t] = this[i + n]; else Uint8Array.prototype.set.call(e, this.subarray(n, n + o), t); return o; }, i.prototype.fill = function (e, t, n, r) { if (typeof e === 'string') { if (typeof t === 'string' ? (r = t, t = 0, n = this.length) : typeof n === 'string' && (r = n, n = this.length), e.length === 1) { const o = e.charCodeAt(0); o < 256 && (e = o); } if (void 0 !== r && typeof r !== 'string') throw new TypeError('encoding must be a string'); if (typeof r === 'string' && !i.isEncoding(r)) throw new TypeError(`Unknown encoding: ${r}`); } else typeof e === 'number' && (e &= 255); if (t < 0 || this.length < t || this.length < n) throw new RangeError('Out of range index'); if (n <= t) return this; t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0); let s; if (typeof e === 'number') for (s = t; s < n; ++s) this[s] = e; else { const a = i.isBuffer(e) ? e : new i(e, r); const u = a.length; for (s = 0; s < n - t; ++s) this[s + t] = a[s % u]; } return this; }; var J = /[^+/0-9A-Za-z-_]/g;
  }, { 'base64-js': 8, ieee754: 21 }],
  12: [function (e, t, n) {
    function r(e, t, r) { r = r || {}, t = t || n.defaultState(); for (let o = r.start || 0, s = r.end || e.length, a = o; a < s;) { try { i(e[a], t); } catch (e) { throw e.index = a, e; }a++; } return t; } function i(e, t) { if (e.length !== 1) throw (o = new Error('Character must be a string of length 1')).name = 'InvalidArgumentError', o.code = 'CHARACTER_PARSER:CHAR_LENGTH_NOT_ONE', o; (t = t || n.defaultState()).src += e; const r = t.isComment(); const i = t.history ? t.history[0] : ''; switch (t.regexpStart && (e !== '/' && e != '*' || t.stack.pop(), t.regexpStart = !1), t.current()) { case p.LINE_COMMENT: e === '\n' && t.stack.pop(); break; case p.BLOCK_COMMENT: t.lastChar === '*' && e === '/' && t.stack.pop(); break; case p.SINGLE_QUOTE: e !== "'" || t.escaped ? e !== '\\' || t.escaped ? t.escaped = !1 : t.escaped = !0 : t.stack.pop(); break; case p.DOUBLE_QUOTE: e !== '"' || t.escaped ? e !== '\\' || t.escaped ? t.escaped = !1 : t.escaped = !0 : t.stack.pop(); break; case p.TEMPLATE_QUOTE: e !== '`' || t.escaped ? e !== '\\' || t.escaped ? e !== '$' || t.escaped ? e === '{' && t.hasDollar ? t.stack.push(h[e]) : (t.escaped = !1, t.hasDollar = !1) : t.hasDollar = !0 : (t.escaped = !0, t.hasDollar = !1) : (t.stack.pop(), t.hasDollar = !1); break; case p.REGEXP: e !== '/' || t.escaped ? e !== '\\' || t.escaped ? t.escaped = !1 : t.escaped = !0 : t.stack.pop(); break; default: if (e in h)t.stack.push(h[e]); else if (e in f) { if (t.current() !== e) { var o = new SyntaxError(`Mismatched Bracket: ${e}`); throw o.code = 'CHARACTER_PARSER:MISMATCHED_BRACKET', o; }t.stack.pop(); } else i === '/' && e === '/' ? (t.history = t.history.substr(1), t.stack.push(p.LINE_COMMENT)) : i === '/' && e === '*' ? (t.history = t.history.substr(1), t.stack.push(p.BLOCK_COMMENT)) : e === '/' && c(t.history) ? (t.stack.push(p.REGEXP), t.regexpStart = !0) : e === "'" ? t.stack.push(p.SINGLE_QUOTE) : e === '"' ? t.stack.push(p.DOUBLE_QUOTE) : e === '`' && t.stack.push(p.TEMPLATE_QUOTE); } return t.isComment() || r || (t.history = e + t.history), t.lastChar = e, t; } function o() { this.stack = [], this.regexpStart = !1, this.escaped = !1, this.hasDollar = !1, this.src = '', this.history = '', this.lastChar = ''; } function s(e, t, n) { return l(t) ? t.test(e.substr(n || 0)) : e.substr(n || 0, t.length) === t; } function a(e) { if (!e) return !0; switch (e.charCodeAt(0)) { case 46: case 40: case 41: case 59: case 44: case 123: case 125: case 91: case 93: case 58: case 63: case 126: case 37: case 38: case 42: case 43: case 45: case 47: case 60: case 62: case 94: case 124: case 33: case 61: return !0; default: return !1; } } function u(e) { return e === 'if' || e === 'in' || e === 'do' || e === 'var' || e === 'for' || e === 'new' || e === 'try' || e === 'let' || e === 'this' || e === 'else' || e === 'case' || e === 'void' || e === 'with' || e === 'enum' || e === 'while' || e === 'break' || e === 'catch' || e === 'throw' || e === 'const' || e === 'yield' || e === 'class' || e === 'super' || e === 'return' || e === 'typeof' || e === 'delete' || e === 'switch' || e === 'export' || e === 'import' || e === 'default' || e === 'finally' || e === 'extends' || e === 'function' || e === 'continue' || e === 'debugger' || e === 'package' || e === 'private' || e === 'interface' || e === 'instanceof' || e === 'implements' || e === 'protected' || e === 'public' || e === 'static'; } function c(e) { return !((e = e.replace(/^\s*/, ''))[0] === ')' || e[0] !== '}' && !a(e[0]) && (!/^\w+\b/.test(e) || !u(/^\w+\b/.exec(e)[0].split('').reverse().join('')))); } var l = e('is-regex'); var p = (n = t.exports = r).TOKEN_TYPES = {
      LINE_COMMENT: '//', BLOCK_COMMENT: '/**/', SINGLE_QUOTE: "'", DOUBLE_QUOTE: '"', TEMPLATE_QUOTE: '`', REGEXP: '//g',
    }; var h = n.BRACKETS = { '(': ')', '{': '}', '[': ']' }; var f = { ')': '(', '}': '{', ']': '[' }; n.parse = r, n.parseUntil = function (e, t, r) { for (var o = (r = r || {}).start || 0, a = o, u = n.defaultState(); a < e.length;) { if ((r.ignoreNesting || !u.isNesting(r)) && s(e, t, a)) { const c = a; return { start: o, end: c, src: e.substring(o, c) }; } try { i(e[a], u); } catch (e) { throw e.index = a, e; }a++; } const l = new Error('The end of the string was reached with no closing bracket found.'); throw l.code = 'CHARACTER_PARSER:END_OF_STRING_REACHED', l.index = a, l; }, n.parseChar = i, n.defaultState = function () { return new o(); }, o.prototype.current = function () { return this.stack[this.stack.length - 1]; }, o.prototype.isString = function () { return this.current() === p.SINGLE_QUOTE || this.current() === p.DOUBLE_QUOTE || this.current() === p.TEMPLATE_QUOTE; }, o.prototype.isComment = function () { return this.current() === p.LINE_COMMENT || this.current() === p.BLOCK_COMMENT; }, o.prototype.isNesting = function (e) { return (!e || !e.ignoreLineComment || this.stack.length !== 1 || this.stack[0] !== p.LINE_COMMENT) && !!this.stack.length; }, n.isPunctuator = a, n.isKeyword = u;
  }, { 'is-regex': 25 }],
  13: [function (e, t, n) {
    function r(e, t) {
      if (e = `(${e})`, a === e && c === t) return u; if (a = e, c = t, !s(e)) return u = !1; let n; try {
        n = i.parse(e, {
          ecmaVersion: 6, allowReturnOutsideFunction: !0, allowImportExportEverywhere: !0, allowHashBang: !0,
        });
      } catch (e) { return u = !1; } let r = !0; return o.simple(n, {
        Statement(e) { r && !0 !== l[e.type] && (r = !1); }, Expression(e) { r && !0 !== p[e.type] && (r = !1); }, MemberExpression(e) { r && (e.computed ? r = !1 : e.property.name[0] === '_' && (r = !1)); }, Identifier(e) { r && (t && e.name in t || (r = !1)); },
      }), u = r;
    } var i = e('acorn'); var o = e('acorn/dist/walk'); var s = e('is-expression'); var a = '(null)'; var u = !0; var c = void 0; var l = { EmptyStatement: !0, ExpressionStatement: !0 }; var p = {
      ParenthesizedExpression: !0, ArrayExpression: !0, ObjectExpression: !0, SequenceExpression: !0, TemplateLiteral: !0, UnaryExpression: !0, BinaryExpression: !0, LogicalExpression: !0, ConditionalExpression: !0, Identifier: !0, Literal: !0, ComprehensionExpression: !0, TaggedTemplateExpression: !0, MemberExpression: !0, CallExpression: !0, NewExpression: !0,
    }; t.exports = r, r.isConstant = r, r.toConstant = function (e, t) { if (!r(e, t)) throw new Error(`${JSON.stringify(e)} is not constant.`); return Function(Object.keys(t || {}).join(','), `return (${e})`)(...Object.keys(t || {}).map(e => t[e])); };
  }, { acorn: 14, 'acorn/dist/walk': 15, 'is-expression': 16 }],
  14: [function (e, t, n) {
    !(function (e, r) { typeof n === 'object' && void 0 !== t ? r(n) : typeof define === 'function' && define.amd ? define(['exports'], r) : r(e.acorn = e.acorn || {}); }(this, (e) => {
      function t(e, t) { for (let n = 65536, r = 0; r < t.length; r += 2) { if ((n += t[r]) > e) return !1; if ((n += t[r + 1]) >= e) return !0; } } function n(e, n) { return e < 65 ? e === 36 : e < 91 || (e < 97 ? e === 95 : e < 123 || (e <= 65535 ? e >= 170 && x.test(String.fromCharCode(e)) : !1 !== n && t(e, k))); } function r(e, n) { return e < 48 ? e === 36 : e < 58 || !(e < 65) && (e < 91 || (e < 97 ? e === 95 : e < 123 || (e <= 65535 ? e >= 170 && w.test(String.fromCharCode(e)) : !1 !== n && (t(e, k) || t(e, E))))); } function i(e, t) { return new A(e, { beforeExpr: !0, binop: t }); } function o(e, t) { return void 0 === t && (t = {}), t.keyword = e, T[e] = new A(e, t); } function s(e) { return e === 10 || e === 13 || e === 8232 || e == 8233; } function a(e) { return Object.prototype.toString.call(e) === '[object Array]'; } function u(e, t) { return Object.prototype.hasOwnProperty.call(e, t); } function c(e, t) { for (let n = 1, r = 0; ;) { B.lastIndex = r; const i = B.exec(e); if (!(i && i.index < t)) return new N(n, t - r); ++n, r = i.index + i[0].length; } } function l(e) { const t = {}; for (const n in R)t[n] = e && u(e, n) ? e[n] : R[n]; if (t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), a(t.onToken)) { const r = t.onToken; t.onToken = function (e) { return r.push(e); }; } return a(t.onComment) && (t.onComment = p(t, t.onComment)), t; } function p(e, t) {
        return function (n, r, i, o, s, a) {
          const u = {
            type: n ? 'Block' : 'Line', value: r, start: i, end: o,
          }; e.locations && (u.loc = new M(this, s, a)), e.ranges && (u.range = [i, o]), t.push(u);
        };
      } function h(e) { return new RegExp(`^(${e.replace(/ /g, '|')})$`); } function f(e, t, n, r) { return e.type = t, e.end = n, this.options.locations && (e.loc.end = r), this.options.ranges && (e.range[1] = n), e; } function d(e, t, n, r) { try { return new RegExp(e, t); } catch (e) { if (void 0 !== n) throw e instanceof SyntaxError && r.raise(n, `Error parsing regular expression: ${e.message}`), e; } } function m(e) { return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e))); } const g = {
        3: 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile', 5: 'class enum extends super const export import', 6: 'enum', 7: 'enum', strict: 'implements interface let package private protected public static yield', strictBind: 'eval arguments',
      }; const v = 'break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this'; const y = { 5: v, 6: `${v} const class extends export import super` }; let b = 'ÂªÂµÂºÃ€-Ã–Ã˜-Ã¶Ã¸-ËË†-Ë‘Ë -Ë¤Ë¬Ë®Í°-Í´Í¶Í·Íº-Í½Í¿Î†Îˆ-ÎŠÎŒÎŽ-Î¡Î£-ÏµÏ·-ÒÒŠ-Ô¯Ô±-Õ–Õ™Õ¡-Ö‡×-×ª×°-×²Ø -ÙŠÙ®Ù¯Ù±-Û“Û•Û¥Û¦Û®Û¯Ûº-Û¼Û¿ÜÜ’-Ü¯Ý-Þ¥Þ±ßŠ-ßªß´ßµßºà €-à •à šà ¤à ¨à¡€-à¡˜à¢ -à¢´à¢¶-à¢½à¤„-à¤¹à¤½à¥à¥˜-à¥¡à¥±-à¦€à¦…-à¦Œà¦à¦à¦“-à¦¨à¦ª-à¦°à¦²à¦¶-à¦¹à¦½à§Žà§œà§à§Ÿ-à§¡à§°à§±à¨…-à¨Šà¨à¨à¨“-à¨¨à¨ª-à¨°à¨²à¨³à¨µà¨¶à¨¸à¨¹à©™-à©œà©žà©²-à©´àª…-àªàª-àª‘àª“-àª¨àªª-àª°àª²àª³àªµ-àª¹àª½à«à« à«¡à«¹à¬…-à¬Œà¬à¬à¬“-à¬¨à¬ª-à¬°à¬²à¬³à¬µ-à¬¹à¬½à­œà­à­Ÿ-à­¡à­±à®ƒà®…-à®Šà®Ž-à®à®’-à®•à®™à®šà®œà®žà®Ÿà®£à®¤à®¨-à®ªà®®-à®¹à¯à°…-à°Œà°Ž-à°à°’-à°¨à°ª-à°¹à°½à±˜-à±šà± à±¡à²€à²…-à²Œà²Ž-à²à²’-à²¨à²ª-à²³à²µ-à²¹à²½à³žà³ à³¡à³±à³²à´…-à´Œà´Ž-à´à´’-à´ºà´½àµŽàµ”-àµ–àµŸ-àµ¡àµº-àµ¿à¶…-à¶–à¶š-à¶±à¶³-à¶»à¶½à·€-à·†à¸-à¸°à¸²à¸³à¹€-à¹†àºàº‚àº„àº‡àºˆàºŠàºàº”-àº—àº™-àºŸàº¡-àº£àº¥àº§àºªàº«àº­-àº°àº²àº³àº½à»€-à»„à»†à»œ-à»Ÿà¼€à½€-à½‡à½‰-à½¬à¾ˆ-à¾Œá€€-á€ªá€¿á-á•áš-áá¡á¥á¦á®-á°áµ-á‚á‚Žá‚ -áƒ…áƒ‡áƒáƒ-áƒºáƒ¼-á‰ˆá‰Š-á‰á‰-á‰–á‰˜á‰š-á‰á‰ -áŠˆáŠŠ-áŠáŠ-áŠ°áŠ²-áŠµáŠ¸-áŠ¾á‹€á‹‚-á‹…á‹ˆ-á‹–á‹˜-áŒáŒ’-áŒ•áŒ˜-ášáŽ€-áŽáŽ -áµá¸-á½á-á™¬á™¯-á™¿áš-áššáš -á›ªá›®-á›¸áœ€-áœŒáœŽ-áœ‘áœ -áœ±á€-á‘á -á¬á®-á°áž€-áž³áŸ—áŸœá  -á¡·á¢€-á¢¨á¢ªá¢°-á£µá¤€-á¤žá¥-á¥­á¥°-á¥´á¦€-á¦«á¦°-á§‰á¨€-á¨–á¨ -á©”áª§á¬…-á¬³á­…-á­‹á®ƒ-á® á®®á®¯á®º-á¯¥á°€-á°£á±-á±á±š-á±½á²€-á²ˆá³©-á³¬á³®-á³±á³µá³¶á´€-á¶¿á¸€-á¼•á¼˜-á¼á¼ -á½…á½ˆ-á½á½-á½—á½™á½›á½á½Ÿ-á½½á¾€-á¾´á¾¶-á¾¼á¾¾á¿‚-á¿„á¿†-á¿Œá¿-á¿“á¿–-á¿›á¿ -á¿¬á¿²-á¿´á¿¶-á¿¼â±â¿â‚-â‚œâ„‚â„‡â„Š-â„“â„•â„˜-â„â„¤â„¦â„¨â„ª-â„¹â„¼-â„¿â……-â…‰â…Žâ… -â†ˆâ°€-â°®â°°-â±žâ± -â³¤â³«-â³®â³²â³³â´€-â´¥â´§â´­â´°-âµ§âµ¯â¶€-â¶–â¶ -â¶¦â¶¨-â¶®â¶°-â¶¶â¶¸-â¶¾â·€-â·†â·ˆ-â·Žâ·-â·–â·˜-â·žã€…-ã€‡ã€¡-ã€©ã€±-ã€µã€¸-ã€¼ã-ã‚–ã‚›-ã‚Ÿã‚¡-ãƒºãƒ¼-ãƒ¿ã„…-ã„­ã„±-ã†Žã† -ã†ºã‡°-ã‡¿ã€-ä¶µä¸€-é¿•ê€€-ê’Œê“-ê“½ê”€-ê˜Œê˜-ê˜Ÿê˜ªê˜«ê™€-ê™®ê™¿-êšêš -ê›¯êœ—-êœŸêœ¢-êžˆêž‹-êž®êž°-êž·êŸ·-ê ê ƒ-ê …ê ‡-ê Šê Œ-ê ¢ê¡€-ê¡³ê¢‚-ê¢³ê£²-ê£·ê£»ê£½ê¤Š-ê¤¥ê¤°-ê¥†ê¥ -ê¥¼ê¦„-ê¦²ê§ê§ -ê§¤ê§¦-ê§¯ê§º-ê§¾ê¨€-ê¨¨ê©€-ê©‚ê©„-ê©‹ê© -ê©¶ê©ºê©¾-êª¯êª±êªµêª¶êª¹-êª½ê«€ê«‚ê«›-ê«ê« -ê«ªê«²-ê«´ê¬-ê¬†ê¬‰-ê¬Žê¬‘-ê¬–ê¬ -ê¬¦ê¬¨-ê¬®ê¬°-ê­šê­œ-ê­¥ê­°-ê¯¢ê°€-íž£íž°-íŸ†íŸ‹-íŸ»ï¤€-ï©­ï©°-ï«™ï¬€-ï¬†ï¬“-ï¬—ï¬ï¬Ÿ-ï¬¨ï¬ª-ï¬¶ï¬¸-ï¬¼ï¬¾ï­€ï­ï­ƒï­„ï­†-ï®±ï¯“-ï´½ïµ-ï¶ï¶’-ï·‡ï·°-ï·»ï¹°-ï¹´ï¹¶-ï»¼ï¼¡-ï¼ºï½-ï½šï½¦-ï¾¾ï¿‚-ï¿‡ï¿Š-ï¿ï¿’-ï¿—ï¿š-ï¿œ'; let _ = 'â€Œâ€Â·Ì€-Í¯Î‡Òƒ-Ò‡Ö‘-Ö½Ö¿××‚×„×…×‡Ø-ØšÙ‹-Ù©Ù°Û–-ÛœÛŸ-Û¤Û§Û¨Ûª-Û­Û°-Û¹Ü‘Ü°-ÝŠÞ¦-Þ°ß€-ß‰ß«-ß³à –-à ™à ›-à £à ¥-à §à ©-à ­à¡™-à¡›à£”-à£¡à££-à¤ƒà¤º-à¤¼à¤¾-à¥à¥‘-à¥—à¥¢à¥£à¥¦-à¥¯à¦-à¦ƒà¦¼à¦¾-à§„à§‡à§ˆà§‹-à§à§—à§¢à§£à§¦-à§¯à¨-à¨ƒà¨¼à¨¾-à©‚à©‡à©ˆà©‹-à©à©‘à©¦-à©±à©µàª-àªƒàª¼àª¾-à«…à«‡-à«‰à«‹-à«à«¢à«£à«¦-à«¯à¬-à¬ƒà¬¼à¬¾-à­„à­‡à­ˆà­‹-à­à­–à­—à­¢à­£à­¦-à­¯à®‚à®¾-à¯‚à¯†-à¯ˆà¯Š-à¯à¯—à¯¦-à¯¯à°€-à°ƒà°¾-à±„à±†-à±ˆà±Š-à±à±•à±–à±¢à±£à±¦-à±¯à²-à²ƒà²¼à²¾-à³„à³†-à³ˆà³Š-à³à³•à³–à³¢à³£à³¦-à³¯à´-à´ƒà´¾-àµ„àµ†-àµˆàµŠ-àµàµ—àµ¢àµ£àµ¦-àµ¯à¶‚à¶ƒà·Šà·-à·”à·–à·˜-à·Ÿà·¦-à·¯à·²à·³à¸±à¸´-à¸ºà¹‡-à¹Žà¹-à¹™àº±àº´-àº¹àº»àº¼à»ˆ-à»à»-à»™à¼˜à¼™à¼ -à¼©à¼µà¼·à¼¹à¼¾à¼¿à½±-à¾„à¾†à¾‡à¾-à¾—à¾™-à¾¼à¿†á€«-á€¾á€-á‰á–-á™áž-á á¢-á¤á§-á­á±-á´á‚‚-á‚á‚-á‚á-áŸá©-á±áœ’-áœ”áœ²-áœ´á’á“á²á³áž´-áŸ“áŸáŸ -áŸ©á ‹-á á -á ™á¢©á¤ -á¤«á¤°-á¤»á¥†-á¥á§-á§šá¨—-á¨›á©•-á©žá© -á©¼á©¿-áª‰áª-áª™áª°-áª½á¬€-á¬„á¬´-á­„á­-á­™á­«-á­³á®€-á®‚á®¡-á®­á®°-á®¹á¯¦-á¯³á°¤-á°·á±€-á±‰á±-á±™á³-á³’á³”-á³¨á³­á³²-á³´á³¸á³¹á·€-á·µá·»-á·¿â€¿â€â”âƒ-âƒœâƒ¡âƒ¥-âƒ°â³¯-â³±âµ¿â· -â·¿ã€ª-ã€¯ã‚™ã‚šê˜ -ê˜©ê™¯ê™´-ê™½êšžêšŸê›°ê›±ê ‚ê †ê ‹ê £-ê §ê¢€ê¢ê¢´-ê£…ê£-ê£™ê£ -ê£±ê¤€-ê¤‰ê¤¦-ê¤­ê¥‡-ê¥“ê¦€-ê¦ƒê¦³-ê§€ê§-ê§™ê§¥ê§°-ê§¹ê¨©-ê¨¶ê©ƒê©Œê©ê©-ê©™ê©»-ê©½êª°êª²-êª´êª·êª¸êª¾êª¿ê«ê««-ê«¯ê«µê«¶ê¯£-ê¯ªê¯¬ê¯­ê¯°-ê¯¹ï¬žï¸€-ï¸ï¸ -ï¸¯ï¸³ï¸´ï¹-ï¹ï¼-ï¼™ï¼¿'; var x = new RegExp(`[${b}]`); var w = new RegExp(`[${b}${_}]`); b = _ = null; var k = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541]; var E = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; var A = function (e, t) { void 0 === t && (t = {}), this.label = e, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop || null, this.updateContext = null; }; const C = { beforeExpr: !0 }; const S = { startsExpr: !0 }; var T = {}; const O = {
        num: new A('num', S),
        regexp: new A('regexp', S),
        string: new A('string', S),
        name: new A('name', S),
        eof: new A('eof'),
        bracketL: new A('[', { beforeExpr: !0, startsExpr: !0 }),
        bracketR: new A(']'),
        braceL: new A('{', { beforeExpr: !0, startsExpr: !0 }),
        braceR: new A('}'),
        parenL: new A('(', { beforeExpr: !0, startsExpr: !0 }),
        parenR: new A(')'),
        comma: new A(',', C),
        semi: new A(';', C),
        colon: new A(':', C),
        dot: new A('.'),
        question: new A('?', C),
        arrow: new A('=>', C),
        template: new A('template'),
        ellipsis: new A('...', C),
        backQuote: new A('`', S),
        dollarBraceL: new A('${', { beforeExpr: !0, startsExpr: !0 }),
        eq: new A('=', { beforeExpr: !0, isAssign: !0 }),
        assign: new A('_=', { beforeExpr: !0, isAssign: !0 }),
        incDec: new A('++/--', { prefix: !0, postfix: !0, startsExpr: !0 }),
        prefix: new A('prefix', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        logicalOR: i('||', 1),
        logicalAND: i('&&', 2),
        bitwiseOR: i('|', 3),
        bitwiseXOR: i('^', 4),
        bitwiseAND: i('&', 5),
        equality: i('==/!=', 6),
        relational: i('</>', 7),
        bitShift: i('<</>>', 8),
        plusMin: new A('+/-', {
          beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0,
        }),
        modulo: i('%', 10),
        star: i('*', 10),
        slash: i('/', 10),
        starstar: new A('**', { beforeExpr: !0 }),
        _break: o('break'),
        _case: o('case', C),
        _catch: o('catch'),
        _continue: o('continue'),
        _debugger: o('debugger'),
        _default: o('default', C),
        _do: o('do', { isLoop: !0, beforeExpr: !0 }),
        _else: o('else', C),
        _finally: o('finally'),
        _for: o('for', { isLoop: !0 }),
        _function: o('function', S),
        _if: o('if'),
        _return: o('return', C),
        _switch: o('switch'),
        _throw: o('throw', C),
        _try: o('try'),
        _var: o('var'),
        _const: o('const'),
        _while: o('while', { isLoop: !0 }),
        _with: o('with'),
        _new: o('new', { beforeExpr: !0, startsExpr: !0 }),
        _this: o('this', S),
        _super: o('super', S),
        _class: o('class'),
        _extends: o('extends', C),
        _export: o('export'),
        _import: o('import'),
        _null: o('null', S),
        _true: o('true', S),
        _false: o('false', S),
        _in: o('in', { beforeExpr: !0, binop: 7 }),
        _instanceof: o('instanceof', { beforeExpr: !0, binop: 7 }),
        _typeof: o('typeof', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _void: o('void', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _delete: o('delete', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
      }; const F = /\r\n?|\n|\u2028|\u2029/; var B = new RegExp(F.source, 'g'); const D = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; const L = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g; var N = function (e, t) { this.line = e, this.column = t; }; N.prototype.offset = function (e) { return new N(this.line, this.column + e); }; var M = function (e, t, n) { this.start = t, this.end = n, e.sourceFile !== null && (this.source = e.sourceFile); }; var R = {
        ecmaVersion: 6, sourceType: 'script', onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowHashBang: !1, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1, plugins: {},
      }; const P = {}; const I = function (e, t, n) { this.options = e = l(e), this.sourceFile = e.sourceFile, this.keywords = h(y[e.ecmaVersion >= 6 ? 6 : 5]); const r = e.allowReserved ? '' : g[e.ecmaVersion] + (e.sourceType == 'module' ? ' await' : ''); this.reservedWords = h(r); const i = (r ? `${r} ` : '') + g.strict; this.reservedWordsStrict = h(i), this.reservedWordsStrictBind = h(`${i} ${g.strictBind}`), this.input = String(t), this.containsEsc = !1, this.loadPlugins(e.plugins), n ? (this.pos = n, this.lineStart = Math.max(0, this.input.lastIndexOf('\n', n)), this.curLine = this.input.slice(0, this.lineStart).split(F).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = O.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.strict = this.inModule = e.sourceType === 'module', this.potentialArrowAt = -1, this.inFunction = this.inGenerator = !1, this.labels = [], this.pos === 0 && e.allowHashBang && this.input.slice(0, 2) === '#!' && this.skipLineComment(2); }; I.prototype.isKeyword = function (e) { return this.keywords.test(e); }, I.prototype.isReservedWord = function (e) { return this.reservedWords.test(e); }, I.prototype.extend = function (e, t) { this[e] = t(this[e]); }, I.prototype.loadPlugins = function (e) { const t = this; for (const n in e) { const r = P[n]; if (!r) throw new Error(`Plugin '${n}' not found`); r(t, e[n]); } }, I.prototype.parse = function () { const e = this.options.program || this.startNode(); return this.nextToken(), this.parseTopLevel(e); }; const j = I.prototype; j.isUseStrict = function (e) { return this.options.ecmaVersion >= 5 && e.type === 'ExpressionStatement' && e.expression.type === 'Literal' && e.expression.raw.slice(1, -1) === 'use strict'; }, j.eat = function (e) { return this.type === e && (this.next(), !0); }, j.isContextual = function (e) { return this.type === O.name && this.value === e; }, j.eatContextual = function (e) { return this.value === e && this.eat(O.name); }, j.expectContextual = function (e) { this.eatContextual(e) || this.unexpected(); }, j.canInsertSemicolon = function () { return this.type === O.eof || this.type === O.braceR || F.test(this.input.slice(this.lastTokEnd, this.start)); }, j.insertSemicolon = function () { if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0; }, j.semicolon = function () { this.eat(O.semi) || this.insertSemicolon() || this.unexpected(); }, j.afterTrailingComma = function (e) { if (this.type == e) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), this.next(), !0; }, j.expect = function (e) { this.eat(e) || this.unexpected(); }, j.unexpected = function (e) { this.raise(e != null ? e : this.start, 'Unexpected token'); }; const V = function () { this.shorthandAssign = 0, this.trailingComma = 0; }; j.checkPatternErrors = function (e, t) { const n = e && e.trailingComma; if (!t) return !!n; n && this.raise(n, 'Comma is not permitted after the rest element'); }, j.checkExpressionErrors = function (e, t) { const n = e && e.shorthandAssign; if (!t) return !!n; n && this.raise(n, 'Shorthand property assignments are valid only in destructuring patterns'); }; const z = I.prototype; z.parseTopLevel = function (e) { const t = this; let n = !0; for (e.body || (e.body = []); this.type !== O.eof;) { const r = t.parseStatement(!0, !0); e.body.push(r), n && (t.isUseStrict(r) && t.setStrict(!0), n = !1); } return this.next(), this.options.ecmaVersion >= 6 && (e.sourceType = this.options.sourceType), this.finishNode(e, 'Program'); }; const U = { kind: 'loop' }; const $ = { kind: 'switch' }; z.isLet = function () { if (this.type !== O.name || this.options.ecmaVersion < 6 || this.value != 'let') return !1; L.lastIndex = this.pos; const e = L.exec(this.input); const t = this.pos + e[0].length; const i = this.input.charCodeAt(t); if (i === 91 || i == 123) return !0; if (n(i, !0)) { for (var o = t + 1; r(this.input.charCodeAt(o), !0); ++o);const s = this.input.slice(t, o); if (!this.isKeyword(s)) return !0; } return !1; }, z.parseStatement = function (e, t) { let n; let r = this.type; const i = this.startNode(); switch (this.isLet() && (r = O._var, n = 'let'), r) { case O._break: case O._continue: return this.parseBreakContinueStatement(i, r.keyword); case O._debugger: return this.parseDebuggerStatement(i); case O._do: return this.parseDoStatement(i); case O._for: return this.parseForStatement(i); case O._function: return !e && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(i); case O._class: return e || this.unexpected(), this.parseClass(i, !0); case O._if: return this.parseIfStatement(i); case O._return: return this.parseReturnStatement(i); case O._switch: return this.parseSwitchStatement(i); case O._throw: return this.parseThrowStatement(i); case O._try: return this.parseTryStatement(i); case O._const: case O._var: return n = n || this.value, e || n == 'var' || this.unexpected(), this.parseVarStatement(i, n); case O._while: return this.parseWhileStatement(i); case O._with: return this.parseWithStatement(i); case O.braceL: return this.parseBlock(); case O.semi: return this.parseEmptyStatement(i); case O._export: case O._import: return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r === O._import ? this.parseImport(i) : this.parseExport(i); default: var o = this.value; var s = this.parseExpression(); return r === O.name && s.type === 'Identifier' && this.eat(O.colon) ? this.parseLabeledStatement(i, o, s) : this.parseExpressionStatement(i, s); } }, z.parseBreakContinueStatement = function (e, t) { const n = this; const r = t == 'break'; this.next(), this.eat(O.semi) || this.insertSemicolon() ? e.label = null : this.type !== O.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon()); for (var i = 0; i < this.labels.length; ++i) { const o = n.labels[i]; if (e.label == null || o.name === e.label.name) { if (o.kind != null && (r || o.kind === 'loop')) break; if (e.label && r) break; } } return i === this.labels.length && this.raise(e.start, `Unsyntactic ${t}`), this.finishNode(e, r ? 'BreakStatement' : 'ContinueStatement'); }, z.parseDebuggerStatement = function (e) { return this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement'); }, z.parseDoStatement = function (e) { return this.next(), this.labels.push(U), e.body = this.parseStatement(!1), this.labels.pop(), this.expect(O._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(O.semi) : this.semicolon(), this.finishNode(e, 'DoWhileStatement'); }, z.parseForStatement = function (e) {
        if (this.next(), this.labels.push(U), this.expect(O.parenL), this.type === O.semi) return this.parseFor(e, null); const t = this.isLet(); if (this.type === O._var || this.type === O._const || t) { const n = this.startNode(); const r = t ? 'let' : this.value; return this.next(), this.parseVar(n, !0, r), this.finishNode(n, 'VariableDeclaration'), !(this.type === O._in || this.options.ecmaVersion >= 6 && this.isContextual('of')) || n.declarations.length !== 1 || r !== 'var' && n.declarations[0].init ? this.parseFor(e, n) : this.parseForIn(e, n); } const i = new V();


        const o = this.parseExpression(!0, i); return this.type === O._in || this.options.ecmaVersion >= 6 && this.isContextual('of') ? (this.checkPatternErrors(i, !0), this.toAssignable(o), this.checkLVal(o), this.parseForIn(e, o)) : (this.checkExpressionErrors(i, !0), this.parseFor(e, o));
      }, z.parseFunctionStatement = function (e) { return this.next(), this.parseFunction(e, !0); }, z.parseIfStatement = function (e) { return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement(!1), e.alternate = this.eat(O._else) ? this.parseStatement(!1) : null, this.finishNode(e, 'IfStatement'); }, z.parseReturnStatement = function (e) { return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(O.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, 'ReturnStatement'); }, z.parseSwitchStatement = function (e) { const t = this; this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(O.braceL), this.labels.push($); for (var n, r = !1; this.type != O.braceR;) if (t.type === O._case || t.type === O._default) { const i = t.type === O._case; n && t.finishNode(n, 'SwitchCase'), e.cases.push(n = t.startNode()), n.consequent = [], t.next(), i ? n.test = t.parseExpression() : (r && t.raiseRecoverable(t.lastTokStart, 'Multiple default clauses'), r = !0, n.test = null), t.expect(O.colon); } else n || t.unexpected(), n.consequent.push(t.parseStatement(!0)); return n && this.finishNode(n, 'SwitchCase'), this.next(), this.labels.pop(), this.finishNode(e, 'SwitchStatement'); }, z.parseThrowStatement = function (e) { return this.next(), F.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, 'Illegal newline after throw'), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, 'ThrowStatement'); }; const q = []; z.parseTryStatement = function (e) { if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === O._catch) { const t = this.startNode(); this.next(), this.expect(O.parenL), t.param = this.parseBindingAtom(), this.checkLVal(t.param, !0), this.expect(O.parenR), t.body = this.parseBlock(), e.handler = this.finishNode(t, 'CatchClause'); } return e.finalizer = this.eat(O._finally) ? this.parseBlock() : null, e.handler || e.finalizer || this.raise(e.start, 'Missing catch or finally clause'), this.finishNode(e, 'TryStatement'); }, z.parseVarStatement = function (e, t) { return this.next(), this.parseVar(e, !1, t), this.semicolon(), this.finishNode(e, 'VariableDeclaration'); }, z.parseWhileStatement = function (e) { return this.next(), e.test = this.parseParenExpression(), this.labels.push(U), e.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(e, 'WhileStatement'); }, z.parseWithStatement = function (e) { return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement(!1), this.finishNode(e, 'WithStatement'); }, z.parseEmptyStatement = function (e) { return this.next(), this.finishNode(e, 'EmptyStatement'); }, z.parseLabeledStatement = function (e, t, n) { for (var r = this, i = 0; i < this.labels.length; ++i)r.labels[i].name === t && r.raise(n.start, `Label '${t}' is already declared`); for (var o = this.type.isLoop ? 'loop' : this.type === O._switch ? 'switch' : null, s = this.labels.length - 1; s >= 0; s--) { const a = r.labels[s]; if (a.statementStart != e.start) break; a.statementStart = r.start, a.kind = o; } return this.labels.push({ name: t, kind: o, statementStart: this.start }), e.body = this.parseStatement(!0), this.labels.pop(), e.label = n, this.finishNode(e, 'LabeledStatement'); }, z.parseExpressionStatement = function (e, t) { return e.expression = t, this.semicolon(), this.finishNode(e, 'ExpressionStatement'); }, z.parseBlock = function (e) { let t; const n = this; const r = this.startNode(); let i = !0; for (r.body = [], this.expect(O.braceL); !this.eat(O.braceR);) { const o = n.parseStatement(!0); r.body.push(o), i && e && n.isUseStrict(o) && (t = n.strict, n.setStrict(n.strict = !0)), i = !1; } return !1 === t && this.setStrict(!1), this.finishNode(r, 'BlockStatement'); }, z.parseFor = function (e, t) { return e.init = t, this.expect(O.semi), e.test = this.type === O.semi ? null : this.parseExpression(), this.expect(O.semi), e.update = this.type === O.parenR ? null : this.parseExpression(), this.expect(O.parenR), e.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(e, 'ForStatement'); }, z.parseForIn = function (e, t) { const n = this.type === O._in ? 'ForInStatement' : 'ForOfStatement'; return this.next(), e.left = t, e.right = this.parseExpression(), this.expect(O.parenR), e.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(e, n); }, z.parseVar = function (e, t, n) { const r = this; for (e.declarations = [], e.kind = n; ;) { const i = r.startNode(); if (r.parseVarId(i), r.eat(O.eq) ? i.init = r.parseMaybeAssign(t) : n !== 'const' || r.type === O._in || r.options.ecmaVersion >= 6 && r.isContextual('of') ? i.id.type == 'Identifier' || t && (r.type === O._in || r.isContextual('of')) ? i.init = null : r.raise(r.lastTokEnd, 'Complex binding patterns require an initialization value') : r.unexpected(), e.declarations.push(r.finishNode(i, 'VariableDeclarator')), !r.eat(O.comma)) break; } return e; }, z.parseVarId = function (e) { e.id = this.parseBindingAtom(), this.checkLVal(e.id, !0); }, z.parseFunction = function (e, t, n) { this.initFunction(e), this.options.ecmaVersion >= 6 && (e.generator = this.eat(O.star)); const r = this.inGenerator; return this.inGenerator = e.generator, (t || this.type === O.name) && (e.id = this.parseIdent()), this.parseFunctionParams(e), this.parseFunctionBody(e, n), this.inGenerator = r, this.finishNode(e, t ? 'FunctionDeclaration' : 'FunctionExpression'); }, z.parseFunctionParams = function (e) { this.expect(O.parenL), e.params = this.parseBindingList(O.parenR, !1, !1, !0); }, z.parseClass = function (e, t) { const n = this; this.next(), this.parseClassId(e, t), this.parseClassSuper(e); const r = this.startNode(); let i = !1; for (r.body = [], this.expect(O.braceL); !this.eat(O.braceR);) if (!n.eat(O.semi)) { const o = n.startNode(); let s = n.eat(O.star); const a = n.type === O.name && n.value === 'static'; n.parsePropertyName(o), o.static = a && n.type !== O.parenL, o.static && (s && n.unexpected(), s = n.eat(O.star), n.parsePropertyName(o)), o.kind = 'method'; let u = !1; if (!o.computed) { let c = o.key; s || c.type !== 'Identifier' || n.type === O.parenL || c.name !== 'get' && c.name !== 'set' || (u = !0, o.kind = c.name, c = n.parsePropertyName(o)), !o.static && (c.type === 'Identifier' && c.name === 'constructor' || c.type === 'Literal' && c.value === 'constructor') && (i && n.raise(c.start, 'Duplicate constructor in the same class'), u && n.raise(c.start, "Constructor can't have get/set modifier"), s && n.raise(c.start, "Constructor can't be a generator"), o.kind = 'constructor', i = !0); } if (n.parseClassMethod(r, o, s), u) { const l = o.kind === 'get' ? 0 : 1; if (o.value.params.length !== l) { const p = o.value.start; o.kind === 'get' ? n.raiseRecoverable(p, 'getter should have no params') : n.raiseRecoverable(p, 'setter should have exactly one param'); }o.kind === 'set' && o.value.params[0].type === 'RestElement' && n.raise(o.value.params[0].start, 'Setter cannot use rest params'); } } return e.body = this.finishNode(r, 'ClassBody'), this.finishNode(e, t ? 'ClassDeclaration' : 'ClassExpression'); }, z.parseClassMethod = function (e, t, n) { t.value = this.parseMethod(n), e.body.push(this.finishNode(t, 'MethodDefinition')); }, z.parseClassId = function (e, t) { e.id = this.type === O.name ? this.parseIdent() : t ? this.unexpected() : null; }, z.parseClassSuper = function (e) { e.superClass = this.eat(O._extends) ? this.parseExprSubscripts() : null; }, z.parseExport = function (e) { const t = this; if (this.next(), this.eat(O.star)) return this.expectContextual('from'), e.source = this.type === O.string ? this.parseExprAtom() : this.unexpected(), this.semicolon(), this.finishNode(e, 'ExportAllDeclaration'); if (this.eat(O._default)) { const n = this.type == O.parenL; const r = this.parseMaybeAssign(); let i = !0; return n || r.type != 'FunctionExpression' && r.type != 'ClassExpression' || (i = !1, r.id && (r.type = r.type == 'FunctionExpression' ? 'FunctionDeclaration' : 'ClassDeclaration')), e.declaration = r, i && this.semicolon(), this.finishNode(e, 'ExportDefaultDeclaration'); } if (this.shouldParseExportStatement())e.declaration = this.parseStatement(!0), e.specifiers = [], e.source = null; else { if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(), this.eatContextual('from'))e.source = this.type === O.string ? this.parseExprAtom() : this.unexpected(); else { for (let o = 0; o < e.specifiers.length; o++)(t.keywords.test(e.specifiers[o].local.name) || t.reservedWords.test(e.specifiers[o].local.name)) && t.unexpected(e.specifiers[o].local.start); e.source = null; } this.semicolon(); } return this.finishNode(e, 'ExportNamedDeclaration'); }, z.shouldParseExportStatement = function () { return this.type.keyword || this.isLet(); }, z.parseExportSpecifiers = function () { const e = this; const t = []; let n = !0; for (this.expect(O.braceL); !this.eat(O.braceR);) { if (n)n = !1; else if (e.expect(O.comma), e.afterTrailingComma(O.braceR)) break; const r = e.startNode(); r.local = e.parseIdent(e.type === O._default), r.exported = e.eatContextual('as') ? e.parseIdent(!0) : r.local, t.push(e.finishNode(r, 'ExportSpecifier')); } return t; }, z.parseImport = function (e) { return this.next(), this.type === O.string ? (e.specifiers = q, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual('from'), e.source = this.type === O.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e, 'ImportDeclaration'); }, z.parseImportSpecifiers = function () { const e = this; const t = []; let n = !0; if (this.type === O.name) { const r = this.startNode(); if (r.local = this.parseIdent(), this.checkLVal(r.local, !0), t.push(this.finishNode(r, 'ImportDefaultSpecifier')), !this.eat(O.comma)) return t; } if (this.type === O.star) { const i = this.startNode(); return this.next(), this.expectContextual('as'), i.local = this.parseIdent(), this.checkLVal(i.local, !0), t.push(this.finishNode(i, 'ImportNamespaceSpecifier')), t; } for (this.expect(O.braceL); !this.eat(O.braceR);) { if (n)n = !1; else if (e.expect(O.comma), e.afterTrailingComma(O.braceR)) break; const o = e.startNode(); o.imported = e.parseIdent(!0), e.eatContextual('as') ? o.local = e.parseIdent() : (o.local = o.imported, e.isKeyword(o.local.name) && e.unexpected(o.local.start), e.reservedWordsStrict.test(o.local.name) && e.raise(o.local.start, `The keyword '${o.local.name}' is reserved`)), e.checkLVal(o.local, !0), t.push(e.finishNode(o, 'ImportSpecifier')); } return t; }; const H = I.prototype; H.toAssignable = function (e, t) { const n = this; if (this.options.ecmaVersion >= 6 && e) switch (e.type) { case 'Identifier': case 'ObjectPattern': case 'ArrayPattern': break; case 'ObjectExpression': e.type = 'ObjectPattern'; for (let r = 0; r < e.properties.length; r++) { const i = e.properties[r]; i.kind !== 'init' && n.raise(i.key.start, "Object pattern can't contain getter or setter"), n.toAssignable(i.value, t); } break; case 'ArrayExpression': e.type = 'ArrayPattern', this.toAssignableList(e.elements, t); break; case 'AssignmentExpression': if (e.operator !== '=') { this.raise(e.left.end, "Only '=' operator can be used for specifying default value."); break; }e.type = 'AssignmentPattern', delete e.operator; case 'AssignmentPattern': e.right.type === 'YieldExpression' && this.raise(e.right.start, 'Yield expression cannot be a default value'); break; case 'ParenthesizedExpression': e.expression = this.toAssignable(e.expression, t); break; case 'MemberExpression': if (!t) break; default: this.raise(e.start, 'Assigning to rvalue'); } return e; }, H.toAssignableList = function (e, t) { const n = this; let r = e.length; if (r) { const i = e[r - 1]; if (i && i.type == 'RestElement')--r; else if (i && i.type == 'SpreadElement') { i.type = 'RestElement'; const o = i.argument; this.toAssignable(o, t), o.type !== 'Identifier' && o.type !== 'MemberExpression' && o.type !== 'ArrayPattern' && this.unexpected(o.start), --r; }t && i && i.type === 'RestElement' && i.argument.type !== 'Identifier' && this.unexpected(i.argument.start); } for (let s = 0; s < r; s++) { const a = e[s]; a && n.toAssignable(a, t); } return e; }, H.parseSpread = function (e) { const t = this.startNode(); return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, 'SpreadElement'); }, H.parseRest = function (e) { const t = this.startNode(); return this.next(), t.argument = e ? this.type === O.name ? this.parseIdent() : this.unexpected() : this.type === O.name || this.type === O.bracketL ? this.parseBindingAtom() : this.unexpected(), this.finishNode(t, 'RestElement'); }, H.parseBindingAtom = function () { if (this.options.ecmaVersion < 6) return this.parseIdent(); switch (this.type) { case O.name: return this.parseIdent(); case O.bracketL: var e = this.startNode(); return this.next(), e.elements = this.parseBindingList(O.bracketR, !0, !0), this.finishNode(e, 'ArrayPattern'); case O.braceL: return this.parseObj(!0); default: this.unexpected(); } }, H.parseBindingList = function (e, t, n, r) { for (var i = this, o = [], s = !0; !this.eat(e);) if (s ? s = !1 : i.expect(O.comma), t && i.type === O.comma)o.push(null); else { if (n && i.afterTrailingComma(e)) break; if (i.type === O.ellipsis) { const a = i.parseRest(r); i.parseBindingListItem(a), o.push(a), i.type === O.comma && i.raise(i.start, 'Comma is not permitted after the rest element'), i.expect(e); break; } const u = i.parseMaybeDefault(i.start, i.startLoc); i.parseBindingListItem(u), o.push(u); } return o; }, H.parseBindingListItem = function (e) { return e; }, H.parseMaybeDefault = function (e, t, n) { if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(O.eq)) return n; const r = this.startNodeAt(e, t); return r.left = n, r.right = this.parseMaybeAssign(), this.finishNode(r, 'AssignmentPattern'); }, H.checkLVal = function (e, t, n) { const r = this; switch (e.type) { case 'Identifier': this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, `${(t ? 'Binding ' : 'Assigning to ') + e.name} in strict mode`), n && (u(n, e.name) && this.raiseRecoverable(e.start, 'Argument name clash'), n[e.name] = !0); break; case 'MemberExpression': t && this.raiseRecoverable(e.start, `${t ? 'Binding' : 'Assigning to'} member expression`); break; case 'ObjectPattern': for (let i = 0; i < e.properties.length; i++)r.checkLVal(e.properties[i].value, t, n); break; case 'ArrayPattern': for (let o = 0; o < e.elements.length; o++) { const s = e.elements[o]; s && r.checkLVal(s, t, n); } break; case 'AssignmentPattern': this.checkLVal(e.left, t, n); break; case 'RestElement': this.checkLVal(e.argument, t, n); break; case 'ParenthesizedExpression': this.checkLVal(e.expression, t, n); break; default: this.raise(e.start, `${t ? 'Binding' : 'Assigning to'} rvalue`); } }; const W = I.prototype; W.checkPropClash = function (e, t) { if (!(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) { let n; const r = e.key; switch (r.type) { case 'Identifier': n = r.name; break; case 'Literal': n = String(r.value); break; default: return; } const i = e.kind; if (this.options.ecmaVersion >= 6)n === '__proto__' && i === 'init' && (t.proto && this.raiseRecoverable(r.start, 'Redefinition of __proto__ property'), t.proto = !0); else { let o = t[n = `$${n}`]; if (o) { const s = i !== 'init'; (!this.strict && !s || !o[i]) && s ^ o.init || this.raiseRecoverable(r.start, 'Redefinition of property'); } else o = t[n] = { init: !1, get: !1, set: !1 }; o[i] = !0; } } }, W.parseExpression = function (e, t) { const n = this; const r = this.start; const i = this.startLoc; const o = this.parseMaybeAssign(e, t); if (this.type === O.comma) { const s = this.startNodeAt(r, i); for (s.expressions = [o]; this.eat(O.comma);)s.expressions.push(n.parseMaybeAssign(e, t)); return this.finishNode(s, 'SequenceExpression'); } return o; }, W.parseMaybeAssign = function (e, t, n) { if (this.inGenerator && this.isContextual('yield')) return this.parseYield(); let r = !1; t || (t = new V(), r = !0); const i = this.start; const o = this.startLoc; this.type != O.parenL && this.type != O.name || (this.potentialArrowAt = this.start); let s = this.parseMaybeConditional(e, t); if (n && (s = n.call(this, s, i, o)), this.type.isAssign) { this.checkPatternErrors(t, !0), r || V.call(t); const a = this.startNodeAt(i, o); return a.operator = this.value, a.left = this.type === O.eq ? this.toAssignable(s) : s, t.shorthandAssign = 0, this.checkLVal(s), this.next(), a.right = this.parseMaybeAssign(e), this.finishNode(a, 'AssignmentExpression'); } return r && this.checkExpressionErrors(t, !0), s; }, W.parseMaybeConditional = function (e, t) { const n = this.start; const r = this.startLoc; const i = this.parseExprOps(e, t); if (this.checkExpressionErrors(t)) return i; if (this.eat(O.question)) { const o = this.startNodeAt(n, r); return o.test = i, o.consequent = this.parseMaybeAssign(), this.expect(O.colon), o.alternate = this.parseMaybeAssign(e), this.finishNode(o, 'ConditionalExpression'); } return i; }, W.parseExprOps = function (e, t) { const n = this.start; const r = this.startLoc; const i = this.parseMaybeUnary(t, !1); return this.checkExpressionErrors(t) ? i : this.parseExprOp(i, n, r, -1, e); }, W.parseExprOp = function (e, t, n, r, i) { const o = this.type.binop; if (o != null && (!i || this.type !== O._in) && o > r) { const s = this.type === O.logicalOR || this.type === O.logicalAND; const a = this.value; this.next(); const u = this.start; const c = this.startLoc; const l = this.parseExprOp(this.parseMaybeUnary(null, !1), u, c, o, i); const p = this.buildBinary(t, n, e, l, a, s); return this.parseExprOp(p, t, n, r, i); } return e; }, W.buildBinary = function (e, t, n, r, i, o) { const s = this.startNodeAt(e, t); return s.left = n, s.operator = i, s.right = r, this.finishNode(s, o ? 'LogicalExpression' : 'BinaryExpression'); }, W.parseMaybeUnary = function (e, t) { let n; const r = this; const i = this.start; const o = this.startLoc; if (this.type.prefix) { const s = this.startNode(); const a = this.type === O.incDec; s.operator = this.value, s.prefix = !0, this.next(), s.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(e, !0), a ? this.checkLVal(s.argument) : this.strict && s.operator === 'delete' && s.argument.type === 'Identifier' ? this.raiseRecoverable(s.start, 'Deleting local variable in strict mode') : t = !0, n = this.finishNode(s, a ? 'UpdateExpression' : 'UnaryExpression'); } else { if (n = this.parseExprSubscripts(e), this.checkExpressionErrors(e)) return n; for (;this.type.postfix && !this.canInsertSemicolon();) { const u = r.startNodeAt(i, o); u.operator = r.value, u.prefix = !1, u.argument = n, r.checkLVal(n), r.next(), n = r.finishNode(u, 'UpdateExpression'); } } return !t && this.eat(O.starstar) ? this.buildBinary(i, o, n, this.parseMaybeUnary(null, !1), '**', !1) : n; }, W.parseExprSubscripts = function (e) { const t = this.start; const n = this.startLoc; const r = this.parseExprAtom(e); const i = r.type === 'ArrowFunctionExpression' && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ')'; return this.checkExpressionErrors(e) || i ? r : this.parseSubscripts(r, t, n); }, W.parseSubscripts = function (e, t, n, r) { for (let i = this; ;) if (i.eat(O.dot)) { const o = i.startNodeAt(t, n); o.object = e, o.property = i.parseIdent(!0), o.computed = !1, e = i.finishNode(o, 'MemberExpression'); } else if (i.eat(O.bracketL)) { const s = i.startNodeAt(t, n); s.object = e, s.property = i.parseExpression(), s.computed = !0, i.expect(O.bracketR), e = i.finishNode(s, 'MemberExpression'); } else if (!r && i.eat(O.parenL)) { const a = i.startNodeAt(t, n); a.callee = e, a.arguments = i.parseExprList(O.parenR, !1), e = i.finishNode(a, 'CallExpression'); } else { if (i.type !== O.backQuote) return e; const u = i.startNodeAt(t, n); u.tag = e, u.quasi = i.parseTemplate(), e = i.finishNode(u, 'TaggedTemplateExpression'); } }, W.parseExprAtom = function (e) { let t; const n = this.potentialArrowAt == this.start; switch (this.type) { case O._super: this.inFunction || this.raise(this.start, "'super' outside of function or class"); case O._this: var r = this.type === O._this ? 'ThisExpression' : 'Super'; return t = this.startNode(), this.next(), this.finishNode(t, r); case O.name: var i = this.start; var o = this.startLoc; var s = this.parseIdent(this.type !== O.name); return n && !this.canInsertSemicolon() && this.eat(O.arrow) ? this.parseArrowExpression(this.startNodeAt(i, o), [s]) : s; case O.regexp: var a = this.value; return t = this.parseLiteral(a.value), t.regex = { pattern: a.pattern, flags: a.flags }, t; case O.num: case O.string: return this.parseLiteral(this.value); case O._null: case O._true: case O._false: return t = this.startNode(), t.value = this.type === O._null ? null : this.type === O._true, t.raw = this.type.keyword, this.next(), this.finishNode(t, 'Literal'); case O.parenL: return this.parseParenAndDistinguishExpression(n); case O.bracketL: return t = this.startNode(), this.next(), t.elements = this.parseExprList(O.bracketR, !0, !0, e), this.finishNode(t, 'ArrayExpression'); case O.braceL: return this.parseObj(!1, e); case O._function: return t = this.startNode(), this.next(), this.parseFunction(t, !1); case O._class: return this.parseClass(this.startNode(), !1); case O._new: return this.parseNew(); case O.backQuote: return this.parseTemplate(); default: this.unexpected(); } }, W.parseLiteral = function (e) { const t = this.startNode(); return t.value = e, t.raw = this.input.slice(this.start, this.end), this.next(), this.finishNode(t, 'Literal'); }, W.parseParenExpression = function () { this.expect(O.parenL); const e = this.parseExpression(); return this.expect(O.parenR), e; }, W.parseParenAndDistinguishExpression = function (e) { let t; const n = this; const r = this.start; const i = this.startLoc; if (this.options.ecmaVersion >= 6) { this.next(); for (var o, s, a = this.start, u = this.startLoc, c = [], l = !0, p = new V(); this.type !== O.parenR;) { if (l ? l = !1 : n.expect(O.comma), n.type === O.ellipsis) { o = n.start, c.push(n.parseParenItem(n.parseRest())); break; }n.type !== O.parenL || s || (s = n.start), c.push(n.parseMaybeAssign(!1, p, n.parseParenItem)); } const h = this.start; const f = this.startLoc; if (this.expect(O.parenR), e && !this.canInsertSemicolon() && this.eat(O.arrow)) return this.checkPatternErrors(p, !0), s && this.unexpected(s), this.parseParenArrowList(r, i, c); c.length || this.unexpected(this.lastTokStart), o && this.unexpected(o), this.checkExpressionErrors(p, !0), c.length > 1 ? ((t = this.startNodeAt(a, u)).expressions = c, this.finishNodeAt(t, 'SequenceExpression', h, f)) : t = c[0]; } else t = this.parseParenExpression(); if (this.options.preserveParens) { const d = this.startNodeAt(r, i); return d.expression = t, this.finishNode(d, 'ParenthesizedExpression'); } return t; }, W.parseParenItem = function (e) { return e; }, W.parseParenArrowList = function (e, t, n) { return this.parseArrowExpression(this.startNodeAt(e, t), n); }; const G = []; W.parseNew = function () { const e = this.startNode(); const t = this.parseIdent(!0); if (this.options.ecmaVersion >= 6 && this.eat(O.dot)) return e.meta = t, e.property = this.parseIdent(!0), e.property.name !== 'target' && this.raiseRecoverable(e.property.start, 'The only valid meta property for new is new.target'), this.inFunction || this.raiseRecoverable(e.start, 'new.target can only be used in functions'), this.finishNode(e, 'MetaProperty'); const n = this.start; const r = this.startLoc; return e.callee = this.parseSubscripts(this.parseExprAtom(), n, r, !0), this.eat(O.parenL) ? e.arguments = this.parseExprList(O.parenR, !1) : e.arguments = G, this.finishNode(e, 'NewExpression'); }, W.parseTemplateElement = function () { const e = this.startNode(); return e.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'), cooked: this.value }, this.next(), e.tail = this.type === O.backQuote, this.finishNode(e, 'TemplateElement'); }, W.parseTemplate = function () { const e = this; const t = this.startNode(); this.next(), t.expressions = []; let n = this.parseTemplateElement(); for (t.quasis = [n]; !n.tail;)e.expect(O.dollarBraceL), t.expressions.push(e.parseExpression()), e.expect(O.braceR), t.quasis.push(n = e.parseTemplateElement()); return this.next(), this.finishNode(t, 'TemplateLiteral'); }, W.parseObj = function (e, t) { const n = this; const r = this.startNode(); let i = !0; const o = {}; for (r.properties = [], this.next(); !this.eat(O.braceR);) { if (i)i = !1; else if (n.expect(O.comma), n.afterTrailingComma(O.braceR)) break; var s; var a; var u; const c = n.startNode(); n.options.ecmaVersion >= 6 && (c.method = !1, c.shorthand = !1, (e || t) && (a = n.start, u = n.startLoc), e || (s = n.eat(O.star))), n.parsePropertyName(c), n.parsePropertyValue(c, e, s, a, u, t), n.checkPropClash(c, o), r.properties.push(n.finishNode(c, 'Property')); } return this.finishNode(r, e ? 'ObjectPattern' : 'ObjectExpression'); }, W.parsePropertyValue = function (e, t, n, r, i, o) { if (this.eat(O.colon))e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, o), e.kind = 'init'; else if (this.options.ecmaVersion >= 6 && this.type === O.parenL)t && this.unexpected(), e.kind = 'init', e.method = !0, e.value = this.parseMethod(n); else if (this.options.ecmaVersion >= 5 && !e.computed && e.key.type === 'Identifier' && (e.key.name === 'get' || e.key.name === 'set') && this.type != O.comma && this.type != O.braceR) { (n || t) && this.unexpected(), e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(!1); const s = e.kind === 'get' ? 0 : 1; if (e.value.params.length !== s) { const a = e.value.start; e.kind === 'get' ? this.raiseRecoverable(a, 'getter should have no params') : this.raiseRecoverable(a, 'setter should have exactly one param'); }e.kind === 'set' && e.value.params[0].type === 'RestElement' && this.raiseRecoverable(e.value.params[0].start, 'Setter cannot use rest params'); } else this.options.ecmaVersion >= 6 && !e.computed && e.key.type === 'Identifier' ? ((this.keywords.test(e.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(e.key.name) || this.inGenerator && e.key.name == 'yield') && this.raiseRecoverable(e.key.start, `'${e.key.name}' can not be used as shorthand property`), e.kind = 'init', t ? e.value = this.parseMaybeDefault(r, i, e.key) : this.type === O.eq && o ? (o.shorthandAssign || (o.shorthandAssign = this.start), e.value = this.parseMaybeDefault(r, i, e.key)) : e.value = e.key, e.shorthand = !0) : this.unexpected(); }, W.parsePropertyName = function (e) { if (this.options.ecmaVersion >= 6) { if (this.eat(O.bracketL)) return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(O.bracketR), e.key; e.computed = !1; } return e.key = this.type === O.num || this.type === O.string ? this.parseExprAtom() : this.parseIdent(!0); }, W.initFunction = function (e) { e.id = null, this.options.ecmaVersion >= 6 && (e.generator = !1, e.expression = !1); }, W.parseMethod = function (e) { const t = this.startNode(); const n = this.inGenerator; return this.inGenerator = e, this.initFunction(t), this.expect(O.parenL), t.params = this.parseBindingList(O.parenR, !1, !1), this.options.ecmaVersion >= 6 && (t.generator = e), this.parseFunctionBody(t, !1), this.inGenerator = n, this.finishNode(t, 'FunctionExpression'); }, W.parseArrowExpression = function (e, t) { const n = this.inGenerator; return this.inGenerator = !1, this.initFunction(e), e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0), this.inGenerator = n, this.finishNode(e, 'ArrowFunctionExpression'); }, W.parseFunctionBody = function (e, t) { const n = t && this.type !== O.braceL; if (n)e.body = this.parseMaybeAssign(), e.expression = !0; else { const r = this.inFunction; const i = this.labels; this.inFunction = !0, this.labels = [], e.body = this.parseBlock(!0), e.expression = !1, this.inFunction = r, this.labels = i; } const o = !n && e.body.body.length && this.isUseStrict(e.body.body[0]) ? e.body.body[0] : null; if (this.strict || o) { const s = this.strict; this.strict = !0, e.id && this.checkLVal(e.id, !0), this.checkParams(e, o), this.strict = s; } else t && this.checkParams(e, o); }, W.checkParams = function (e, t) { for (let n = this, r = {}, i = 0; i < e.params.length; i++)t && n.options.ecmaVersion >= 7 && e.params[i].type !== 'Identifier' && n.raiseRecoverable(t.start, "Illegal 'use strict' directive in function with non-simple parameter list"), n.checkLVal(e.params[i], !0, r); }, W.parseExprList = function (e, t, n, r) { for (var i = this, o = [], s = !0; !this.eat(e);) { if (s)s = !1; else if (i.expect(O.comma), t && i.afterTrailingComma(e)) break; var a; n && i.type === O.comma ? a = null : i.type === O.ellipsis ? (a = i.parseSpread(r), i.type === O.comma && r && !r.trailingComma && (r.trailingComma = i.lastTokStart)) : a = i.parseMaybeAssign(!1, r), o.push(a); } return o; }, W.parseIdent = function (e) { const t = this.startNode(); return e && this.options.allowReserved == 'never' && (e = !1), this.type === O.name ? (!e && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf('\\') == -1) && this.raiseRecoverable(this.start, `The keyword '${this.value}' is reserved`), !e && this.inGenerator && this.value === 'yield' && this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator"), t.name = this.value) : e && this.type.keyword ? t.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(t, 'Identifier'); }, W.parseYield = function () { const e = this.startNode(); return this.next(), this.type == O.semi || this.canInsertSemicolon() || this.type != O.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat(O.star), e.argument = this.parseMaybeAssign()), this.finishNode(e, 'YieldExpression'); }; const Y = I.prototype; Y.raise = function (e, t) { const n = c(this.input, e); t += ` (${n.line}:${n.column})`; const r = new SyntaxError(t); throw r.pos = e, r.loc = n, r.raisedAt = this.pos, r; }, Y.raiseRecoverable = Y.raise, Y.curPosition = function () { if (this.options.locations) return new N(this.curLine, this.pos - this.lineStart); }; const X = function (e, t, n) { this.type = '', this.start = t, this.end = 0, e.options.locations && (this.loc = new M(e, n)), e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile), e.options.ranges && (this.range = [t, 0]); }; const K = I.prototype; K.startNode = function () { return new X(this, this.start, this.startLoc); }, K.startNodeAt = function (e, t) { return new X(this, e, t); }, K.finishNode = function (e, t) { return f.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc); }, K.finishNodeAt = function (e, t, n, r) { return f.call(this, e, t, n, r); }; const J = function (e, t, n, r) { this.token = e, this.isExpr = !!t, this.preserveSpace = !!n, this.override = r; }; const Q = {
        b_stat: new J('{', !1), b_expr: new J('{', !0), b_tmpl: new J('${', !0), p_stat: new J('(', !1), p_expr: new J('(', !0), q_tmpl: new J('`', !0, !0, (e => e.readTmplToken())), f_expr: new J('function', !0),
      }; const Z = I.prototype; Z.initialContext = function () { return [Q.b_stat]; }, Z.braceIsBlock = function (e) { if (e === O.colon) { const t = this.curContext(); if (t === Q.b_stat || t === Q.b_expr) return !t.isExpr; } return e === O._return ? F.test(this.input.slice(this.lastTokEnd, this.start)) : e === O._else || e === O.semi || e === O.eof || e === O.parenR || (e == O.braceL ? this.curContext() === Q.b_stat : !this.exprAllowed); }, Z.updateContext = function (e) { let t; const n = this.type; n.keyword && e == O.dot ? this.exprAllowed = !1 : (t = n.updateContext) ? t.call(this, e) : this.exprAllowed = n.beforeExpr; }, O.parenR.updateContext = O.braceR.updateContext = function () { if (this.context.length != 1) { const e = this.context.pop(); e === Q.b_stat && this.curContext() === Q.f_expr ? (this.context.pop(), this.exprAllowed = !1) : this.exprAllowed = e === Q.b_tmpl || !e.isExpr; } else this.exprAllowed = !0; }, O.braceL.updateContext = function (e) { this.context.push(this.braceIsBlock(e) ? Q.b_stat : Q.b_expr), this.exprAllowed = !0; }, O.dollarBraceL.updateContext = function () { this.context.push(Q.b_tmpl), this.exprAllowed = !0; }, O.parenL.updateContext = function (e) { const t = e === O._if || e === O._for || e === O._with || e === O._while; this.context.push(t ? Q.p_stat : Q.p_expr), this.exprAllowed = !0; }, O.incDec.updateContext = function () {}, O._function.updateContext = function (e) { e.beforeExpr && e !== O.semi && e !== O._else && (e !== O.colon && e !== O.braceL || this.curContext() !== Q.b_stat) && this.context.push(Q.f_expr), this.exprAllowed = !1; }, O.backQuote.updateContext = function () { this.curContext() === Q.q_tmpl ? this.context.pop() : this.context.push(Q.q_tmpl), this.exprAllowed = !1; }; const ee = function (e) { this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, e.options.locations && (this.loc = new M(e, e.startLoc, e.endLoc)), e.options.ranges && (this.range = [e.start, e.end]); }; const te = I.prototype; const ne = typeof Packages === 'object' && Object.prototype.toString.call(Packages) == '[object JavaPackage]'; te.next = function () { this.options.onToken && this.options.onToken(new ee(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken(); }, te.getToken = function () { return this.next(), new ee(this); }, typeof Symbol !== 'undefined' && (te[Symbol.iterator] = function () { const e = this; return { next() { const t = e.getToken(); return { done: t.type === O.eof, value: t }; } }; }), te.setStrict = function (e) { const t = this; if (this.strict = e, this.type === O.num || this.type === O.string) { if (this.pos = this.start, this.options.locations) for (;this.pos < this.lineStart;)t.lineStart = t.input.lastIndexOf('\n', t.lineStart - 2) + 1, --t.curLine; this.nextToken(); } }, te.curContext = function () { return this.context[this.context.length - 1]; }, te.nextToken = function () { const e = this.curContext(); return e && e.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(O.eof) : e.override ? e.override(this) : void this.readToken(this.fullCharCodeAtPos()); }, te.readToken = function (e) { return n(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e); }, te.fullCharCodeAtPos = function () { const e = this.input.charCodeAt(this.pos); return e <= 55295 || e >= 57344 ? e : (e << 10) + this.input.charCodeAt(this.pos + 1) - 56613888; }, te.skipBlockComment = function () { const e = this; const t = this.options.onComment && this.curPosition(); const n = this.pos; const r = this.input.indexOf('*/', this.pos += 2); if (r === -1 && this.raise(this.pos - 2, 'Unterminated comment'), this.pos = r + 2, this.options.locations) { B.lastIndex = n; for (var i; (i = B.exec(this.input)) && i.index < this.pos;)++e.curLine, e.lineStart = i.index + i[0].length; } this.options.onComment && this.options.onComment(!0, this.input.slice(n + 2, r), n, this.pos, t, this.curPosition()); }, te.skipLineComment = function (e) { for (var t = this, n = this.pos, r = this.options.onComment && this.curPosition(), i = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && i !== 10 && i !== 13 && i !== 8232 && i !== 8233;)++t.pos, i = t.input.charCodeAt(t.pos); this.options.onComment && this.options.onComment(!1, this.input.slice(n + e, this.pos), n, this.pos, r, this.curPosition()); }, te.skipSpace = function () { const e = this; e:for (;this.pos < this.input.length;) { const t = e.input.charCodeAt(e.pos); switch (t) { case 32: case 160: ++e.pos; break; case 13: e.input.charCodeAt(e.pos + 1) === 10 && ++e.pos; case 10: case 8232: case 8233: ++e.pos, e.options.locations && (++e.curLine, e.lineStart = e.pos); break; case 47: switch (e.input.charCodeAt(e.pos + 1)) { case 42: e.skipBlockComment(); break; case 47: e.skipLineComment(2); break; default: break e; } break; default: if (!(t > 8 && t < 14 || t >= 5760 && D.test(String.fromCharCode(t)))) break e; ++e.pos; } } }, te.finishToken = function (e, t) { this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition()); const n = this.type; this.type = e, this.value = t, this.updateContext(n); }, te.readToken_dot = function () { const e = this.input.charCodeAt(this.pos + 1); if (e >= 48 && e <= 57) return this.readNumber(!0); const t = this.input.charCodeAt(this.pos + 2); return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(O.ellipsis)) : (++this.pos, this.finishToken(O.dot)); }, te.readToken_slash = function () { const e = this.input.charCodeAt(this.pos + 1); return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(O.assign, 2) : this.finishOp(O.slash, 1); }, te.readToken_mult_modulo_exp = function (e) { let t = this.input.charCodeAt(this.pos + 1); let n = 1; let r = e === 42 ? O.star : O.modulo; return this.options.ecmaVersion >= 7 && t === 42 && (++n, r = O.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(O.assign, n + 1) : this.finishOp(r, n); }, te.readToken_pipe_amp = function (e) { const t = this.input.charCodeAt(this.pos + 1); return t === e ? this.finishOp(e === 124 ? O.logicalOR : O.logicalAND, 2) : t === 61 ? this.finishOp(O.assign, 2) : this.finishOp(e === 124 ? O.bitwiseOR : O.bitwiseAND, 1); }, te.readToken_caret = function () { return this.input.charCodeAt(this.pos + 1) === 61 ? this.finishOp(O.assign, 2) : this.finishOp(O.bitwiseXOR, 1); }, te.readToken_plus_min = function (e) { const t = this.input.charCodeAt(this.pos + 1); return t === e ? t == 45 && this.input.charCodeAt(this.pos + 2) == 62 && F.test(this.input.slice(this.lastTokEnd, this.pos)) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(O.incDec, 2) : t === 61 ? this.finishOp(O.assign, 2) : this.finishOp(O.plusMin, 1); }, te.readToken_lt_gt = function (e) { const t = this.input.charCodeAt(this.pos + 1); let n = 1; return t === e ? (n = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + n) === 61 ? this.finishOp(O.assign, n + 1) : this.finishOp(O.bitShift, n)) : t == 33 && e == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45 ? (this.inModule && this.unexpected(), this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (n = 2), this.finishOp(O.relational, n)); }, te.readToken_eq_excl = function (e) { const t = this.input.charCodeAt(this.pos + 1); return t === 61 ? this.finishOp(O.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(O.arrow)) : this.finishOp(e === 61 ? O.eq : O.prefix, 1); }, te.getTokenFromCode = function (e) { switch (e) { case 46: return this.readToken_dot(); case 40: return ++this.pos, this.finishToken(O.parenL); case 41: return ++this.pos, this.finishToken(O.parenR); case 59: return ++this.pos, this.finishToken(O.semi); case 44: return ++this.pos, this.finishToken(O.comma); case 91: return ++this.pos, this.finishToken(O.bracketL); case 93: return ++this.pos, this.finishToken(O.bracketR); case 123: return ++this.pos, this.finishToken(O.braceL); case 125: return ++this.pos, this.finishToken(O.braceR); case 58: return ++this.pos, this.finishToken(O.colon); case 63: return ++this.pos, this.finishToken(O.question); case 96: if (this.options.ecmaVersion < 6) break; return ++this.pos, this.finishToken(O.backQuote); case 48: var t = this.input.charCodeAt(this.pos + 1); if (t === 120 || t === 88) return this.readRadixNumber(16); if (this.options.ecmaVersion >= 6) { if (t === 111 || t === 79) return this.readRadixNumber(8); if (t === 98 || t === 66) return this.readRadixNumber(2); } case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return this.readNumber(!1); case 34: case 39: return this.readString(e); case 47: return this.readToken_slash(); case 37: case 42: return this.readToken_mult_modulo_exp(e); case 124: case 38: return this.readToken_pipe_amp(e); case 94: return this.readToken_caret(); case 43: case 45: return this.readToken_plus_min(e); case 60: case 62: return this.readToken_lt_gt(e); case 61: case 33: return this.readToken_eq_excl(e); case 126: return this.finishOp(O.prefix, 1); } this.raise(this.pos, `Unexpected character '${m(e)}'`); }, te.finishOp = function (e, t) { const n = this.input.slice(this.pos, this.pos + t); return this.pos += t, this.finishToken(e, n); }; const re = !!d('ï¿¿', 'u'); te.readRegexp = function () { for (var e, t, n = this, r = this.pos; ;) { n.pos >= n.input.length && n.raise(r, 'Unterminated regular expression'); const i = n.input.charAt(n.pos); if (F.test(i) && n.raise(r, 'Unterminated regular expression'), e)e = !1; else { if (i === '[')t = !0; else if (i === ']' && t)t = !1; else if (i === '/' && !t) break; e = i === '\\'; }++n.pos; } const o = this.input.slice(r, this.pos); ++this.pos; const s = this.readWord1(); let a = o; let u = ''; if (s) { let c = /^[gim]*$/; this.options.ecmaVersion >= 6 && (c = /^[gimuy]*$/), c.test(s) || this.raise(r, 'Invalid regular expression flag'), s.indexOf('u') >= 0 && (re ? u = 'u' : (a = (a = a.replace(/\\u\{([0-9a-fA-F]+)\}/g, (e, t, i) => (t = Number(`0x${t}`)) > 1114111 && n.raise(r + i + 3, 'Code point out of bounds'), 'x')).replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x'), u = u.replace('u', ''))); } let l = null; return ne || (d(a, u, r, this), l = d(o, s)), this.finishToken(O.regexp, { pattern: o, flags: s, value: l }); }, te.readInt = function (e, t) { for (var n = this, r = this.pos, i = 0, o = 0, s = t == null ? 1 / 0 : t; o < s; ++o) { var a; const u = n.input.charCodeAt(n.pos); if ((a = u >= 97 ? u - 97 + 10 : u >= 65 ? u - 65 + 10 : u >= 48 && u <= 57 ? u - 48 : 1 / 0) >= e) break; ++n.pos, i = i * e + a; } return this.pos === r || t != null && this.pos - r !== t ? null : i; }, te.readRadixNumber = function (e) { this.pos += 2; const t = this.readInt(e); return t == null && this.raise(this.start + 2, `Expected number in radix ${e}`), n(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'), this.finishToken(O.num, t); }, te.readNumber = function (e) { const t = this.pos; let r = !1; const i = this.input.charCodeAt(this.pos) === 48; e || this.readInt(10) !== null || this.raise(t, 'Invalid number'); let o = this.input.charCodeAt(this.pos); o === 46 && (++this.pos, this.readInt(10), r = !0, o = this.input.charCodeAt(this.pos)), o !== 69 && o !== 101 || ((o = this.input.charCodeAt(++this.pos)) !== 43 && o !== 45 || ++this.pos, this.readInt(10) === null && this.raise(t, 'Invalid number'), r = !0), n(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'); let s; const a = this.input.slice(t, this.pos); return r ? s = parseFloat(a) : i && a.length !== 1 ? /[89]/.test(a) || this.strict ? this.raise(t, 'Invalid number') : s = parseInt(a, 8) : s = parseInt(a, 10), this.finishToken(O.num, s); }, te.readCodePoint = function () { let e; if (this.input.charCodeAt(this.pos) === 123) { this.options.ecmaVersion < 6 && this.unexpected(); const t = ++this.pos; e = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos), ++this.pos, e > 1114111 && this.raise(t, 'Code point out of bounds'); } else e = this.readHexChar(4); return e; }, te.readString = function (e) { for (var t = this, n = '', r = ++this.pos; ;) { t.pos >= t.input.length && t.raise(t.start, 'Unterminated string constant'); const i = t.input.charCodeAt(t.pos); if (i === e) break; i === 92 ? (n += t.input.slice(r, t.pos), n += t.readEscapedChar(!1), r = t.pos) : (s(i) && t.raise(t.start, 'Unterminated string constant'), ++t.pos); } return n += this.input.slice(r, this.pos++), this.finishToken(O.string, n); }, te.readTmplToken = function () { for (let e = this, t = '', n = this.pos; ;) { e.pos >= e.input.length && e.raise(e.start, 'Unterminated template'); const r = e.input.charCodeAt(e.pos); if (r === 96 || r === 36 && e.input.charCodeAt(e.pos + 1) === 123) return e.pos === e.start && e.type === O.template ? r === 36 ? (e.pos += 2, e.finishToken(O.dollarBraceL)) : (++e.pos, e.finishToken(O.backQuote)) : (t += e.input.slice(n, e.pos), e.finishToken(O.template, t)); if (r === 92)t += e.input.slice(n, e.pos), t += e.readEscapedChar(!0), n = e.pos; else if (s(r)) { switch (t += e.input.slice(n, e.pos), ++e.pos, r) { case 13: e.input.charCodeAt(e.pos) === 10 && ++e.pos; case 10: t += '\n'; break; default: t += String.fromCharCode(r); }e.options.locations && (++e.curLine, e.lineStart = e.pos), n = e.pos; } else ++e.pos; } }, te.readEscapedChar = function (e) { const t = this.input.charCodeAt(++this.pos); switch (++this.pos, t) { case 110: return '\n'; case 114: return '\r'; case 120: return String.fromCharCode(this.readHexChar(2)); case 117: return m(this.readCodePoint()); case 116: return '\t'; case 98: return '\b'; case 118: return '\v'; case 102: return '\f'; case 13: this.input.charCodeAt(this.pos) === 10 && ++this.pos; case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), ''; default: if (t >= 48 && t <= 55) { let n = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]; let r = parseInt(n, 8); return r > 255 && (n = n.slice(0, -1), r = parseInt(n, 8)), n !== '0' && (this.strict || e) && this.raise(this.pos - 2, 'Octal literal in strict mode'), this.pos += n.length - 1, String.fromCharCode(r); } return String.fromCharCode(t); } }, te.readHexChar = function (e) { const t = this.pos; const n = this.readInt(16, e); return n === null && this.raise(t, 'Bad character escape sequence'), n; }, te.readWord1 = function () { const e = this; this.containsEsc = !1; for (var t = '', i = !0, o = this.pos, s = this.options.ecmaVersion >= 6; this.pos < this.input.length;) { const a = e.fullCharCodeAtPos(); if (r(a, s))e.pos += a <= 65535 ? 1 : 2; else { if (a !== 92) break; e.containsEsc = !0, t += e.input.slice(o, e.pos); const u = e.pos; e.input.charCodeAt(++e.pos) != 117 && e.raise(e.pos, 'Expecting Unicode escape sequence \\uXXXX'), ++e.pos; const c = e.readCodePoint(); (i ? n : r)(c, s) || e.raise(u, 'Invalid Unicode escape'), t += m(c), o = e.pos; }i = !1; } return t + this.input.slice(o, this.pos); }, te.readWord = function () { const e = this.readWord1(); let t = O.name; return (this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(e) && (t = T[e]), this.finishToken(t, e); }; e.version = '3.3.0', e.parse = function (e, t) { return new I(t, e).parse(); }, e.parseExpressionAt = function (e, t, n) { const r = new I(n, e, t); return r.nextToken(), r.parseExpression(); }, e.tokenizer = function (e, t) { return new I(t, e); }, e.Parser = I, e.plugins = P, e.defaultOptions = R, e.Position = N, e.SourceLocation = M, e.getLineInfo = c, e.Node = X, e.TokenType = A, e.tokTypes = O, e.TokContext = J, e.tokContexts = Q, e.isIdentifierChar = r, e.isIdentifierStart = n, e.Token = ee, e.isNewLine = s, e.lineBreak = F, e.lineBreakG = B, Object.defineProperty(e, '__esModule', { value: !0 });
    }));
  }, {}],
  15: [function (e, t, n) {
    !(function (e, r) { typeof n === 'object' && void 0 !== t ? r(n) : typeof define === 'function' && define.amd ? define(['exports'], r) : r((e.acorn = e.acorn || {}, e.acorn.walk = e.acorn.walk || {})); }(this, (e) => {
      function t(e) { return typeof e === 'string' ? function (t) { return t == e; } : e || function () { return !0; }; } function n(e, t, n) { n(e, t); } function r(e, t, n) {} const i = function (e, t) { this.node = e, this.state = t; }; const o = Object.create || function (e) { function t() {} return t.prototype = e, new t(); }; const s = {}; s.Program = s.BlockStatement = function (e, t, n) { for (let r = 0; r < e.body.length; ++r)n(e.body[r], t, 'Statement'); }, s.Statement = n, s.EmptyStatement = r, s.ExpressionStatement = s.ParenthesizedExpression = function (e, t, n) { return n(e.expression, t, 'Expression'); }, s.IfStatement = function (e, t, n) { n(e.test, t, 'Expression'), n(e.consequent, t, 'Statement'), e.alternate && n(e.alternate, t, 'Statement'); }, s.LabeledStatement = function (e, t, n) { return n(e.body, t, 'Statement'); }, s.BreakStatement = s.ContinueStatement = r, s.WithStatement = function (e, t, n) { n(e.object, t, 'Expression'), n(e.body, t, 'Statement'); }, s.SwitchStatement = function (e, t, n) { n(e.discriminant, t, 'Expression'); for (let r = 0; r < e.cases.length; ++r) { const i = e.cases[r]; i.test && n(i.test, t, 'Expression'); for (let o = 0; o < i.consequent.length; ++o)n(i.consequent[o], t, 'Statement'); } }, s.ReturnStatement = s.YieldExpression = function (e, t, n) { e.argument && n(e.argument, t, 'Expression'); }, s.ThrowStatement = s.SpreadElement = function (e, t, n) { return n(e.argument, t, 'Expression'); }, s.TryStatement = function (e, t, n) { n(e.block, t, 'Statement'), e.handler && n(e.handler, t), e.finalizer && n(e.finalizer, t, 'Statement'); }, s.CatchClause = function (e, t, n) { n(e.param, t, 'Pattern'), n(e.body, t, 'ScopeBody'); }, s.WhileStatement = s.DoWhileStatement = function (e, t, n) { n(e.test, t, 'Expression'), n(e.body, t, 'Statement'); }, s.ForStatement = function (e, t, n) { e.init && n(e.init, t, 'ForInit'), e.test && n(e.test, t, 'Expression'), e.update && n(e.update, t, 'Expression'), n(e.body, t, 'Statement'); }, s.ForInStatement = s.ForOfStatement = function (e, t, n) { n(e.left, t, 'ForInit'), n(e.right, t, 'Expression'), n(e.body, t, 'Statement'); }, s.ForInit = function (e, t, n) { e.type == 'VariableDeclaration' ? n(e, t) : n(e, t, 'Expression'); }, s.DebuggerStatement = r, s.FunctionDeclaration = function (e, t, n) { return n(e, t, 'Function'); }, s.VariableDeclaration = function (e, t, n) { for (let r = 0; r < e.declarations.length; ++r)n(e.declarations[r], t); }, s.VariableDeclarator = function (e, t, n) { n(e.id, t, 'Pattern'), e.init && n(e.init, t, 'Expression'); }, s.Function = function (e, t, n) { e.id && n(e.id, t, 'Pattern'); for (let r = 0; r < e.params.length; r++)n(e.params[r], t, 'Pattern'); n(e.body, t, e.expression ? 'ScopeExpression' : 'ScopeBody'); }, s.ScopeBody = function (e, t, n) { return n(e, t, 'Statement'); }, s.ScopeExpression = function (e, t, n) { return n(e, t, 'Expression'); }, s.Pattern = function (e, t, n) { e.type == 'Identifier' ? n(e, t, 'VariablePattern') : e.type == 'MemberExpression' ? n(e, t, 'MemberPattern') : n(e, t); }, s.VariablePattern = r, s.MemberPattern = n, s.RestElement = function (e, t, n) { return n(e.argument, t, 'Pattern'); }, s.ArrayPattern = function (e, t, n) { for (let r = 0; r < e.elements.length; ++r) { const i = e.elements[r]; i && n(i, t, 'Pattern'); } }, s.ObjectPattern = function (e, t, n) { for (let r = 0; r < e.properties.length; ++r)n(e.properties[r].value, t, 'Pattern'); }, s.Expression = n, s.ThisExpression = s.Super = s.MetaProperty = r, s.ArrayExpression = function (e, t, n) { for (let r = 0; r < e.elements.length; ++r) { const i = e.elements[r]; i && n(i, t, 'Expression'); } }, s.ObjectExpression = function (e, t, n) { for (let r = 0; r < e.properties.length; ++r)n(e.properties[r], t); }, s.FunctionExpression = s.ArrowFunctionExpression = s.FunctionDeclaration, s.SequenceExpression = s.TemplateLiteral = function (e, t, n) { for (let r = 0; r < e.expressions.length; ++r)n(e.expressions[r], t, 'Expression'); }, s.UnaryExpression = s.UpdateExpression = function (e, t, n) { n(e.argument, t, 'Expression'); }, s.BinaryExpression = s.LogicalExpression = function (e, t, n) { n(e.left, t, 'Expression'), n(e.right, t, 'Expression'); }, s.AssignmentExpression = s.AssignmentPattern = function (e, t, n) { n(e.left, t, 'Pattern'), n(e.right, t, 'Expression'); }, s.ConditionalExpression = function (e, t, n) { n(e.test, t, 'Expression'), n(e.consequent, t, 'Expression'), n(e.alternate, t, 'Expression'); }, s.NewExpression = s.CallExpression = function (e, t, n) { if (n(e.callee, t, 'Expression'), e.arguments) for (let r = 0; r < e.arguments.length; ++r)n(e.arguments[r], t, 'Expression'); }, s.MemberExpression = function (e, t, n) { n(e.object, t, 'Expression'), e.computed && n(e.property, t, 'Expression'); }, s.ExportNamedDeclaration = s.ExportDefaultDeclaration = function (e, t, n) { e.declaration && n(e.declaration, t, e.type == 'ExportNamedDeclaration' || e.declaration.id ? 'Statement' : 'Expression'), e.source && n(e.source, t, 'Expression'); }, s.ExportAllDeclaration = function (e, t, n) { n(e.source, t, 'Expression'); }, s.ImportDeclaration = function (e, t, n) { for (let r = 0; r < e.specifiers.length; r++)n(e.specifiers[r], t); n(e.source, t, 'Expression'); }, s.ImportSpecifier = s.ImportDefaultSpecifier = s.ImportNamespaceSpecifier = s.Identifier = s.Literal = r, s.TaggedTemplateExpression = function (e, t, n) { n(e.tag, t, 'Expression'), n(e.quasi, t); }, s.ClassDeclaration = s.ClassExpression = function (e, t, n) { return n(e, t, 'Class'); }, s.Class = function (e, t, n) { e.id && n(e.id, t, 'Pattern'), e.superClass && n(e.superClass, t, 'Expression'); for (let r = 0; r < e.body.body.length; r++)n(e.body.body[r], t); }, s.MethodDefinition = s.Property = function (e, t, n) { e.computed && n(e.key, t, 'Expression'), n(e.value, t, 'Expression'); }, e.simple = function (t, n, r, i, o) { r || (r = e.base), (function e(t, i, o) { const s = o || t.type; const a = n[s]; r[s](t, i, e), a && a(t, i); }(t, i, o)); }, e.ancestor = function (t, n, r, i) { r || (r = e.base); const o = []; !(function e(t, i, s) { const a = s || t.type; const u = n[a]; const c = t != o[o.length - 1]; c && o.push(t), r[a](t, i, e), u && u(t, i || o, o), c && o.pop(); }(t, i)); }, e.recursive = function (t, n, r, i, o) { const s = r ? e.make(r, i) : i; !(function e(t, n, r) { s[r || t.type](t, n, e); }(t, n, o)); }, e.findNodeAt = function (n, r, o, s, a, u) { s = t(s), a || (a = e.base); try { !(function e(t, n, u) { const c = u || t.type; if ((r == null || t.start <= r) && (o == null || t.end >= o) && a[c](t, n, e), (r == null || t.start == r) && (o == null || t.end == o) && s(c, t)) throw new i(t, n); }(n, u)); } catch (e) { if (e instanceof i) return e; throw e; } }, e.findNodeAround = function (n, r, o, s, a) { o = t(o), s || (s = e.base); try { !(function e(t, n, a) { const u = a || t.type; if (!(t.start > r || t.end < r) && (s[u](t, n, e), o(u, t))) throw new i(t, n); }(n, a)); } catch (e) { if (e instanceof i) return e; throw e; } }, e.findNodeAfter = function (n, r, o, s, a) { o = t(o), s || (s = e.base); try { !(function e(t, n, a) { if (!(t.end < r)) { const u = a || t.type; if (t.start >= r && o(u, t)) throw new i(t, n); s[u](t, n, e); } }(n, a)); } catch (e) { if (e instanceof i) return e; throw e; } }, e.findNodeBefore = function (n, r, o, s, a) { o = t(o), s || (s = e.base); let u; return (function e(t, n, a) { if (!(t.start > r)) { const c = a || t.type; t.end <= r && (!u || u.node.end < t.end) && o(c, t) && (u = new i(t, n)), s[c](t, n, e); } }(n, a)), u; }, e.make = function (t, n) { n || (n = e.base); const r = o(n); for (const i in t)r[i] = t[i]; return r; }, e.base = s, Object.defineProperty(e, '__esModule', { value: !0 });
    }));
  }, {}],
  16: [function (e, t, n) {
    const r = e('acorn'); const i = e('object-assign'); t.exports = function (e, t) { t = i({}, o, t); try { const n = new r.Parser(t, e, 0); t.strict && (n.strict = !0), t.lineComment || (n.skipLineComment = function (e) { this.raise(this.pos, 'Line comments not allowed in an expression'); }), n.nextToken(), n.parseExpression(), n.type !== r.tokTypes.eof && n.unexpected(); } catch (e) { if (!t.throw) return !1; throw e; } return !0; }; var o = { throw: !1, strict: !1, lineComment: !1 };
  }, { acorn: 14, 'object-assign': 28 }],
  17: [function (e, t, n) {
    t.exports = {
      html: '<!DOCTYPE html>', xml: '<?xml version="1.0" encoding="utf-8" ?>', transitional: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">', strict: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">', frameset: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">', 1.1: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">', basic: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">', mobile: '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">', plist: '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">',
    };
  }, {}],
  18: [function (e, t, n) {
    const r = Array.prototype.slice; const i = Object.prototype.toString; t.exports = function (e) { const t = this; if (typeof t !== 'function' || i.call(t) !== '[object Function]') throw new TypeError(`Function.prototype.bind called on incompatible ${t}`); for (var n, o = r.call(arguments, 1), s = Math.max(0, t.length - o.length), a = [], u = 0; u < s; u++)a.push(`$${u}`); if (n = Function('binder', `return function (${a.join(',')}){ return binder.apply(this,arguments); }`)(function () { if (this instanceof n) { const i = t.apply(this, o.concat(r.call(arguments))); return Object(i) === i ? i : this; } return t.apply(e, o.concat(r.call(arguments))); }), t.prototype) { const c = function () {}; c.prototype = t.prototype, n.prototype = new c(), c.prototype = null; } return n; };
  }, {}],
  19: [function (e, t, n) {
    const r = e('./implementation'); t.exports = Function.prototype.bind || r;
  }, { './implementation': 18 }],
  20: [function (e, t, n) { const r = e('function-bind'); t.exports = r.call(Function.call, Object.prototype.hasOwnProperty); }, { 'function-bind': 19 }],
  21: [function (e, t, n) { n.read = function (e, t, n, r, i) { let o; let s; const a = 8 * i - r - 1; const u = (1 << a) - 1; const c = u >> 1; let l = -7; let p = n ? i - 1 : 0; const h = n ? -1 : 1; let f = e[t + p]; for (p += h, o = f & (1 << -l) - 1, f >>= -l, l += a; l > 0; o = 256 * o + e[t + p], p += h, l -= 8);for (s = o & (1 << -l) - 1, o >>= -l, l += r; l > 0; s = 256 * s + e[t + p], p += h, l -= 8);if (o === 0)o = 1 - c; else { if (o === u) return s ? NaN : 1 / 0 * (f ? -1 : 1); s += Math.pow(2, r), o -= c; } return (f ? -1 : 1) * s * Math.pow(2, o - r); }, n.write = function (e, t, n, r, i, o) { let s; let a; let u; let c = 8 * o - i - 1; const l = (1 << c) - 1; const p = l >> 1; const h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0; let f = r ? 0 : o - 1; const d = r ? 1 : -1; const m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (t += s + p >= 1 ? h / u : h * Math.pow(2, 1 - p)) * u >= 2 && (s++, u /= 2), s + p >= l ? (a = 0, s = l) : s + p >= 1 ? (a = (t * u - 1) * Math.pow(2, i), s += p) : (a = t * Math.pow(2, p - 1) * Math.pow(2, i), s = 0)); i >= 8; e[n + f] = 255 & a, f += d, a /= 256, i -= 8);for (s = s << i | a, c += i; c > 0; e[n + f] = 255 & s, f += d, s /= 256, c -= 8);e[n + f - d] |= 128 * m; }; }, {}],
  22: [function (e, t, n) { function r(e) { return !!e.constructor && typeof e.constructor.isBuffer === 'function' && e.constructor.isBuffer(e); } function i(e) { return typeof e.readFloatLE === 'function' && typeof e.slice === 'function' && r(e.slice(0, 0)); }t.exports = function (e) { return e != null && (r(e) || i(e) || !!e._isBuffer); }; }, {}],
  23: [function (e, t, n) { arguments[4][16][0].apply(n, arguments); }, { acorn: 2, dup: 16, 'object-assign': 28 }],
  24: [function (e, t, n) { t.exports = function (e) { return !!e && (typeof e === 'object' || typeof e === 'function') && typeof e.then === 'function'; }; }, {}],
  25: [function (e, t, n) {
    const r = e('has'); const i = RegExp.prototype.exec; const o = Object.getOwnPropertyDescriptor; const s = function (e) { try { var t = e.lastIndex; return e.lastIndex = 0, i.call(e), !0; } catch (e) { return !1; } finally { e.lastIndex = t; } }; const a = Object.prototype.toString; const u = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol'; t.exports = function (e) { if (!e || typeof e !== 'object') return !1; if (!u) return a.call(e) === '[object RegExp]'; const t = o(e, 'lastIndex'); return !(!t || !r(t, 'value')) && s(e); };
  }, { has: 20 }],
  26: [function (e, t, n) {
    function r(e) {
      return e instanceof Date ? `new Date(${r(e.toISOString())})` : void 0 === e ? 'undefined' : JSON.stringify(e).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029').replace(/</g, '\\u003C')
        .replace(/>/g, '\\u003E')
        .replace(/\//g, '\\u002F');
    }t.exports = r;
  }, {}],
  27: [function (e, t, n) {
    function r(e) { o(e, 'Transformer must be an object'), o(typeof e.name === 'string', 'Transformer must have a name'), o(typeof e.outputFormat === 'string', 'Transformer must have an output format'), o(['compile', 'compileAsync', 'compileFile', 'compileFileAsync', 'compileClient', 'compileClientAsync', 'compileFileClient', 'compileFileClientAsync', 'render', 'renderAsync', 'renderFile', 'renderFileAsync'].some(t => typeof e[t] === 'function'), 'Transformer must implement at least one of the potential methods.'), this._tr = e, this.name = this._tr.name, this.outputFormat = this._tr.outputFormat, this.inputFormats = this._tr.inputFormats || [this.name]; } const i = e('fs'); var o = e('assert'); const s = e('promise'); const a = e('is-promise'); const u = t.exports = function (e) { return new r(e); }; u.Transformer = r, u.normalizeFn = function (e) { if (typeof e === 'function') return { fn: e, dependencies: [] }; if (e && typeof e === 'object' && typeof e.fn === 'function') { if ('dependencies' in e) { if (!Array.isArray(e.dependencies)) throw new Error('Result should have a dependencies property that is an array'); } else e.dependencies = []; return e; } throw new Error('Invalid result object from transform.'); }, u.normalizeFnAsync = function (e, t) { return s.resolve(e).then(e => (e && a(e.fn) ? e.fn.then(t => e.fn = t, e) : e)).then(u.normalizeFn).nodeify(t); }, u.normalize = function (e) { if (typeof e === 'string') return { body: e, dependencies: [] }; if (e && typeof e === 'object' && typeof e.body === 'string') { if ('dependencies' in e) { if (!Array.isArray(e.dependencies)) throw new Error('Result should have a dependencies property that is an array'); } else e.dependencies = []; return e; } throw new Error('Invalid result object from transform.'); }, u.normalizeAsync = function (e, t) { return s.resolve(e).then(e => (e && a(e.body) ? e.body.then(t => e.body = t, e) : e)).then(u.normalize).nodeify(t); }, i.readFile ? (u.readFile = s.denodeify(i.readFile), u.readFileSync = i.readFileSync) : (u.readFile = function () { throw new Error('fs.readFile unsupported'); }, u.readFileSync = function () { throw new Error('fs.readFileSync unsupported'); }); const c = {
      compile: ['compile', 'render'], compileAsync: ['compileAsync', 'compile', 'render'], compileFile: ['compileFile', 'compile', 'renderFile', 'render'], compileFileAsync: ['compileFileAsync', 'compileFile', 'compileAsync', 'compile', 'renderFile', 'render'], compileClient: ['compileClient'], compileClientAsync: ['compileClientAsync', 'compileClient'], compileFileClient: ['compileFileClient', 'compileClient'], compileFileClientAsync: ['compileFileClientAsync', 'compileFileClient', 'compileClientAsync', 'compileClient'], render: ['render', 'compile'], renderAsync: ['renderAsync', 'render', 'compileAsync', 'compile'], renderFile: ['renderFile', 'render', 'compileFile', 'compile'], renderFileAsync: ['renderFileAsync', 'renderFile', 'renderAsync', 'render', 'compileFileAsync', 'compileFile', 'compileAsync', 'compile'],
    }; r.prototype._hasMethod = function (e) { return typeof this._tr[e] === 'function'; }, r.prototype.can = function (e) { return c[e].some(e => this._hasMethod(e)); }, r.prototype.compile = function (e, t) { if (!this._hasMethod('compile')) { if (this.can('render')) { const n = this; return { fn(r) { return u.normalize(n._tr.render(e, t, r)).body; }, dependencies: [] }; } throw this.can('compileAsync') ? new Error(`The Transform "${this.name}" does not support synchronous compilation`) : this.can('compileFileAsync') ? new Error(`The Transform "${this.name}" does not support compiling plain strings`) : new Error(`The Transform "${this.name}" does not support compilation`); } return u.normalizeFn(this._tr.compile(e, t)); }, r.prototype.compileAsync = function (e, t, n) { return this.can('compileAsync') ? this._hasMethod('compileAsync') ? u.normalizeFnAsync(this._tr.compileAsync(e, t), n) : u.normalizeFnAsync(this.compile(e, t), n) : s.reject(new Error(`The Transform "${this.name}" does not support compiling plain strings`)).nodeify(n); }, r.prototype.compileFile = function (e, t) { if (!this.can('compileFile')) throw new Error(`The Transform "${this.name}" does not support synchronous compilation`); return this._hasMethod('compileFile') ? u.normalizeFn(this._tr.compileFile(e, t)) : this._hasMethod('renderFile') ? u.normalizeFn(n => u.normalize(this._tr.renderFile(e, t, n)).body) : (t || (t = {}), void 0 === t.filename && (t.filename = e), this.compile(u.readFileSync(e, 'utf8'), t)); }, r.prototype.compileFileAsync = function (e, t, n) { return this.can('compileFileAsync') ? this._hasMethod('compileFileAsync') ? u.normalizeFnAsync(this._tr.compileFileAsync(e, t), n) : this._hasMethod('compileFile') || this._hasMethod('renderFile') ? u.normalizeFnAsync(this.compileFile(e, t), n) : (t || (t = {}), void 0 === t.filename && (t.filename = e), u.normalizeFnAsync(u.readFile(e, 'utf8').then(e => (this._hasMethod('compileAsync') ? this._tr.compileAsync(e, t) : this.compile(e, t))), n)) : s.reject(new Error(`The Transform "${this.name}" does not support compilation`)); }, r.prototype.compileClient = function (e, t) { if (!this.can('compileClient')) throw this.can('compileClientAsync') ? new Error(`The Transform "${this.name}" does not support compiling for the client synchronously.`) : this.can('compileFileClientAsync') ? new Error(`The Transform "${this.name}" does not support compiling for the client from a string.`) : new Error(`The Transform "${this.name}" does not support compiling for the client`); return u.normalize(this._tr.compileClient(e, t)); }, r.prototype.compileClientAsync = function (e, t, n) { return this.can('compileClientAsync') ? this._hasMethod('compileClientAsync') ? u.normalizeAsync(this._tr.compileClientAsync(e, t), n) : u.normalizeAsync(this._tr.compileClient(e, t), n) : this.can('compileFileClientAsync') ? s.reject(new Error(`The Transform "${this.name}" does not support compiling for the client from a string.`)).nodeify(n) : s.reject(new Error(`The Transform "${this.name}" does not support compiling for the client`)).nodeify(n); }, r.prototype.compileFileClient = function (e, t) { if (!this.can('compileFileClient')) throw this.can('compileFileClientAsync') ? new Error(`The Transform "${this.name}" does not support compiling for the client synchronously.`) : new Error(`The Transform "${this.name}" does not support compiling for the client`); return this._hasMethod('compileFileClient') ? u.normalize(this._tr.compileFileClient(e, t)) : (t || (t = {}), void 0 === t.filename && (t.filename = e), u.normalize(this._tr.compileClient(u.readFileSync(e, 'utf8'), t))); }, r.prototype.compileFileClientAsync = function (e, t, n) { return this.can('compileFileClientAsync') ? this._hasMethod('compileFileClientAsync') ? u.normalizeAsync(this._tr.compileFileClientAsync(e, t), n) : this._hasMethod('compileFileClient') ? u.normalizeAsync(this._tr.compileFileClient(e, t), n) : (t || (t = {}), void 0 === t.filename && (t.filename = e), u.normalizeAsync(u.readFile(e, 'utf8').then(e => (this._hasMethod('compileClientAsync') ? this._tr.compileClientAsync(e, t) : this._tr.compileClient(e, t))), n)) : s.reject(new Error(`The Transform "${this.name}" does not support compiling for the client`)).nodeify(n); }, r.prototype.render = function (e, t, n) { if (!this.can('render')) throw this.can('renderAsync') ? new Error(`The Transform "${this.name}" does not support rendering synchronously.`) : this.can('renderFileAsync') ? new Error(`The Transform "${this.name}" does not support rendering from a string.`) : new Error(`The Transform "${this.name}" does not support rendering`); if (this._hasMethod('render')) return u.normalize(this._tr.render(e, t, n)); const r = u.normalizeFn(this._tr.compile(e, t)); const i = r.fn(n || t); if (typeof i !== 'string') throw new Error(`The Transform "${this.name}" does not support rendering synchronously.`); return u.normalize({ body: i, dependencies: r.dependencies }); }, r.prototype.renderAsync = function (e, t, n, r) { return typeof n === 'function' && (r = n, n = t), this.can('renderAsync') ? this._hasMethod('renderAsync') ? u.normalizeAsync(this._tr.renderAsync(e, t, n), r) : this._hasMethod('render') ? u.normalizeAsync(this._tr.render(e, t, n), r) : u.normalizeAsync(this.compileAsync(e, t).then(e => ({ body: e.fn(n || t), dependencies: e.dependencies })), r) : this.can('renderFileAsync') ? s.reject(new Error(`The Transform "${this.name}" does not support rendering from a string.`)).nodeify(r) : s.reject(new Error(`The Transform "${this.name}" does not support rendering`)).nodeify(r); }, r.prototype.renderFile = function (e, t, n) { if (!this.can('renderFile')) throw new Error(`The Transform "${this.name}" does not support rendering synchronously.`); if (this._hasMethod('renderFile')) return u.normalize(this._tr.renderFile(e, t, n)); if (this._hasMethod('render')) return t || (t = {}), void 0 === t.filename && (t.filename = e), u.normalize(this._tr.render(u.readFileSync(e, 'utf8'), t, n)); const r = this.compileFile(e, t); return u.normalize({ body: r.fn(n || t), dependencies: r.dependencies }); }, r.prototype.renderFileAsync = function (e, t, n, r) { if (!this.can('renderFileAsync')) throw new Error(`The Transform "${this.name}" does not support rendering.`); return typeof n === 'function' && (r = n, n = t), this._hasMethod('renderFileAsync') ? u.normalizeAsync(this._tr.renderFileAsync(e, t, n), r) : this._hasMethod('renderFile') ? u.normalizeAsync(this._tr.renderFile(e, t, n), r) : this._hasMethod('compile') || this._hasMethod('compileAsync') || this._hasMethod('compileFile') || this._hasMethod('compileFileAsync') ? u.normalizeAsync(this.compileFileAsync(e, t).then(e => ({ body: e.fn(n || t), dependencies: e.dependencies })), r) : (t || (t = {}), void 0 === t.filename && (t.filename = e), u.normalizeAsync(u.readFile(e, 'utf8').then(e => this.renderAsync(e, t, n)), r)); };
  }, {
    assert: 7, fs: 10, 'is-promise': 24, promise: 32,
  }],
  28: [function (e, t, n) {
    function r(e) { if (e === null || void 0 === e) throw new TypeError('Object.assign cannot be called with null or undefined'); return Object(e); } const i = Object.getOwnPropertySymbols; const o = Object.prototype.hasOwnProperty; const s = Object.prototype.propertyIsEnumerable; t.exports = (function () { try { if (!Object.assign) return !1; const e = new String('abc'); if (e[5] = 'de', Object.getOwnPropertyNames(e)[0] === '5') return !1; for (var t = {}, n = 0; n < 10; n++)t[`_${String.fromCharCode(n)}`] = n; if (Object.getOwnPropertyNames(t).map(e => t[e]).join('') !== '0123456789') return !1; const r = {}; return 'abcdefghijklmnopqrst'.split('').forEach((e) => { r[e] = e; }), Object.keys(Object.assign({}, r)).join('') === 'abcdefghijklmnopqrst'; } catch (e) { return !1; } }()) ? Object.assign : function (e, t) { for (var n, a, u = r(e), c = 1; c < arguments.length; c++) { n = Object(arguments[c]); for (const l in n)o.call(n, l) && (u[l] = n[l]); if (i) { a = i(n); for (let p = 0; p < a.length; p++)s.call(n, a[p]) && (u[a[p]] = n[a[p]]); } } return u; };
  }, {}],
  29: [function (e, t, n) { n.endianness = function () { return 'LE'; }, n.hostname = function () { return typeof location !== 'undefined' ? location.hostname : ''; }, n.loadavg = function () { return []; }, n.uptime = function () { return 0; }, n.freemem = function () { return Number.MAX_VALUE; }, n.totalmem = function () { return Number.MAX_VALUE; }, n.cpus = function () { return []; }, n.type = function () { return 'Browser'; }, n.release = function () { return typeof navigator !== 'undefined' ? navigator.appVersion : ''; }, n.networkInterfaces = n.getNetworkInterfaces = function () { return {}; }, n.arch = function () { return 'javascript'; }, n.platform = function () { return 'browser'; }, n.tmpdir = n.tmpDir = function () { return '/tmp'; }, n.EOL = '\n', n.homedir = function () { return '/'; }; }, {}],
  30: [function (e, t, n) { (function (e) { function t(e, t) { for (var n = 0, r = e.length - 1; r >= 0; r--) { const i = e[r]; i === '.' ? e.splice(r, 1) : i === '..' ? (e.splice(r, 1), n++) : n && (e.splice(r, 1), n--); } if (t) for (;n--; n)e.unshift('..'); return e; } function r(e, t) { if (e.filter) return e.filter(t); for (var n = [], r = 0; r < e.length; r++)t(e[r], r, e) && n.push(e[r]); return n; } const i = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; const o = function (e) { return i.exec(e).slice(1); }; n.resolve = function () { for (var n = '', i = !1, o = arguments.length - 1; o >= -1 && !i; o--) { const s = o >= 0 ? arguments[o] : e.cwd(); if (typeof s !== 'string') throw new TypeError('Arguments to path.resolve must be strings'); s && (n = `${s}/${n}`, i = s.charAt(0) === '/'); } return n = t(r(n.split('/'), e => !!e), !i).join('/'), (i ? '/' : '') + n || '.'; }, n.normalize = function (e) { const i = n.isAbsolute(e); const o = s(e, -1) === '/'; return (e = t(r(e.split('/'), e => !!e), !i).join('/')) || i || (e = '.'), e && o && (e += '/'), (i ? '/' : '') + e; }, n.isAbsolute = function (e) { return e.charAt(0) === '/'; }, n.join = function () { const e = Array.prototype.slice.call(arguments, 0); return n.normalize(r(e, (e, t) => { if (typeof e !== 'string') throw new TypeError('Arguments to path.join must be strings'); return e; }).join('/')); }, n.relative = function (e, t) { function r(e) { for (var t = 0; t < e.length && e[t] === ''; t++);for (var n = e.length - 1; n >= 0 && e[n] === ''; n--);return t > n ? [] : e.slice(t, n - t + 1); }e = n.resolve(e).substr(1), t = n.resolve(t).substr(1); for (var i = r(e.split('/')), o = r(t.split('/')), s = Math.min(i.length, o.length), a = s, u = 0; u < s; u++) if (i[u] !== o[u]) { a = u; break; } for (var c = [], u = a; u < i.length; u++)c.push('..'); return (c = c.concat(o.slice(a))).join('/'); }, n.sep = '/', n.delimiter = ':', n.dirname = function (e) { const t = o(e); const n = t[0]; let r = t[1]; return n || r ? (r && (r = r.substr(0, r.length - 1)), n + r) : '.'; }, n.basename = function (e, t) { let n = o(e)[2]; return t && n.substr(-1 * t.length) === t && (n = n.substr(0, n.length - t.length)), n; }, n.extname = function (e) { return o(e)[3]; }; var s = 'ab'.substr(-1) === 'b' ? function (e, t, n) { return e.substr(t, n); } : function (e, t, n) { return t < 0 && (t = e.length + t), e.substr(t, n); }; }).call(this, e('_process')); }, { _process: 31 }],
  31: [function (e, t, n) { function r() { throw new Error('setTimeout has not been defined'); } function i() { throw new Error('clearTimeout has not been defined'); } function o(e) { if (p === setTimeout) return setTimeout(e, 0); if ((p === r || !p) && setTimeout) return p = setTimeout, setTimeout(e, 0); try { return p(e, 0); } catch (t) { try { return p.call(null, e, 0); } catch (t) { return p.call(this, e, 0); } } } function s(e) { if (h === clearTimeout) return clearTimeout(e); if ((h === i || !h) && clearTimeout) return h = clearTimeout, clearTimeout(e); try { return h(e); } catch (t) { try { return h.call(null, e); } catch (t) { return h.call(this, e); } } } function a() { g && d && (g = !1, d.length ? m = d.concat(m) : v = -1, m.length && u()); } function u() { if (!g) { const e = o(a); g = !0; for (let t = m.length; t;) { for (d = m, m = []; ++v < t;)d && d[v].run(); v = -1, t = m.length; }d = null, g = !1, s(e); } } function c(e, t) { this.fun = e, this.array = t; } function l() {} let p; let h; const f = t.exports = {}; !(function () { try { p = typeof setTimeout === 'function' ? setTimeout : r; } catch (e) { p = r; } try { h = typeof clearTimeout === 'function' ? clearTimeout : i; } catch (e) { h = i; } }()); let d; var m = []; var g = !1; var v = -1; f.nextTick = function (e) { const t = new Array(arguments.length - 1); if (arguments.length > 1) for (let n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; m.push(new c(e, t)), m.length !== 1 || g || o(u); }, c.prototype.run = function () { this.fun.apply(null, this.array); }, f.title = 'browser', f.browser = !0, f.env = {}, f.argv = [], f.version = '', f.versions = {}, f.on = l, f.addListener = l, f.once = l, f.off = l, f.removeListener = l, f.removeAllListeners = l, f.emit = l, f.prependListener = l, f.prependOnceListener = l, f.listeners = function (e) { return []; }, f.binding = function (e) { throw new Error('process.binding is not supported'); }, f.cwd = function () { return '/'; }, f.chdir = function (e) { throw new Error('process.chdir is not supported'); }, f.umask = function () { return 0; }; }, {}],
  32: [function (e, t, n) {
    t.exports = e('./lib');
  }, { './lib': 37 }],
  33: [function (e, t, n) {
    function r() {} function i(e) { try { return e.then; } catch (e) { return v = e, y; } } function o(e, t) { try { return e(t); } catch (e) { return v = e, y; } } function s(e, t, n) { try { e(t, n); } catch (e) { return v = e, y; } } function a(e) { if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new'); if (typeof e !== 'function') throw new TypeError("Promise constructor's argument is not a function"); this._40 = 0, this._65 = 0, this._55 = null, this._72 = null, e !== r && m(e, this); } function u(e, t, n) { return new e.constructor(((i, o) => { const s = new a(r); s.then(i, o), c(e, new d(t, n, s)); })); } function c(e, t) { for (;e._65 === 3;)e = e._55; if (a._37 && a._37(e), e._65 === 0) return e._40 === 0 ? (e._40 = 1, void (e._72 = t)) : e._40 === 1 ? (e._40 = 2, void (e._72 = [e._72, t])) : void e._72.push(t); l(e, t); } function l(e, t) { g(() => { const n = e._65 === 1 ? t.onFulfilled : t.onRejected; if (n !== null) { const r = o(n, e._55); r === y ? h(t.promise, v) : p(t.promise, r); } else e._65 === 1 ? p(t.promise, e._55) : h(t.promise, e._55); }); } function p(e, t) { if (t === e) return h(e, new TypeError('A promise cannot be resolved with itself.')); if (t && (typeof t === 'object' || typeof t === 'function')) { const n = i(t); if (n === y) return h(e, v); if (n === e.then && t instanceof a) return e._65 = 3, e._55 = t, void f(e); if (typeof n === 'function') return void m(n.bind(t), e); }e._65 = 1, e._55 = t, f(e); } function h(e, t) { e._65 = 2, e._55 = t, a._87 && a._87(e, t), f(e); } function f(e) { if (e._40 === 1 && (c(e, e._72), e._72 = null), e._40 === 2) { for (let t = 0; t < e._72.length; t++)c(e, e._72[t]); e._72 = null; } } function d(e, t, n) { this.onFulfilled = typeof e === 'function' ? e : null, this.onRejected = typeof t === 'function' ? t : null, this.promise = n; } function m(e, t) { let n = !1; const r = s(e, (e) => { n || (n = !0, p(t, e)); }, (e) => { n || (n = !0, h(t, e)); }); n || r !== y || (n = !0, h(t, v)); } var g = e('asap/raw'); var v = null; var y = {}; t.exports = a, a._37 = null, a._87 = null, a._61 = r, a.prototype.then = function (e, t) { if (this.constructor !== a) return u(this, e, t); const n = new a(r); return c(this, new d(e, t, n)), n; };
  }, { 'asap/raw': 6 }],
  34: [function (e, t, n) {
    const r = e('./core.js'); t.exports = r, r.prototype.done = function (e, t) { (arguments.length ? this.then.apply(this, arguments) : this).then(null, (e) => { setTimeout(() => { throw e; }, 0); }); };
  }, { './core.js': 33 }],
  35: [function (e, t, n) {
    function r(e) { const t = new i(i._61); return t._65 = 1, t._55 = e, t; } var i = e('./core.js'); t.exports = i; const o = r(!0); const s = r(!1); const a = r(null); const u = r(void 0); const c = r(0); const l = r(''); i.resolve = function (e) { if (e instanceof i) return e; if (e === null) return a; if (void 0 === e) return u; if (!0 === e) return o; if (!1 === e) return s; if (e === 0) return c; if (e === '') return l; if (typeof e === 'object' || typeof e === 'function') try { const t = e.then; if (typeof t === 'function') return new i(t.bind(e)); } catch (e) { return new i(((t, n) => { n(e); })); } return r(e); }, i.all = function (e) { const t = Array.prototype.slice.call(e); return new i(((e, n) => { function r(s, a) { if (a && (typeof a === 'object' || typeof a === 'function')) { if (a instanceof i && a.then === i.prototype.then) { for (;a._65 === 3;)a = a._55; return a._65 === 1 ? r(s, a._55) : (a._65 === 2 && n(a._55), void a.then((e) => { r(s, e); }, n)); } const u = a.then; if (typeof u === 'function') return void new i(u.bind(a)).then((e) => { r(s, e); }, n); }t[s] = a, --o == 0 && e(t); } if (t.length === 0) return e([]); for (var o = t.length, s = 0; s < t.length; s++)r(s, t[s]); })); }, i.reject = function (e) { return new i(((t, n) => { n(e); })); }, i.race = function (e) { return new i(((t, n) => { e.forEach((e) => { i.resolve(e).then(t, n); }); })); }, i.prototype.catch = function (e) { return this.then(null, e); };
  }, { './core.js': 33 }],
  36: [function (e, t, n) {
    const r = e('./core.js'); t.exports = r, r.prototype.finally = function (e) { return this.then(t => r.resolve(e()).then(() => t), t => r.resolve(e()).then(() => { throw t; })); };
  }, { './core.js': 33 }],
  37: [function (e, t, n) {
    t.exports = e('./core.js'), e('./done.js'), e('./finally.js'), e('./es6-extensions.js'), e('./node-extensions.js'), e('./synchronous.js');
  }, {
    './core.js': 33, './done.js': 34, './es6-extensions.js': 35, './finally.js': 36, './node-extensions.js': 38, './synchronous.js': 39,
  }],
  38: [function (e, t, n) {
    function r(e, t) { for (var n = [], r = 0; r < t; r++)n.push(`a${r}`); const i = [`return function (${n.join(',')}) {`, 'var self = this;', 'return new Promise(function (rs, rj) {', 'var res = fn.call(', ['self'].concat(n).concat([a]).join(','), ');', 'if (res &&', '(typeof res === "object" || typeof res === "function") &&', 'typeof res.then === "function"', ') {rs(res);}', '});', '};'].join(''); return Function(['Promise', 'fn'], i)(o, e); } function i(e) { for (var t = Math.max(e.length - 1, 3), n = [], r = 0; r < t; r++)n.push(`a${r}`); const i = [`return function (${n.join(',')}) {`, 'var self = this;', 'var args;', 'var argLength = arguments.length;', `if (arguments.length > ${t}) {`, 'args = new Array(arguments.length + 1);', 'for (var i = 0; i < arguments.length; i++) {', 'args[i] = arguments[i];', '}', '}', 'return new Promise(function (rs, rj) {', `var cb = ${a};`, 'var res;', 'switch (argLength) {', n.concat(['extra']).map((e, t) => `case ${t}:res = fn.call(${['self'].concat(n.slice(0, t)).concat('cb').join(',')});break;`).join(''), 'default:', 'args[argLength] = cb;', 'res = fn.apply(self, args);', '}', 'if (res &&', '(typeof res === "object" || typeof res === "function") &&', 'typeof res.then === "function"', ') {rs(res);}', '});', '};'].join(''); return Function(['Promise', 'fn'], i)(o, e); } var o = e('./core.js'); const s = e('asap'); t.exports = o, o.denodeify = function (e, t) { return typeof t === 'number' && t !== 1 / 0 ? r(e, t) : i(e); }; var a = 'function (err, res) {if (err) { rj(err); } else { rs(res); }}'; o.nodeify = function (e) { return function () { const t = Array.prototype.slice.call(arguments); const n = typeof t[t.length - 1] === 'function' ? t.pop() : null; const r = this; try { return e.apply(this, arguments).nodeify(n, r); } catch (e) { if (n === null || void 0 === n) return new o(((t, n) => { n(e); })); s(() => { n.call(r, e); }); } }; }, o.prototype.nodeify = function (e, t) { if (typeof e !== 'function') return this; this.then((n) => { s(() => { e.call(t, null, n); }); }, (n) => { s(() => { e.call(t, n); }); }); };
  }, { './core.js': 33, asap: 5 }],
  39: [function (e, t, n) {
    const r = e('./core.js'); t.exports = r, r.enableSynchronous = function () { r.prototype.isPending = function () { return this.getState() == 0; }, r.prototype.isFulfilled = function () { return this.getState() == 1; }, r.prototype.isRejected = function () { return this.getState() == 2; }, r.prototype.getValue = function () { if (this._65 === 3) return this._55.getValue(); if (!this.isFulfilled()) throw new Error('Cannot get a value of an unfulfilled promise.'); return this._55; }, r.prototype.getReason = function () { if (this._65 === 3) return this._55.getReason(); if (!this.isRejected()) throw new Error('Cannot get a rejection reason of a non-rejected promise.'); return this._55; }, r.prototype.getState = function () { return this._65 === 3 ? this._55.getState() : this._65 === -1 || this._65 === -2 ? 0 : this._65; }; }, r.disableSynchronous = function () { r.prototype.isPending = void 0, r.prototype.isFulfilled = void 0, r.prototype.isRejected = void 0, r.prototype.getValue = void 0, r.prototype.getReason = void 0, r.prototype.getState = void 0; };
  }, { './core.js': 33 }],
  40: [function (e, t, n) {
    function r(e) { return s(e, { pug: a, pug_interp: void 0 }); } function i(e) { return s.toConstant(e, { pug: a, pug_interp: void 0 }); } const o = e('assert'); var s = e('constantinople'); var a = e('pug-runtime'); const u = e('js-stringify'); t.exports = function (e, t) { function n(e, n, o, s) { if (r(n)) if (t.format === 'html') { const c = u(a.attr(e, i(n), o, t.terse)); const l = s[s.length - 1]; l && l[l.length - 1] === c[0] ? s[s.length - 1] = l.substr(0, l.length - 1) + c.substr(1) : s.push(c); } else n = i(n), o && (n = a.escape(n)), s.push(`${u(e)}: ${u(n)}`); else t.format === 'html' ? s.push(`${t.runtime('attr')}("${e}", ${n}, ${u(o)}, ${u(t.terse)})`) : (o && (n = `${t.runtime('escape')}(${n})`), s.push(`${u(e)}: ${n}`)); }o(Array.isArray(e), 'Attrs should be an array'), o(e.every(e => e && typeof e === 'object' && typeof e.name === 'string' && (typeof e.val === 'string' || typeof e.val === 'boolean') && typeof e.mustEscape === 'boolean'), 'All attributes should be supplied as an object of the form {name, val, mustEscape}'), o(t && typeof t === 'object', 'Options should be an object'), o(typeof t.terse === 'boolean', 'Options.terse should be a boolean'), o(typeof t.runtime === 'function', 'Options.runtime should be a function that takes a runtime function name and returns the source code that will evaluate to that function at runtime'), o(t.format === 'html' || t.format === 'object', 'Options.format should be "html" or "object"'); let s = []; let c = []; const l = []; e.forEach((e) => { const o = e.name; let p = e.val; const h = e.mustEscape; o === 'class' ? (c.push(p), l.push(h)) : (o === 'style' && (p = r(p) ? u(a.style(i(p))) : `${t.runtime('style')}(${p})`), n(o, p, h, s)); }); const p = []; return c.length && (c.every(r) ? n('class', u(a.classes(c.map(i), l)), !1, p) : (c = c.map((e, t) => r(e) && (e = u(l[t] ? a.escape(i(e)) : i(e)), l[t] = !1), e), n('class', `${t.runtime('classes')}([${c.join(',')}], ${u(l)})`, !1, p))), s = p.concat(s), t.format === 'html' ? s.length ? s.join('+') : '""' : `{${s.join(',')}}`; };
  }, {
    assert: 7, constantinople: 13, 'js-stringify': 26, 'pug-runtime': 123,
  }],
  41: [function (e, t, n) {
    function r(e) { return f(e, { pug: l, pug_interp: void 0 }); } function i(e) { return f.toConstant(e, { pug: l, pug_interp: void 0 }); } function o(e, t) { this.options = t = t || {}, this.node = e, this.bufferedConcatenationCount = 0, this.hasCompiledDoctype = !1, this.hasCompiledTag = !1, this.pp = t.pretty || !1, this.pp && typeof this.pp !== 'string' && (this.pp = '  '), this.debug = !1 !== t.compileDebug, this.indents = 0, this.parentIndents = 0, this.terse = !1, this.mixins = {}, this.dynamicMixins = !1, this.eachCount = 0, t.doctype && this.setDoctype(t.doctype), this.runtimeFunctionsUsed = [], this.inlineRuntimeFunctions = t.inlineRuntimeFunctions || !1, this.debug && this.inlineRuntimeFunctions && this.runtimeFunctionsUsed.push('rethrow'); } function s(e) { function t(e) { return e.type === 'Block' ? e.nodes.every(t) : e.type === 'YieldBlock' || (e.type === 'Text' && !/\n/.test(e.val) || e.isInline); } return e.block.nodes.every(t); } const a = e('doctypes'); const u = e('pug-error'); const c = e('pug-runtime/build'); var l = e('pug-runtime'); const p = e('pug-attrs'); const h = e('void-elements'); var f = e('constantinople'); const d = e('js-stringify'); const m = e('with'); const g = { pre: !0, textarea: !0 }; const v = ['pug', 'pug_mixins', 'pug_interp', 'pug_debug_filename', 'pug_debug_line', 'pug_debug_sources', 'pug_html']; t.exports = function (e, t) { return new o(e, t).compile(); }, t.exports.CodeGenerator = o, o.prototype = {
      runtime(e) { return this.inlineRuntimeFunctions ? (this.runtimeFunctionsUsed.push(e), `pug_${e}`) : `pug.${e}`; }, error(e, t, n) { throw u(t, e, { line: n.line, column: n.column, filename: n.filename }); }, compile() { if (this.buf = [], this.pp && this.buf.push('var pug_indent = [];'), this.lastBufferedIdx = -1, this.visit(this.node), !this.dynamicMixins) for (let e = Object.keys(this.mixins), t = 0; t < e.length; t++) { const n = this.mixins[e[t]]; if (!n.used) for (let r = 0; r < n.instances.length; r++) for (let i = n.instances[r].start; i < n.instances[r].end; i++) this.buf[i] = ''; } let o = this.buf.join('\n'); const s = this.options.globals ? this.options.globals.concat(v) : v; return o = this.options.self ? `var self = locals || {};${o}` : m('locals || {}', o, s.concat(this.runtimeFunctionsUsed.map(e => `pug_${e}`))), this.debug && (this.options.includeSources && (o = `var pug_debug_sources = ${d(this.options.includeSources)};\n${o}`), o = `var pug_debug_filename, pug_debug_line;try {${o}} catch (err) {${this.inlineRuntimeFunctions ? 'pug_rethrow' : 'pug.rethrow'}(err, pug_debug_filename, pug_debug_line${this.options.includeSources ? ', pug_debug_sources[pug_debug_filename]' : ''});}`), `${c(this.runtimeFunctionsUsed)}function ${this.options.templateName || 'template'}(locals) {var pug_html = "", pug_mixins = {}, pug_interp;${o};return pug_html;}`; }, setDoctype(e) { this.doctype = a[e.toLowerCase()] || `<!DOCTYPE ${e}>`, this.terse = this.doctype.toLowerCase() == '<!doctype html>', this.xml = this.doctype.indexOf('<?xml') == 0; }, buffer(e) { e = (e = d(e)).substr(1, e.length - 2), this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100 ? (this.lastBufferedType === 'code' && (this.lastBuffered += ' + "', this.bufferedConcatenationCount++), this.lastBufferedType = 'text', this.lastBuffered += e, this.buf[this.lastBufferedIdx - 1] = `pug_html = pug_html + ${this.bufferStartChar}${this.lastBuffered}";`) : (this.bufferedConcatenationCount = 0, this.buf.push(`pug_html = pug_html + "${e}";`), this.lastBufferedType = 'text', this.bufferStartChar = '"', this.lastBuffered = e, this.lastBufferedIdx = this.buf.length); }, bufferExpression(e) { if (r(e)) return this.buffer(`${i(e)}`); this.lastBufferedIdx == this.buf.length && this.bufferedConcatenationCount < 100 ? (this.bufferedConcatenationCount++, this.lastBufferedType === 'text' && (this.lastBuffered += '"'), this.lastBufferedType = 'code', this.lastBuffered += ` + (${e})`, this.buf[this.lastBufferedIdx - 1] = `pug_html = pug_html + (${this.bufferStartChar}${this.lastBuffered});`) : (this.bufferedConcatenationCount = 0, this.buf.push(`pug_html = pug_html + (${e});`), this.lastBufferedType = 'code', this.bufferStartChar = '', this.lastBuffered = `(${e})`, this.lastBufferedIdx = this.buf.length); }, prettyIndent(e, t) { e = e || 0, t = t ? '\n' : '', this.buffer(t + Array(this.indents + e).join(this.pp)), this.parentIndents && this.buf.push('pug_html = pug_html + pug_indent.join("");'); }, visit(e, t) { const n = this.debug; if (!e) { throw i = t ? `A child of ${t.type} (${t.filename || 'Pug'}:${t.line})` : 'A top-level node', i += ` is ${e}, expected a Pug AST Node.`, new TypeError(i); } if (n && !1 !== e.debug && e.type !== 'Block' && e.line) { let r = `;pug_debug_line = ${e.line}`; e.filename && (r += `;pug_debug_filename = ${d(e.filename)}`), this.buf.push(`${r};`); } if (!this[`visit${e.type}`]) { var i; switch (i = t ? `A child of ${t.type}` : 'A top-level node', i += ` (${e.filename || 'Pug'}:${e.line}) is of type ${e.type}, which is not supported by pug-code-gen.`, e.type) { case 'Filter': i += ' Please use pug-filters to preprocess this AST.'; break; case 'Extends': case 'Include': case 'NamedBlock': case 'FileReference': i += ' Please use pug-linker to preprocess this AST.'; } throw new TypeError(i); } this.visitNode(e); }, visitNode(e) { return this[`visit${e.type}`](e); }, visitCase(e) { this.buf.push(`switch (${e.expr}){`), this.visit(e.block, e), this.buf.push('}'); }, visitWhen(e) { e.expr == 'default' ? this.buf.push('default:') : this.buf.push(`case ${e.expr}:`), e.block && (this.visit(e.block, e), this.buf.push('  break;')); }, visitLiteral(e) { this.buffer(e.str); }, visitNamedBlock(e) { return this.visitBlock(e); }, visitBlock(e) { const t = this.escapePrettyMode; const n = this.pp; n && e.nodes.length > 1 && !t && e.nodes[0].type === 'Text' && e.nodes[1].type === 'Text' && this.prettyIndent(1, !0); for (let r = 0; r < e.nodes.length; ++r)n && r > 0 && !t && e.nodes[r].type === 'Text' && e.nodes[r - 1].type === 'Text' && /\n$/.test(e.nodes[r - 1].val) && this.prettyIndent(1, !1), this.visit(e.nodes[r], e); }, visitMixinBlock(e) { this.pp && this.buf.push(`pug_indent.push('${Array(this.indents + 1).join(this.pp)}');`), this.buf.push('block && block();'), this.pp && this.buf.push('pug_indent.pop();'); }, visitDoctype(e) { !e || !e.val && this.doctype || this.setDoctype(e.val || 'html'), this.doctype && this.buffer(this.doctype), this.hasCompiledDoctype = !0; }, visitMixin(e) { let t = 'pug_mixins['; let n = e.args || ''; const r = e.block; const i = e.attrs; const o = this.attributeBlocks(e.attributeBlocks); const s = this.pp; const a = e.name[0] === '#'; const u = e.name; if (a && (this.dynamicMixins = !0), t += `${a ? e.name.substr(2, e.name.length - 3) : `"${e.name}"`}]`, this.mixins[u] = this.mixins[u] || { used: !1, instances: [] }, e.call) { if (this.mixins[u].used = !0, s && this.buf.push(`pug_indent.push('${Array(this.indents + 1).join(s)}');`), r || i.length || o.length) { if (this.buf.push(`${t}.call({`), r) { this.buf.push('block: function(){'), this.parentIndents++; const c = this.indents; this.indents = 0, this.visit(e.block, e), this.indents = c, this.parentIndents--, i.length || o.length ? this.buf.push('},') : this.buf.push('}'); } if (o.length) { if (i.length) { l = this.attrs(i); o.unshift(l); }o.length > 1 ? this.buf.push(`attributes: ${this.runtime('merge')}([${o.join(',')}])`) : this.buf.push(`attributes: ${o[0]}`); } else if (i.length) { var l = this.attrs(i); this.buf.push(`attributes: ${l}`); }n ? this.buf.push(`}, ${n});`) : this.buf.push('});'); } else this.buf.push(`${t}(${n});`); s && this.buf.push('pug_indent.pop();'); } else { let p; const h = this.buf.length; (n = n ? n.split(',') : []).length && /^\.\.\./.test(n[n.length - 1].trim()) && (p = n.pop().trim().replace(/^\.\.\./, '')), this.buf.push(`${t} = pug_interp = function(${n.join(',')}){`), this.buf.push('var block = (this && this.block), attributes = (this && this.attributes) || {};'), p && (this.buf.push(`var ${p} = [];`), this.buf.push(`for (pug_interp = ${n.length}; pug_interp < arguments.length; pug_interp++) {`), this.buf.push(`  ${p}.push(arguments[pug_interp]);`), this.buf.push('}')), this.parentIndents++, this.visit(r, e), this.parentIndents--, this.buf.push('};'); const f = this.buf.length; this.mixins[u].instances.push({ start: h, end: f }); } }, visitTag(e, t) { function n() { t ? o.bufferExpression(e.expr) : o.buffer(r); } this.indents++; var r = e.name; const i = this.pp; var o = this; !0 === g[e.name] && (this.escapePrettyMode = !0), this.hasCompiledTag || (this.hasCompiledDoctype || r != 'html' || this.visitDoctype(), this.hasCompiledTag = !0), i && !e.isInline && this.prettyIndent(0, !0), e.selfClosing || !this.xml && h[e.name] ? (this.buffer('<'), n(), this.visitAttributes(e.attrs, this.attributeBlocks(e.attributeBlocks)), this.terse && !e.selfClosing ? this.buffer('>') : this.buffer('/>'), (e.code || e.block && (e.block.type !== 'Block' || e.block.nodes.length !== 0) && e.block.nodes.some(e => e.type !== 'Text' || !/^\s*$/.test(e.val))) && this.error(`${r} is a self closing element: <${r}/> but contains nested content.`, 'SELF_CLOSING_CONTENT', e)) : (this.buffer('<'), n(), this.visitAttributes(e.attrs, this.attributeBlocks(e.attributeBlocks)), this.buffer('>'), e.code && this.visitCode(e.code), this.visit(e.block, e), !i || e.isInline || !0 === g[e.name] || s(e) || this.prettyIndent(0, !0), this.buffer('</'), n(), this.buffer('>')), !0 === g[e.name] && (this.escapePrettyMode = !1), this.indents--; }, visitInterpolatedTag(e) { return this.visitTag(e, !0); }, visitText(e) { this.buffer(e.val); }, visitComment(e) { e.buffer && (this.pp && this.prettyIndent(1, !0), this.buffer(`\x3c!--${e.val}--\x3e`)); }, visitYieldBlock(e) {}, visitBlockComment(e) { e.buffer && (this.pp && this.prettyIndent(1, !0), this.buffer(`\x3c!--${e.val || ''}`), this.visit(e.block, e), this.pp && this.prettyIndent(1, !0), this.buffer('--\x3e')); }, visitCode(e) { if (e.buffer) { let t = e.val.trim(); t = `null == (pug_interp = ${t}) ? "" : pug_interp`, !1 !== e.mustEscape && (t = `${this.runtime('escape')}(${t})`), this.bufferExpression(t); } else this.buf.push(e.val); e.block && (e.buffer || this.buf.push('{'), this.visit(e.block, e), e.buffer || this.buf.push('}')); }, visitConditional(e) { const t = e.test; this.buf.push(`if (${t}) {`), this.visit(e.consequent, e), this.buf.push('}'), e.alternate && (e.alternate.type === 'Conditional' ? (this.buf.push('else'), this.visitConditional(e.alternate)) : (this.buf.push('else {'), this.visit(e.alternate, e), this.buf.push('}'))); }, visitWhile(e) { const t = e.test; this.buf.push(`while (${t}) {`), this.visit(e.block, e), this.buf.push('}'); }, visitEach(e) { const t = e.key || `pug_index${this.eachCount}`; this.eachCount++, this.buf.push(`// iterate ${e.obj}\n;(function(){\n  var $$obj = ${e.obj};\n  if ('number' == typeof $$obj.length) {`), e.alternate && this.buf.push('    if ($$obj.length) {'), this.buf.push(`      for (var ${t} = 0, $$l = $$obj.length; ${t} < $$l; ${t}++) {\n        var ${e.val} = $$obj[${t}];`), this.visit(e.block, e), this.buf.push('      }'), e.alternate && (this.buf.push('    } else {'), this.visit(e.alternate, e), this.buf.push('    }')), this.buf.push(`  } else {\n    var $$l = 0;\n    for (var ${t} in $$obj) {\n      $$l++;\n      var ${e.val} = $$obj[${t}];`), this.visit(e.block, e), this.buf.push('    }'), e.alternate && (this.buf.push('    if ($$l === 0) {'), this.visit(e.alternate, e), this.buf.push('    }')), this.buf.push('  }\n}).call(this);\n'); }, visitAttributes(e, t) { if (t.length) { if (e.length) { const n = this.attrs(e); t.unshift(n); }t.length > 1 ? this.bufferExpression(`${this.runtime('attrs')}(${this.runtime('merge')}([${t.join(',')}]), ${d(this.terse)})`) : this.bufferExpression(`${this.runtime('attrs')}(${t[0]}, ${d(this.terse)})`); } else e.length && this.attrs(e, !0); }, attrs(e, t) { const n = p(e, { terse: this.terse, format: t ? 'html' : 'object', runtime: this.runtime.bind(this) }); return t && this.bufferExpression(n), n; }, attributeBlocks: e => e && e.slice().map(e => e.val),
    };
  }, {
    constantinople: 13, doctypes: 17, 'js-stringify': 26, 'pug-attrs': 40, 'pug-error': 42, 'pug-runtime': 123, 'pug-runtime/build': 122, 'void-elements': 153, with: 154,
  }],
  42: [function (e, t, n) {
    t.exports = function (e, t, n) {
      let r; const i = n.line; const o = n.column; const s = n.filename; const a = n.src; const u = i + (o ? `:${o}` : ''); if (a && i >= 1 && i <= a.split('\n').length) { const c = a.split('\n'); const l = Math.max(i - 3, 0); const p = Math.min(c.length, i + 3); const h = c.slice(l, p).map((e, t) => { const n = t + l + 1; const r = `${(n == i ? '  > ' : '    ') + n}| `; let s = r + e; return n === i && o > 0 && (s += '\n', s += `${Array(r.length + o).join('-')}^`), s; }).join('\n'); r = `${s || 'Pug'}:${u}\n${h}\n\n${t}`; } else r = `${s || 'Pug'}:${u}\n\n${t}`; const f = new Error(r); return f.code = `PUG:${e}`, f.msg = t, f.line = i, f.column = o, f.filename = s, f.src = a, f.toJSON = function () {
        return {
          code: this.code, msg: this.msg, line: this.line, column: this.column, filename: this.filename,
        };
      }, f;
    };
  }, {}],
  43: [function (e, t, n) {
    n.runFilter = e('./lib/run-filter'), n.handleFilters = e('./lib/handle-filters');
  }, { './lib/handle-filters': 44, './lib/run-filter': 45 }],
  44: [function (e, t, n) {
    function r(e, t, n, r) { function u(e) { let t = e.name; if (r && r[t] && (t = r[t], r[t])) throw l('FILTER_ALISE_CHAIN', `The filter "${e.name}" is an alias for "${t}", which is an alias for "${r[t]}".  Pug does not support chains of filter aliases.`, e); return t; } return n = n || {}, c(e, (e) => { function c(e, n, r, i) { try { const o = u(e); return t && t[o] ? t[o](n, r) : p(o, n, r, h, i); } catch (t) { if (t.code === 'UNKNOWN_FILTER') throw l(t.code, t.message, e); throw t; } } var h = e.filename ? a(e.filename) : null; if (e.type === 'Filter') { i(e, t, n, r); const f = o(e); (m = s(e, n)).filename = e.filename, e.type = 'Text', e.val = c(e, f, m); } else if (e.type === 'RawInclude' && e.filters.length) { const d = e.filters.shift(); var m = s(d, n); const g = m.filename = e.file.fullPath; const v = e.file.str; e.type = 'Text', e.val = (function (e, n, r, i) { const o = u(e); return t && t[o] ? t[o](r, i) : c(e, n, i, 'renderFile'); }(d, g, v, m)), e.filters.forEach((t) => { const r = s(t, n); r.filename = g, e.val = c(t, e.val, r); }), e.filters = void 0, e.file = void 0; } }, { includeDependencies: !0 }), e; } function i(e, t, n, i) { e.block.nodes[0] && e.block.nodes[0].type === 'Filter' && (e.block.nodes[0] = r(e.block, t, n, i).nodes[0]); } function o(e) { return e.block.nodes.map(e => e.val).join(''); } function s(e, t) { const n = {}; e.attrs.forEach((t) => { try { n[t.name] = u.toConstant(t.val); } catch (t) { if (/not constant/.test(t.message)) throw l('FILTER_OPTION_NOT_CONSTANT', `${t.message} All filters are rendered compile-time so filter options must be constants.`, e); throw t; } }); const r = t[e.name] || {}; return Object.keys(r).forEach((e) => { n.hasOwnProperty(e) || (n[e] = r[e]); }), n; } var a = e('path').dirname; var u = e('constantinople'); var c = e('pug-walk'); var l = e('pug-error'); var p = e('./run-filter'); t.exports = r;
  }, {
    './run-filter': 45, constantinople: 13, path: 30, 'pug-error': 42, 'pug-walk': 129,
  }],
  45: [function (e, t, n) {
    (function (n) {
      const r = e('jstransformer'); const i = e('uglify-js'); const o = e('clean-css'); const s = e('resolve'); t.exports = function (t, a, u, c, l) { l = l || 'render'; let p; try { try { p = e(s.sync(`jstransformer-${t}`, { basedir: c || n.cwd() })); } catch (n) { p = e(`jstransformer-${t}`); }p = r(p); } catch (e) {} if (p) { let h = p[l](a, u, u).body; if (u && u.minify) try { switch (p.outputFormat) { case 'js': h = i.minify(h, { fromString: !0 }).code; break; case 'css': h = (new o()).minify(h).styles; } } catch (e) {} return h; } const f = new Error(`unknown filter ":${t}"`); throw f.code = 'UNKNOWN_FILTER', f; };
    }).call(this, e('_process'));
  }, {
    _process: 31, 'clean-css': 46, jstransformer: 27, resolve: 10, 'uglify-js': 147,
  }],
  46: [function (e, t, n) { t.exports = e('./lib/clean'); }, { './lib/clean': 47 }],
  47: [function (e, t, n) {
    (function (n) {
      function r(e) { return void 0 === e ? ['all'] : e; } function i(e) { return !T.existsSync(e) && !/\.css$/.test(e); } function o(e) { return T.existsSync(e) && T.statSync(e).isDirectory(); } function s(e) { return e ? { hostname: F.parse(e).hostname, port: parseInt(F.parse(e).port) } : {}; } function a(e, t) { function n(n) { return n = t.options.debug ? c(t, n) : p(t, n), n = u(t, n), e ? e.call(null, t.errors.length > 0 ? t.errors : null, n) : n; } return function (e) { return t.options.sourceMap ? t.inputSourceMapTracker.track(e, () => (t.options.sourceMapInlineSources ? t.inputSourceMapTracker.resolveSources(() => n(e)) : n(e))) : n(e); }; } function u(e, t) { return t.stats = e.stats, t.errors = e.errors, t.warnings = e.warnings, t; } function c(e, t) { const r = n.hrtime(); e.stats.originalSize = e.sourceTracker.removeAll(t).length, t = p(e, t); const i = n.hrtime(r); return e.stats.timeSpent = ~~(1e3 * i[0] + i[1] / 1e6), e.stats.efficiency = 1 - t.styles.length / e.stats.originalSize, e.stats.minifiedSize = t.styles.length, t; } function l(e) { return function (t, r) { const i = `${t.constructor.name}#${r}`; const o = n.hrtime(); e(t, r); const s = n.hrtime(o); console.log(`%d ms: ${i}`, 1e3 * s[0] + s[1] / 1e6); }; } function p(e, t) { const n = e.options; const r = new b(e, n.keepSpecialComments, n.keepBreaks, n.sourceMap); const i = new _(n.sourceMap); const o = new x(n.sourceMap); const s = new w(e, n.sourceMap, n.compatibility.properties.urlQuotes); const a = n.sourceMap ? y : v; let u = function (e, n) { t = typeof e === 'function' ? e(t) : e[n](t); }; n.benchmark && (u = l(u)), u(r, 'escape'), u(i, 'escape'), u(s, 'escape'), u(o, 'escape'); const c = d(t, e); return m(c, n, e), n.advanced && g(c, n, e, !0), a(c, n, (t, a) => t = o.restore(t, a), t = s.restore(t), t = n.rebase ? f(t, e) : t, t = i.restore(t), r.restore(t), e.inputSourceMapTracker); } const h = e('./imports/inliner'); var f = e('./urls/rebase'); var d = e('./tokenizer/tokenize'); var m = e('./selectors/simple'); var g = e('./selectors/advanced'); var v = e('./stringifier/simple'); var y = e('./stringifier/source-maps'); var b = e('./text/comments-processor'); var _ = e('./text/expressions-processor'); var x = e('./text/free-text-processor'); var w = e('./text/urls-processor'); const k = e('./utils/compatibility'); const E = e('./utils/input-source-map-tracker'); const A = e('./utils/source-tracker'); const C = e('./utils/source-reader'); const S = e('./properties/validator'); var T = e('fs'); const O = e('path'); var F = e('url'); const B = e('./utils/object').override; (t.exports = function (e) {
        e = e || {}, this.options = {
          advanced: void 0 === e.advanced || !!e.advanced, aggressiveMerging: void 0 === e.aggressiveMerging || !!e.aggressiveMerging, benchmark: e.benchmark, compatibility: new k(e.compatibility).toOptions(), debug: e.debug, explicitRoot: !!e.root, explicitTarget: !!e.target, inliner: e.inliner || {}, keepBreaks: e.keepBreaks || !1, keepSpecialComments: 'keepSpecialComments' in e ? e.keepSpecialComments : '*', mediaMerging: void 0 === e.mediaMerging || !!e.mediaMerging, processImport: void 0 === e.processImport || !!e.processImport, processImportFrom: r(e.processImportFrom), rebase: void 0 === e.rebase || !!e.rebase, relativeTo: e.relativeTo, restructuring: void 0 === e.restructuring || !!e.restructuring, root: e.root || n.cwd(), roundingPrecision: e.roundingPrecision, semanticMerging: void 0 !== e.semanticMerging && !!e.semanticMerging, shorthandCompacting: void 0 === e.shorthandCompacting || !!e.shorthandCompacting, sourceMap: e.sourceMap, sourceMapInlineSources: !!e.sourceMapInlineSources, target: !e.target || i(e.target) || o(e.target) ? e.target : O.dirname(e.target),
        }, this.options.inliner.timeout = this.options.inliner.timeout || 5e3, this.options.inliner.request = B(s(n.env.HTTP_PROXY || n.env.http_proxy), this.options.inliner.request || {});
      }).prototype.minify = function (e, t) {
        const r = {
          stats: {}, errors: [], warnings: [], options: this.options, debug: this.options.debug, localOnly: !t, sourceTracker: new A(), validator: new S(this.options.compatibility),
        }; return r.options.sourceMap && (r.inputSourceMapTracker = new E(r)), r.sourceReader = new C(r, e), e = r.sourceReader.toString(), r.options.processImport || e.indexOf('@shallow') > 0 ? (t ? n.nextTick : function (e) { return e(); })(() => new h(r).process(e, { localOnly: r.localOnly, imports: r.options.processImportFrom, whenDone: a(t, r) })) : a(t, r)(e);
      };
    }).call(this, e('_process'));
  }, {
    './imports/inliner': 51, './properties/validator': 66, './selectors/advanced': 69, './selectors/simple': 82, './stringifier/simple': 86, './stringifier/source-maps': 87, './text/comments-processor': 88, './text/expressions-processor': 90, './text/free-text-processor': 91, './text/urls-processor': 92, './tokenizer/tokenize': 95, './urls/rebase': 96, './utils/compatibility': 100, './utils/input-source-map-tracker': 101, './utils/object': 102, './utils/source-reader': 104, './utils/source-tracker': 105, _process: 31, fs: 10, path: 30, url: 148,
  }],
  48: [function (e, t, n) {
    function r(e, t, n, r) { return t + a[n.toLowerCase()] + r; } function i(e, t, n) { return u[t.toLowerCase()] + n; } const o = {}; const s = {
      aliceblue: '#f0f8ff', antiquewhite: '#faebd7', aqua: '#0ff', aquamarine: '#7fffd4', azure: '#f0ffff', beige: '#f5f5dc', bisque: '#ffe4c4', black: '#000', blanchedalmond: '#ffebcd', blue: '#00f', blueviolet: '#8a2be2', brown: '#a52a2a', burlywood: '#deb887', cadetblue: '#5f9ea0', chartreuse: '#7fff00', chocolate: '#d2691e', coral: '#ff7f50', cornflowerblue: '#6495ed', cornsilk: '#fff8dc', crimson: '#dc143c', cyan: '#0ff', darkblue: '#00008b', darkcyan: '#008b8b', darkgoldenrod: '#b8860b', darkgray: '#a9a9a9', darkgreen: '#006400', darkgrey: '#a9a9a9', darkkhaki: '#bdb76b', darkmagenta: '#8b008b', darkolivegreen: '#556b2f', darkorange: '#ff8c00', darkorchid: '#9932cc', darkred: '#8b0000', darksalmon: '#e9967a', darkseagreen: '#8fbc8f', darkslateblue: '#483d8b', darkslategray: '#2f4f4f', darkslategrey: '#2f4f4f', darkturquoise: '#00ced1', darkviolet: '#9400d3', deeppink: '#ff1493', deepskyblue: '#00bfff', dimgray: '#696969', dimgrey: '#696969', dodgerblue: '#1e90ff', firebrick: '#b22222', floralwhite: '#fffaf0', forestgreen: '#228b22', fuchsia: '#f0f', gainsboro: '#dcdcdc', ghostwhite: '#f8f8ff', gold: '#ffd700', goldenrod: '#daa520', gray: '#808080', green: '#008000', greenyellow: '#adff2f', grey: '#808080', honeydew: '#f0fff0', hotpink: '#ff69b4', indianred: '#cd5c5c', indigo: '#4b0082', ivory: '#fffff0', khaki: '#f0e68c', lavender: '#e6e6fa', lavenderblush: '#fff0f5', lawngreen: '#7cfc00', lemonchiffon: '#fffacd', lightblue: '#add8e6', lightcoral: '#f08080', lightcyan: '#e0ffff', lightgoldenrodyellow: '#fafad2', lightgray: '#d3d3d3', lightgreen: '#90ee90', lightgrey: '#d3d3d3', lightpink: '#ffb6c1', lightsalmon: '#ffa07a', lightseagreen: '#20b2aa', lightskyblue: '#87cefa', lightslategray: '#778899', lightslategrey: '#778899', lightsteelblue: '#b0c4de', lightyellow: '#ffffe0', lime: '#0f0', limegreen: '#32cd32', linen: '#faf0e6', magenta: '#ff00ff', maroon: '#800000', mediumaquamarine: '#66cdaa', mediumblue: '#0000cd', mediumorchid: '#ba55d3', mediumpurple: '#9370db', mediumseagreen: '#3cb371', mediumslateblue: '#7b68ee', mediumspringgreen: '#00fa9a', mediumturquoise: '#48d1cc', mediumvioletred: '#c71585', midnightblue: '#191970', mintcream: '#f5fffa', mistyrose: '#ffe4e1', moccasin: '#ffe4b5', navajowhite: '#ffdead', navy: '#000080', oldlace: '#fdf5e6', olive: '#808000', olivedrab: '#6b8e23', orange: '#ffa500', orangered: '#ff4500', orchid: '#da70d6', palegoldenrod: '#eee8aa', palegreen: '#98fb98', paleturquoise: '#afeeee', palevioletred: '#db7093', papayawhip: '#ffefd5', peachpuff: '#ffdab9', peru: '#cd853f', pink: '#ffc0cb', plum: '#dda0dd', powderblue: '#b0e0e6', purple: '#800080', rebeccapurple: '#663399', red: '#f00', rosybrown: '#bc8f8f', royalblue: '#4169e1', saddlebrown: '#8b4513', salmon: '#fa8072', sandybrown: '#f4a460', seagreen: '#2e8b57', seashell: '#fff5ee', sienna: '#a0522d', silver: '#c0c0c0', skyblue: '#87ceeb', slateblue: '#6a5acd', slategray: '#708090', slategrey: '#708090', snow: '#fffafa', springgreen: '#00ff7f', steelblue: '#4682b4', tan: '#d2b48c', teal: '#008080', thistle: '#d8bfd8', tomato: '#ff6347', turquoise: '#40e0d0', violet: '#ee82ee', wheat: '#f5deb3', white: '#fff', whitesmoke: '#f5f5f5', yellow: '#ff0', yellowgreen: '#9acd32',
    }; var a = {}; var u = {}; for (const c in s) { const l = s[c]; c.length < l.length ? u[l] = c : a[c] = l; } const p = new RegExp(`(^| |,|\\))(${Object.keys(a).join('|')})( |,|\\)|$)`, 'ig'); const h = new RegExp(`(${Object.keys(u).join('|')})([^a-f0-9]|$)`, 'ig'); o.shorten = function (e) { const t = e.indexOf('#') > -1; let n = e.replace(p, r); return n != e && (n = n.replace(p, r)), t ? n.replace(h, i) : n; }, t.exports = o;
  }, {}],
  49: [function (e, t, n) { function r(e, t, n) { this.hue = e, this.saturation = t, this.lightness = n; } function i(e, t, n) { let r; let i; let s; if ((e %= 360) < 0 && (e += 360), e = ~~e / 360, t < 0 ? t = 0 : t > 100 && (t = 100), t = ~~t / 100, n < 0 ? n = 0 : n > 100 && (n = 100), n = ~~n / 100, t === 0)r = i = s = n; else { const a = n < 0.5 ? n * (1 + t) : n + t - n * t; const u = 2 * n - a; r = o(u, a, e + 1 / 3), i = o(u, a, e), s = o(u, a, e - 1 / 3); } return [~~(255 * r), ~~(255 * i), ~~(255 * s)]; } function o(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < 0.5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e; }r.prototype.toHex = function () { const e = i(this.hue, this.saturation, this.lightness); const t = e[0].toString(16); const n = e[1].toString(16); const r = e[2].toString(16); return `#${t.length == 1 ? '0' : ''}${t}${n.length == 1 ? '0' : ''}${n}${r.length == 1 ? '0' : ''}${r}`; }, t.exports = r; }, {}],
  50: [function (e, t, n) { function r(e, t, n) { this.red = e, this.green = t, this.blue = n; }r.prototype.toHex = function () { return `#${(`00000${(Math.max(0, Math.min(~~this.red, 255)) << 16 | Math.max(0, Math.min(~~this.green, 255)) << 8 | Math.max(0, Math.min(~~this.blue, 255))).toString(16)}`).slice(-6)}`; }, t.exports = r; }, {}],
  51: [function (e, t, n) {
    (function (n) {
      function r(e) { this.outerContext = e; } function i(e, t) { if (t.shallow) return t.shallow = !1, t.done.push(e), a(t); for (let n = 0, r = 0, i = 0, o = u(e); r < e.length && (n = s(e, i)) != -1;) { if (!o(n)) { if ((r = e.indexOf(';', n)) == -1) { i = e.length, e = ''; break; } const p = e.substring(0, n); return t.done.push(p), t.left.unshift([e.substring(r + 1), w(t, { shallow: !1 })]), t.afterContent = c(p), l(e, n, r, t); }i = n + 1; } return t.done.push(e), a(t); } function o(e, t) { return e.replace(k, (e, n) => (E.test(n) ? e : e.replace(n, b.resolve(t, n)))); } function s(e, t) { const n = e.indexOf('@import', t); const r = e.indexOf('@IMPORT', t); return n > -1 && r == -1 ? n : n == -1 && r > -1 ? r : Math.min(n, r); } function a(e) { return e.left.length > 0 ? i(...e.left.shift()) : e.whenDone(e.done.join('')); } function u(e) { const t = /(\/\*(?!\*\/)[\s\S]*?\*\/)/; let n = 0; let r = 0; let i = !1; return function (o) { let s; let a = 0; let u = 0; let c = 0; let l = 0; if (i) return !1; do { if (o > n && o < r) return !0; if (!(s = e.match(t))) return i = !0, !1; n = a = s.index, c = (l = (u = a + s[0].length) + r) - s[0].length, e = e.substring(u), r = l; } while (l < o);return l > o && o > c; }; } function c(e) { for (var t = u(e), n = -1; ;) if ((n = e.indexOf('{', n + 1)) == -1 || !t(n)) break; return n > -1; } function l(e, t, n, r) { r.shallow = e.indexOf('@shallow') > 0; const i = e.substring(s(e, t) + '@import'.length + 1, n).replace(/@shallow\)$/, ')').trim(); const o = i.indexOf('url(') === 0; const u = o ? 4 : 0; const l = /^['"]/.exec(i.substring(u, u + 2)); const m = l ? i.indexOf(l[0], u + 1) : x(i, ' ')[0].length - (o ? 1 : 0); const g = i.substring(u, m).replace(/['"]/g, '').replace(/\)$/, '').trim(); const v = i.substring(m + 1).replace(/^\)/, '').trim(); const y = r.isRemote || E.test(g); return !y || !r.localOnly && p(g, !0, r.imports) ? y || p(g, !1, r.imports) ? !y && r.afterContent ? (r.warnings.push(`Ignoring local @import of "${g}" as after other CSS content.`), a(r)) : (y ? h : f)(g, v, r) : (r.afterImport ? r.warnings.push(`Ignoring local @import of "${g}" as after other inlined content.`) : d(g, v, r), a(r)) : (r.afterContent || c(r.done.join('')) ? r.warnings.push(`Ignoring remote @import of "${g}" as no callback given.`) : d(g, v, r), a(r)); } function p(e, t, n) { if (n.length === 0) return !1; t && A.test(e) && (e = `http:${e}`); for (var r = t ? b.parse(e).host : e, i = !0, o = 0; o < n.length; o++) { const s = n[o]; s == 'all' ? i = !0 : t && s == 'local' ? i = !1 : t && s == 'remote' ? i = !0 : t || s != 'remote' ? t || s != 'local' ? s[0] == '!' && s.substring(1) === r && (i = !1) : i = !0 : i = !1; } return i; } function h(e, t, r) { function s(e) { f || (f = !0, r.errors.push(`Broken @import declaration of "${u}" - ${e}`), d(u, t, r), n.nextTick(() => { a(r); })); } var u = E.test(e) ? e : b.resolve(r.relativeTo, e); const c = u; if (A.test(u) && (u = `http:${u}`), r.visited.indexOf(u) > -1) return a(r); r.debug && console.error(`Inlining remote stylesheet: ${u}`), r.visited.push(u); const l = r.inliner.request.protocol || r.inliner.request.hostname; const p = l && l.indexOf('https://') !== 0 || u.indexOf('http://') === 0 ? v.get : y.get; var f = !1; const m = w(b.parse(u), r.inliner.request); void 0 !== r.inliner.request.hostname && (m.protocol = r.inliner.request.protocol || 'http:', m.path = m.href), p(m, (e) => { if (e.statusCode < 200 || e.statusCode > 399) return s(`error ${e.statusCode}`); if (e.statusCode > 299) return h(b.resolve(u, e.headers.location), t, r); const a = []; const l = b.parse(u); e.on('data', (e) => { a.push(e.toString()); }), e.on('end', () => { let e = a.join(''); r.rebase && (e = _(e, { toBase: c }, r)), r.sourceReader.trackSource(u, e), e = r.sourceTracker.store(u, e), e = o(e, u), t.length > 0 && (e = `@media ${t}{${e}}`), r.afterImport = !0; const s = w(r, { isRemote: !0, relativeTo: `${l.protocol}//${l.host}${l.pathname}` }); n.nextTick(() => { i(e, s); }); }); }).on('error', (e) => { s(e.message); }).on('timeout', () => { s('timeout'); }).setTimeout(r.inliner.timeout); } function f(e, t, n) { const r = e[0] == '/' ? n.root : n.relativeTo; const o = g.resolve(g.join(r, e)); if (!m.existsSync(o) || !m.statSync(o).isFile()) return n.errors.push(`Broken @import declaration of "${e}"`), a(n); if (n.visited.indexOf(o) > -1) return a(n); n.debug && console.error(`Inlining local stylesheet: ${o}`), n.visited.push(o); const s = g.dirname(o); let u = m.readFileSync(o, 'utf8'); if (n.rebase) { const c = { relative: !0, fromBase: s, toBase: n.baseRelativeTo }; u = _(u, c, n); } const l = g.relative(n.root, o); return n.sourceReader.trackSource(l, u), u = n.sourceTracker.store(l, u), t.length > 0 && (u = `@media ${t}{${u}}`), n.afterImport = !0, i(u, w(n, { relativeTo: s })); } function d(e, t, n) { const r = `@import url(${e})${t.length > 0 ? ` ${t}` : ''};`; n.done.push(r); } var m = e('fs'); var g = e('path'); var v = e('http'); var y = e('https'); var b = e('url'); var _ = e('../urls/rewrite'); var x = e('../utils/split'); var w = e('../utils/object.js').override; var k = /\/\*# sourceMappingURL=(\S+) \*\//; var E = /^(https?:)?\/\//; var A = /^\/\//; r.prototype.process = function (e, t) {
        const n = this.outerContext.options.root; return t = w(t, {
          baseRelativeTo: this.outerContext.options.relativeTo || n, debug: this.outerContext.options.debug, done: [], errors: this.outerContext.errors, left: [], inliner: this.outerContext.options.inliner, rebase: this.outerContext.options.rebase, relativeTo: this.outerContext.options.relativeTo || n, root: n, sourceReader: this.outerContext.sourceReader, sourceTracker: this.outerContext.sourceTracker, warnings: this.outerContext.warnings, visited: [],
        }), i(e, t);
      }, t.exports = r;
    }).call(this, e('_process'));
  }, {
    '../urls/rewrite': 98, '../utils/object.js': 102, '../utils/split': 106, _process: 31, fs: 10, http: 10, https: 10, path: 30, url: 148,
  }],
  52: [function (e, t, n) {
    function r(e) { return function (t) { return t[0] == 'invert' || e.isValidColor(t[0]); }; } function i(e) { return function (t) { return t[0] != 'inherit' && e.isValidStyle(t[0]) && !e.isValidColorValue(t[0]); }; } function o(e, t, n) { const r = n[e]; return c(r.doubleValues && r.defaultValue.length == 2 ? [[e, t.important], [r.defaultValue[0]], [r.defaultValue[1]]] : r.doubleValues && r.defaultValue.length == 1 ? [[e, t.important], [r.defaultValue[0]]] : [[e, t.important], [r.defaultValue]]); } function s(e) { return function (t) { return t[0] != 'inherit' && e.isValidWidth(t[0]) && !e.isValidStyleKeyword(t[0]) && !e.isValidColorValue(t[0]); }; } function a(e, t) { const n = t[e.name].components; const r = []; const i = e.value; if (i.length < 1) return []; i.length < 2 && (i[1] = i[0].slice(0)), i.length < 3 && (i[2] = i[0].slice(0)), i.length < 4 && (i[3] = i[1].slice(0)); for (let o = n.length - 1; o >= 0; o--) { const s = c([[n[o], e.important]]); s.value = [i[o]], r.unshift(s); } return r; } function u(e, t, n) { for (var a, u, c, l = t[e.name], p = [o(l.components[0], e, t), o(l.components[1], e, t), o(l.components[2], e, t)], h = 0; h < 3; h++) { const f = p[h]; f.name.indexOf('color') > 0 ? a = f : f.name.indexOf('style') > 0 ? u = f : c = f; } if (e.value.length == 1 && e.value[0][0] == 'inherit' || e.value.length == 3 && e.value[0][0] == 'inherit' && e.value[1][0] == 'inherit' && e.value[2][0] == 'inherit') return a.value = u.value = c.value = [e.value[0]], p; let d; let m; const g = e.value.slice(0); return g.length > 0 && (d = (m = g.filter(s(n))).length > 1 && (m[0][0] == 'none' || m[0][0] == 'auto') ? m[1] : m[0]) && (c.value = [d], g.splice(g.indexOf(d), 1)), g.length > 0 && (d = g.filter(i(n))[0]) && (u.value = [d], g.splice(g.indexOf(d), 1)), g.length > 0 && (d = g.filter(r(n))[0]) && (a.value = [d], g.splice(g.indexOf(d), 1)), p; } var c = e('./wrap-for-optimizing').single; const l = e('./invalid-property-error'); const p = e('../utils/split'); const h = ','; t.exports = {
      background(e, t, n) { const r = o('background-image', e, t); const i = o('background-position', e, t); const s = o('background-size', e, t); const a = o('background-repeat', e, t); const u = o('background-attachment', e, t); const c = o('background-origin', e, t); const l = o('background-clip', e, t); const h = o('background-color', e, t); const f = [r, i, s, a, u, c, l, h]; const d = e.value; let m = !1; let g = !1; let v = !1; let y = !1; if (e.value.length == 1 && e.value[0][0] == 'inherit') return h.value = r.value = a.value = i.value = s.value = c.value = l.value = e.value, f; for (let b = d.length - 1; b >= 0; b--) { const _ = d[b]; if (n.isValidBackgroundAttachment(_[0]))u.value = [_]; else if (n.isValidBackgroundBox(_[0]))g ? (c.value = [_], v = !0) : (l.value = [_], g = !0); else if (n.isValidBackgroundRepeat(_[0]))y ? a.value.unshift(_) : (a.value = [_], y = !0); else if (n.isValidBackgroundPositionPart(_[0]) || n.isValidBackgroundSizePart(_[0])) if (b > 0) { const x = d[b - 1]; if (x[0].indexOf('/') > 0) { const w = p(x[0], '/'); s.value = [[w.pop()].concat(x.slice(1)), _], d[b - 1] = [w.pop()].concat(x.slice(1)); } else b > 1 && d[b - 2][0] == '/' ? (s.value = [x, _], b -= 2) : x[0] == '/' ? s.value = [_] : (m || (i.value = []), i.value.unshift(_), m = !0); } else m || (i.value = []), i.value.unshift(_), m = !0; else if (n.isValidBackgroundPositionAndSize(_[0])) { const k = p(_[0], '/'); s.value = [[k.pop()].concat(_.slice(1))], i.value = [[k.pop()].concat(_.slice(1))]; } else h.value[0][0] != t[h.name].defaultValue && h.value[0][0] != 'none' || !n.isValidColor(_[0]) ? (n.isValidUrl(_[0]) || n.isValidFunction(_[0])) && (r.value = [_]) : h.value = [_]; } return g && !v && (c.value = l.value.slice(0)), f; }, border: u, borderRadius(e, t) { for (var n = e.value, r = -1, i = 0, s = n.length; i < s; i++) if (n[i][0] == '/') { r = i; break; } if (r === 0 || r === n.length - 1) throw new l('Invalid border-radius value.'); const u = o(e.name, e, t); u.value = r > -1 ? n.slice(0, r) : n.slice(0), u.components = a(u, t); const c = o(e.name, e, t); c.value = r > -1 ? n.slice(r + 1) : n.slice(0), c.components = a(c, t); for (let p = 0; p < 4; p++)u.components[p].multiplex = !0, u.components[p].value = u.components[p].value.concat(c.components[p].value); return u.components; }, fourValues: a, listStyle(e, t, n) { const r = o('list-style-type', e, t); const i = o('list-style-position', e, t); const s = o('list-style-image', e, t); const a = [r, i, s]; if (e.value.length == 1 && e.value[0][0] == 'inherit') return r.value = i.value = s.value = [e.value[0]], a; const u = e.value.slice(0); let c = u.length; let l = 0; for (l = 0, c = u.length; l < c; l++) if (n.isValidUrl(u[l][0]) || u[l][0] == '0') { s.value = [u[l]], u.splice(l, 1); break; } for (l = 0, c = u.length; l < c; l++) if (n.isValidListStyleType(u[l][0])) { r.value = [u[l]], u.splice(l, 1); break; } return u.length > 0 && n.isValidListStylePosition(u[0][0]) && (i.value = [u[0]]), a; }, multiplex(e) { return function (t, n, r) { let i; let s; let a; let u; const c = []; const l = t.value; for (i = 0, a = l.length; i < a; i++)l[i][0] == ',' && c.push(i); if (c.length === 0) return e(t, n, r); const p = []; for (i = 0, a = c.length; i <= a; i++) { const f = i === 0 ? 0 : c[i - 1] + 1; const d = i < a ? c[i] : l.length; const m = o(t.name, t, n); m.value = l.slice(f, d), p.push(e(m, n, r)); } const g = p[0]; for (i = 0, a = g.length; i < a; i++) for (g[i].multiplex = !0, s = 1, u = p.length; s < u; s++)g[i].value.push([h]), Array.prototype.push.apply(g[i].value, p[s][i].value); return g; }; }, outline: u,
    };
  }, { '../utils/split': 106, './invalid-property-error': 58, './wrap-for-optimizing': 68 }],
  53: [function (e, t, n) {
    function r(e, t, n) { const r = e.value[0][0]; const o = t.value[0][0]; return !(!n.colorOpacity && (n.isValidRgbaColor(r) || n.isValidHslaColor(r))) && (!(!n.colorOpacity && (n.isValidRgbaColor(o) || n.isValidHslaColor(o))) && (!(!n.isValidNamedColor(o) && !n.isValidHexColor(o)) || !n.isValidNamedColor(r) && !n.isValidHexColor(r) && (!(!n.isValidRgbaColor(o) && !n.isValidHslaColor(o)) || !n.isValidRgbaColor(r) && !n.isValidHslaColor(r) && i(e, t, n)))); } function i(e, t, n) { const r = e.value[0][0]; const i = t.value[0][0]; return !!n.areSameFunction(r, i) || r === i; }t.exports = {
      always() { return !0; }, alwaysButIntoFunction(e, t, n) { const r = e.value[0][0]; const i = t.value[0][0]; const o = n.isValidFunction(r); const s = n.isValidFunction(i); return o && s ? n.areSameFunction(r, i) : !(!o && s); }, backgroundImage(e, t, n) { const r = e.value[0][0]; const o = t.value[0][0]; return !(o != 'none' && o != 'inherit' && !n.isValidUrl(o)) || r != 'none' && r != 'inherit' && !n.isValidUrl(r) && i(e, t, n); }, border(e, t, n) { return r(e.components[2], t.components[2], n); }, color: r, sameValue(e, t) { return e.value[0][0] === t.value[0][0]; }, sameFunctionOrValue: i, twoOptionalFunctions(e, t, n) { const r = e.value[0][0]; const i = t.value[0][0]; return !(n.isValidFunction(r) ^ n.isValidFunction(i)); }, unit(e, t, n) { const r = e.value[0][0]; const o = t.value[0][0]; return !(n.isValidAndCompatibleUnitWithoutFunction(r) && !n.isValidAndCompatibleUnitWithoutFunction(o)) && (!!n.isValidUnitWithoutFunction(o) || !n.isValidUnitWithoutFunction(r) && (!(!n.isValidFunctionWithoutVendorPrefix(o) || !n.isValidFunctionWithoutVendorPrefix(r)) || i(e, t, n))); },
    };
  }, {}],
  54: [function (e, t, n) { function r(e) { const t = i([[e.name, e.important, e.hack]]); return t.unused = !1, t; } var i = e('./wrap-for-optimizing').single; t.exports = { deep(e) { for (var t = r(e), n = e.components.length - 1; n >= 0; n--) { const i = r(e.components[n]); i.value = e.components[n].value.slice(0), t.components.unshift(i); } return t.dirty = !0, t.value = e.value.slice(0), t; }, shallow: r }; }, { './wrap-for-optimizing': 68 }],
  55: [function (e, t, n) {
    const r = e('./break-up'); const i = e('./can-override'); const o = e('./restore'); const s = {
      color: { canOverride: i.color, defaultValue: 'transparent', shortestValue: 'red' },
      background: {
        components: ['background-image', 'background-position', 'background-size', 'background-repeat', 'background-attachment', 'background-origin', 'background-clip', 'background-color'], breakUp: r.multiplex(r.background), defaultValue: '0 0', restore: o.multiplex(o.background), shortestValue: '0', shorthand: !0,
      },
      'background-clip': { canOverride: i.always, defaultValue: 'border-box', shortestValue: 'border-box' },
      'background-color': {
        canOverride: i.color, defaultValue: 'transparent', multiplexLastOnly: !0, nonMergeableValue: 'none', shortestValue: 'red',
      },
      'background-image': { canOverride: i.backgroundImage, defaultValue: 'none' },
      'background-origin': { canOverride: i.always, defaultValue: 'padding-box', shortestValue: 'border-box' },
      'background-repeat': { canOverride: i.always, defaultValue: ['repeat'], doubleValues: !0 },
      'background-position': {
        canOverride: i.alwaysButIntoFunction, defaultValue: ['0', '0'], doubleValues: !0, shortestValue: '0',
      },
      'background-size': {
        canOverride: i.alwaysButIntoFunction, defaultValue: ['auto'], doubleValues: !0, shortestValue: '0 0',
      },
      'background-attachment': { canOverride: i.always, defaultValue: 'scroll' },
      border: {
        breakUp: r.border, canOverride: i.border, components: ['border-width', 'border-style', 'border-color'], defaultValue: 'none', restore: o.withoutDefaults, shorthand: !0,
      },
      'border-color': { canOverride: i.color, defaultValue: 'none', shorthand: !0 },
      'border-style': { canOverride: i.always, defaultValue: 'none', shorthand: !0 },
      'border-width': {
        canOverride: i.unit, defaultValue: 'medium', shortestValue: '0', shorthand: !0,
      },
      'list-style': {
        components: ['list-style-type', 'list-style-position', 'list-style-image'], canOverride: i.always, breakUp: r.listStyle, restore: o.withoutDefaults, defaultValue: 'outside', shortestValue: 'none', shorthand: !0,
      },
      'list-style-type': { canOverride: i.always, defaultValue: '__hack', shortestValue: 'none' },
      'list-style-position': { canOverride: i.always, defaultValue: 'outside', shortestValue: 'inside' },
      'list-style-image': { canOverride: i.always, defaultValue: 'none' },
      outline: {
        components: ['outline-color', 'outline-style', 'outline-width'], breakUp: r.outline, restore: o.withoutDefaults, defaultValue: '0', shorthand: !0,
      },
      'outline-color': { canOverride: i.color, defaultValue: 'invert', shortestValue: 'red' },
      'outline-style': { canOverride: i.always, defaultValue: 'none' },
      'outline-width': { canOverride: i.unit, defaultValue: 'medium', shortestValue: '0' },
      '-moz-transform': { canOverride: i.sameFunctionOrValue },
      '-ms-transform': { canOverride: i.sameFunctionOrValue },
      '-webkit-transform': { canOverride: i.sameFunctionOrValue },
      transform: { canOverride: i.sameFunctionOrValue },
    }; const a = function (e, t, n) {
      n = n || {}, s[e] = {
        canOverride: n.canOverride, components: t, breakUp: n.breakUp || r.fourValues, defaultValue: n.defaultValue || '0', restore: n.restore || o.fourValues, shortestValue: n.shortestValue, shorthand: !0,
      }; for (let a = 0; a < t.length; a++) {
        s[t[a]] = {
          breakUp: n.breakUp || r.fourValues, canOverride: n.canOverride || i.unit, defaultValue: n.defaultValue || '0', shortestValue: n.shortestValue,
        };
      }
    }; ['', '-moz-', '-o-'].forEach((e) => { a(`${e}border-radius`, [`${e}border-top-left-radius`, `${e}border-top-right-radius`, `${e}border-bottom-right-radius`, `${e}border-bottom-left-radius`], { breakUp: r.borderRadius, restore: o.borderRadius }); }), a('border-color', ['border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color'], {
      breakUp: r.fourValues, canOverride: i.color, defaultValue: 'none', shortestValue: 'red',
    }), a('border-style', ['border-top-style', 'border-right-style', 'border-bottom-style', 'border-left-style'], { breakUp: r.fourValues, canOverride: i.always, defaultValue: 'none' }), a('border-width', ['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'], { defaultValue: 'medium', shortestValue: '0' }), a('padding', ['padding-top', 'padding-right', 'padding-bottom', 'padding-left']), a('margin', ['margin-top', 'margin-right', 'margin-bottom', 'margin-left']); for (const u in s) if (s[u].shorthand) for (let c = 0, l = s[u].components.length; c < l; c++)s[s[u].components[c]].componentOf = u; t.exports = s;
  }, { './break-up': 52, './can-override': 53, './restore': 64 }],
  56: [function (e, t, n) { const r = e('./clone').shallow; const i = ','; t.exports = function (e, t, n, o) { for (let s = !(t.shorthand || n.shorthand || t.multiplex || n.multiplex), a = r(t), u = r(n), c = 0, l = t.value.length; c < l; c++) for (let p = 0, h = n.value.length; p < h; p++) if (t.value[c][0] != i && n.value[p][0] != i && !(s && c != p || (a.value = [t.value[c]], u.value = [n.value[p]], e(a, u, o)))) return !1; return !0; }; }, { './clone': 54 }],
  57: [function (e, t, n) { t.exports = function (e) { for (let t = e.value.length - 1; t >= 0; t--) if (e.value[t][0] == 'inherit') return !0; return !1; }; }, {}],
  58: [function (e, t, n) { function r(e) { this.name = 'InvalidPropertyError', this.message = e, this.stack = (new Error()).stack; }(r.prototype = Object.create(Error.prototype)).constructor = r, t.exports = r; }, {}],
  59: [function (e, t, n) {
    function r(e, t, n, r) { let i; let s; let a = {}; let u = null; e:for (let c = 0, l = e.length; c < l; c++) { const p = e[c]; const d = !(p.name != '-ms-filter' && p.name != 'filter' || u != 'background' && u != 'background-image') ? u : p.name; const m = p.important; const g = p.hack; if (!p.unused) if (c > 0 && i && d == u && m == i.important && g == i.hack && (function (t) { const n = e[t - 1]; const r = e[t]; return h(n.all, n.position) == h(r.all, r.position); }(c)) && !i.unused)p.unused = !0; else { if (d in a && (n && d != u || (function (e) { return !1 === t || !0 === t ? t : t.indexOf(e) > -1; }(c)))) { const v = a[d]; const y = o[d] && o[d].canOverride; let b = !1; for (s = v.length - 1; s >= 0; s--) { const _ = e[v[s]]; const x = _.name != d; const w = _.important; const k = _.hack; if (!_.unused && ((!x || !w) && (w || !(k && !g || !k && g)) && (!w || g != 'star' && g != 'underscore') && (k || g || x || !y || y(_, p, r)))) { if (w && !m || w && g) { p.unused = !0, i = p; continue e; }b = !0, _.unused = !0; } } if (b) { c = -1, i = null, u = null, a = {}; continue; } } else { a[d] = a[d] || [], a[d].push(c); const E = f[d]; if (E) for (s = E.length - 1; s >= 0; s--) { const A = E[s]; a[A] = a[A] || [], a[A].push(c); } }u = d, i = p; } } } function i(e, t, n, o, h, f) { const d = f.validator; const m = f.warnings; const g = s(t); a(g, d, m), r(g, n, h.aggressiveMerging, d); for (let v = 0, y = g.length; v < y; v++) { const b = g[v]; b.variable && b.block && i(e, b.value[0], n, o, h, f); }o && h.shorthandCompacting && (u(g, h.compatibility, d), c(g, h.sourceMap, d)), p(g), l(g); } var o = e('./compactable'); var s = e('./wrap-for-optimizing').all; var a = e('./populate-components'); var u = e('./override-compactor'); var c = e('./shorthand-compactor'); var l = e('./remove-unused'); var p = e('./restore-from-optimizing'); var h = e('../stringifier/one-time').property; var f = {
      'animation-delay': ['animation'], 'animation-direction': ['animation'], 'animation-duration': ['animation'], 'animation-fill-mode': ['animation'], 'animation-iteration-count': ['animation'], 'animation-name': ['animation'], 'animation-play-state': ['animation'], 'animation-timing-function': ['animation'], '-moz-animation-delay': ['-moz-animation'], '-moz-animation-direction': ['-moz-animation'], '-moz-animation-duration': ['-moz-animation'], '-moz-animation-fill-mode': ['-moz-animation'], '-moz-animation-iteration-count': ['-moz-animation'], '-moz-animation-name': ['-moz-animation'], '-moz-animation-play-state': ['-moz-animation'], '-moz-animation-timing-function': ['-moz-animation'], '-o-animation-delay': ['-o-animation'], '-o-animation-direction': ['-o-animation'], '-o-animation-duration': ['-o-animation'], '-o-animation-fill-mode': ['-o-animation'], '-o-animation-iteration-count': ['-o-animation'], '-o-animation-name': ['-o-animation'], '-o-animation-play-state': ['-o-animation'], '-o-animation-timing-function': ['-o-animation'], '-webkit-animation-delay': ['-webkit-animation'], '-webkit-animation-direction': ['-webkit-animation'], '-webkit-animation-duration': ['-webkit-animation'], '-webkit-animation-fill-mode': ['-webkit-animation'], '-webkit-animation-iteration-count': ['-webkit-animation'], '-webkit-animation-name': ['-webkit-animation'], '-webkit-animation-play-state': ['-webkit-animation'], '-webkit-animation-timing-function': ['-webkit-animation'], 'border-color': ['border'], 'border-style': ['border'], 'border-width': ['border'], 'border-bottom': ['border'], 'border-bottom-color': ['border-bottom', 'border-color', 'border'], 'border-bottom-style': ['border-bottom', 'border-style', 'border'], 'border-bottom-width': ['border-bottom', 'border-width', 'border'], 'border-left': ['border'], 'border-left-color': ['border-left', 'border-color', 'border'], 'border-left-style': ['border-left', 'border-style', 'border'], 'border-left-width': ['border-left', 'border-width', 'border'], 'border-right': ['border'], 'border-right-color': ['border-right', 'border-color', 'border'], 'border-right-style': ['border-right', 'border-style', 'border'], 'border-right-width': ['border-right', 'border-width', 'border'], 'border-top': ['border'], 'border-top-color': ['border-top', 'border-color', 'border'], 'border-top-style': ['border-top', 'border-style', 'border'], 'border-top-width': ['border-top', 'border-width', 'border'], 'font-family': ['font'], 'font-size': ['font'], 'font-style': ['font'], 'font-variant': ['font'], 'font-weight': ['font'], 'transition-delay': ['transition'], 'transition-duration': ['transition'], 'transition-property': ['transition'], 'transition-timing-function': ['transition'], '-moz-transition-delay': ['-moz-transition'], '-moz-transition-duration': ['-moz-transition'], '-moz-transition-property': ['-moz-transition'], '-moz-transition-timing-function': ['-moz-transition'], '-o-transition-delay': ['-o-transition'], '-o-transition-duration': ['-o-transition'], '-o-transition-property': ['-o-transition'], '-o-transition-timing-function': ['-o-transition'], '-webkit-transition-delay': ['-webkit-transition'], '-webkit-transition-duration': ['-webkit-transition'], '-webkit-transition-property': ['-webkit-transition'], '-webkit-transition-timing-function': ['-webkit-transition'],
    }; t.exports = i;
  }, {
    '../stringifier/one-time': 85, './compactable': 55, './override-compactor': 60, './populate-components': 61, './remove-unused': 62, './restore-from-optimizing': 63, './shorthand-compactor': 65, './wrap-for-optimizing': 68,
  }],
  60: [function (e, t, n) { function r(e) { return function (t) { return e.name === t.name; }; } function i(e, t) { for (let n = 0; n < e.components.length; n++) { const r = e.components[n]; const i = k[r.name]; var o = i && i.canOverride || o.sameValue; const s = A(r); if (s.value = [[i.defaultValue]], !o(s, r, t)) return !0; } return !1; } function o(e, t) { return k[e.name].components.indexOf(t.name) > -1; } function s(e, t) { t.unused = !0, p(t, h(e)), e.value = t.value; } function a(e, t) { t.unused = !0, e.multiplex = !0, e.value = t.value; } function u(e, t) { t.unused = !0, e.value = t.value; } function c(e, t) { t.multiplex ? a(e, t) : e.multiplex ? s(e, t) : u(e, t); } function l(e, t) { t.unused = !0; for (let n = 0, r = e.components.length; n < r; n++)c(e.components[n], t.components[n], e.multiplex); } function p(e, t) { e.multiplex = !0; for (let n = 0, r = e.components.length; n < r; n++) { const i = e.components[n]; if (!i.multiplex) for (let o = i.value.slice(0), s = 1; s < t; s++)i.value.push([B]), Array.prototype.push.apply(i.value, o); } } function h(e) { for (var t = 0, n = 0, r = e.value.length; n < r; n++)e.value[n][0] == B && t++; return t + 1; } function f(e) { const t = [[e.name]].concat(e.value); return F([t], 0).length; } function d(e, t, n) { for (var r = 0, i = t; i >= 0 && (e[i].name != n || e[i].unused || r++, !(r > 1)); i--);return r > 1; } function m(e, t) { for (let n = 0, r = e.components.length; n < r; n++) if (g(t.isValidFunction, e.components[n])) return !0; return !1; } function g(e, t) { for (let n = 0, r = t.value.length; n < r; n++) if (t.value[n][0] != B && e(t.value[n][0])) return !0; return !1; } function v(e, t) { if (!e.multiplex && !t.multiplex || e.multiplex && t.multiplex) return !1; let n; const i = e.multiplex ? e : t; const o = e.multiplex ? t : e; const u = E(i); S([u]); const c = E(o); S([c]); const l = f(u) + 1 + f(c); return e.multiplex ? s(n = u.components.filter(r(c))[0], c) : (n = c.components.filter(r(u))[0], p(c, h(u)), a(n, u)), S([c]), l < f(c); } function y(e) { return e.name in k; } function b(e, t) { return !e.multiplex && (e.name == 'background' || e.name == 'background-image') && t.multiplex && (t.name == 'background' || t.name == 'background-image') && _(t.value); } function _(e) { for (let t = x(e), n = 0, r = t.length; n < r; n++) if (t[n].length == 1 && t[n][0][0] == 'none') return !0; return !1; } function x(e) { for (var t = [], n = 0, r = [], i = e.length; n < i; n++) { const o = e[n]; o[0] == B ? (t.push(r), r = []) : r.push(o); } return t.push(r), t; } const w = e('./can-override'); var k = e('./compactable'); var E = e('./clone').deep; var A = e('./clone').shallow; const C = e('./has-inherit'); var S = e('./restore-from-optimizing'); const T = e('./every-combination'); const O = e('./vendor-prefixes').same; var F = e('../stringifier/one-time').property; var B = ','; t.exports = function (e, t, n) { let s; let a; let u; let f; let _; let x; let E; e:for (_ = e.length - 1; _ >= 0; _--) if (a = e[_], y(a) && !a.variable) for (s = k[a.name].canOverride || w.sameValue, x = _ - 1; x >= 0; x--) if (u = e[x], y(u) && !(u.variable || u.unused || a.unused || u.hack && !a.hack || !u.hack && a.hack || C(a) || b(u, a))) if (!u.shorthand && a.shorthand && o(a, u)) { if (!a.important && u.important) continue; if (!O([u], a.components)) continue; if (!g(n.isValidFunction, u) && m(a, n)) continue; f = a.components.filter(r(u))[0], s = k[u.name] && k[u.name].canOverride || w.sameValue, T(s, u, f, n) && (u.unused = !0); } else if (u.shorthand && !a.shorthand && o(u, a)) { if (a.important && !u.important) continue; if (!a.important && u.important) { a.unused = !0; continue; } if (d(e, _ - 1, u.name)) continue; if (m(u, n)) continue; if (f = u.components.filter(r(a))[0], T(s, f, a, n)) { const A = !t.properties.backgroundClipMerging && f.name.indexOf('background-clip') > -1 || !t.properties.backgroundOriginMerging && f.name.indexOf('background-origin') > -1 || !t.properties.backgroundSizeMerging && f.name.indexOf('background-size') > -1; const S = k[a.name].nonMergeableValue === a.value[0][0]; if (A || S) continue; if (!t.properties.merging && i(u, n)) continue; if (f.value[0][0] != a.value[0][0] && (C(u) || C(a))) continue; if (v(u, a)) continue; !u.multiplex && a.multiplex && p(u, h(a)), c(f, a), u.dirty = !0; } } else if (u.shorthand && a.shorthand && u.name == a.name) { if (!u.multiplex && a.multiplex) continue; if (!a.important && u.important) { a.unused = !0; continue e; } if (a.important && !u.important) { u.unused = !0; continue; } for (E = u.components.length - 1; E >= 0; E--) { const F = u.components[E]; const B = a.components[E]; if (s = k[F.name].canOverride || w.sameValue, !T(s, F, B, n)) continue e; if (!T(w.twoOptionalFunctions, F, B, n) && n.isValidFunction(B)) continue e; }l(u, a), u.dirty = !0; } else if (u.shorthand && a.shorthand && o(u, a)) { if (!u.important && a.important) continue; if (f = u.components.filter(r(a))[0], s = k[a.name].canOverride || w.sameValue, !T(s, f, a, n)) continue; if (u.important && !a.important) { a.unused = !0; continue; } if (k[a.name].restore(a, k).length > 1) continue; c(f = u.components.filter(r(a))[0], a), a.dirty = !0; } else if (u.name == a.name) { if (u.important && !a.important) { a.unused = !0; continue; } if (s = k[a.name].canOverride || w.sameValue, !T(s, u, a, n)) continue; u.unused = !0; } }; }, {
    '../stringifier/one-time': 85, './can-override': 53, './clone': 54, './compactable': 55, './every-combination': 56, './has-inherit': 57, './restore-from-optimizing': 63, './vendor-prefixes': 67,
  }],
  61: [function (e, t, n) { const r = e('./compactable'); const i = e('./invalid-property-error'); t.exports = function (e, t, n) { for (let o = e.length - 1; o >= 0; o--) { const s = e[o]; const a = r[s.name]; if (a && a.shorthand) { s.shorthand = !0, s.dirty = !0; try { s.components = a.breakUp(s, r, t); } catch (e) { if (!(e instanceof i)) throw e; s.components = [], n.push(e.message); }s.components.length > 0 ? s.multiplex = s.components[0].multiplex : s.unused = !0; } } }; }, { './compactable': 55, './invalid-property-error': 58 }],
  62: [function (e, t, n) { t.exports = function (e) { for (let t = e.length - 1; t >= 0; t--) { const n = e[t]; n.unused && n.all.splice(n.position, 1); } }; }, {}],
  63: [function (e, t, n) { function r(e) { e.value[e.value.length - 1][0] += a; } function i(e) { e.hack == 'underscore' ? e.name = c + e.name : e.hack == 'star' ? e.name = u + e.name : e.hack == 'backslash' ? e.value[e.value.length - 1][0] += s : e.hack == 'bang' && (e.value[e.value.length - 1][0] += ` ${l}`); } const o = e('./compactable'); var s = '\\9'; var a = '!important'; var u = '*'; var c = '_'; var l = '!ie'; t.exports = function (e, t) { for (let n = e.length - 1; n >= 0; n--) { var s; const a = e[n]; const u = o[a.name]; if (!a.unused && (a.dirty || a.important || a.hack) && (!t && u && u.shorthand ? (s = u.restore(a, o), a.value = s) : s = a.value, a.important && r(a), a.hack && i(a), 'all' in a)) { const c = a.all[a.position]; c[0][0] = a.name, c.splice(1, c.length - 1), Array.prototype.push.apply(c, s); } } }; }, { './compactable': 55 }],
  64: [function (e, t, n) {
    function r(e) { for (let t = 0, n = e.length; t < n; t++) { const r = e[t][0]; if (r != 'inherit' && r != s && r != a) return !1; } return !0; } function i(e) { const t = e.components; const n = t[0].value[0]; const r = t[1].value[0]; const i = t[2].value[0]; const o = t[3].value[0]; return n[0] == r[0] && n[0] == i[0] && n[0] == o[0] ? [n] : n[0] == i[0] && r[0] == o[0] ? [n, r] : r[0] == o[0] ? [n, r, i] : [n, r, i, o]; } const o = e('./clone').shallow; var s = ','; var a = '/'; t.exports = {
      background(e, t, n) { function i(e) { Array.prototype.unshift.apply(l, e.value); } function o(e) { const n = t[e.name]; return n.doubleValues ? n.defaultValue.length == 1 ? e.value[0][0] == n.defaultValue[0] && (!e.value[1] || e.value[1][0] == n.defaultValue[0]) : e.value[0][0] == n.defaultValue[0] && (e.value[1] ? e.value[1][0] : e.value[0][0]) == n.defaultValue[1] : e.value[0][0] == n.defaultValue; } for (var s, u, c = e.components, l = [], p = c.length - 1; p >= 0; p--) { const h = c[p]; const f = o(h); if (h.name == 'background-clip') { const d = c[p - 1]; const m = o(d); u = !(s = h.value[0][0] == d.value[0][0]) && (m && !f || !m && !f || !m && f && h.value[0][0] != d.value[0][0]), s ? i(d) : u && (i(h), i(d)), p--; } else if (h.name == 'background-size') { const g = c[p - 1]; const v = o(g); u = !(s = !v && f) && (v && !f || !v && !f), s ? i(g) : u ? (i(h), l.unshift([a]), i(g)) : g.value.length == 1 && i(g), p--; } else { if (f || t[h.name].multiplexLastOnly && !n) continue; i(h); } } return l.length === 0 && e.value.length == 1 && e.value[0][0] == '0' && l.push(e.value[0]), l.length === 0 && l.push([t[e.name].defaultValue]), r(l) ? [l[0]] : l; }, borderRadius(e, t) { if (e.multiplex) { for (var n = o(e), r = o(e), s = 0; s < 4; s++) { const a = e.components[s]; const u = o(e); u.value = [a.value[0]], n.components.push(u); const c = o(e); c.value = [a.value[1] || a.value[0]], r.components.push(c); } const l = i(n); const p = i(r); return l.length != p.length || l[0][0] != p[0][0] || l.length > 1 && l[1][0] != p[1][0] || l.length > 2 && l[2][0] != p[2][0] || l.length > 3 && l[3][0] != p[3][0] ? l.concat([['/']]).concat(p) : l; } return i(e); }, fourValues: i, multiplex(e) { return function (t, n) { if (!t.multiplex) return e(t, n, !0); let r; let i; let a = 0; const u = []; const c = {}; for (r = 0, i = t.components[0].value.length; r < i; r++)t.components[0].value[r][0] == s && a++; for (r = 0; r <= a; r++) { for (var l = o(t), p = 0, h = t.components.length; p < h; p++) { const f = t.components[p]; const d = o(f); l.components.push(d); for (let m = c[d.name] || 0, g = f.value.length; m < g; m++) { if (f.value[m][0] == s) { c[d.name] = m + 1; break; }d.value.push(f.value[m]); } } const v = e(l, n, r == a); Array.prototype.push.apply(u, v), r < a && u.push([',']); } return u; }; }, withoutDefaults(e, t) { for (var n = e.components, i = [], o = n.length - 1; o >= 0; o--) { const s = n[o]; const a = t[s.name]; s.value[0][0] != a.defaultValue && i.unshift(s.value[0]); } return i.length === 0 && i.push([t[e.name].defaultValue]), r(i) ? [i[0]] : i; },
    };
  }, { './clone': 54 }],
  65: [function (e, t, n) { function r(e) { let t; for (const n in e) { if (void 0 !== t && e[n].important != t) return !0; t = e[n].important; } return !1; } function i(e) { const t = []; for (const n in e) { const r = e[n]; const i = r.all[r.position]; const o = i[0][i[0].length - 1]; Array.isArray(o) && Array.prototype.push.apply(t, o); } return t; } function o(e, t, n, r, o) { let s; const f = a[n]; const d = [[n], [f.defaultValue]]; const m = p(d); m.shorthand = !0, m.dirty = !0, l([m], o, []); for (let g = 0, v = f.components.length; g < v; g++) { const y = t[f.components[g]]; const b = a[y.name].canOverride; if (c(y)) return; if (!h(b, m.components[g], y, o)) return; m.components[g] = u(y), m.important = y.important, s = y.all; } for (const _ in t)t[_].unused = !0; if (r) { const x = i(t); x.length > 0 && d[0].push(x); }m.position = s.length, m.all = s, m.all.push(d), e.push(m); } function s(e, t, n, i, s) { const u = e[t]; for (const c in n) if (void 0 === u || c != u.name) { const l = a[c]; const p = n[c]; l.components.length > Object.keys(p).length ? delete n[c] : r(p) || o(e, p, c, i, s); } } var a = e('./compactable'); var u = e('./clone').deep; var c = e('./has-inherit'); var l = e('./populate-components'); var p = e('./wrap-for-optimizing').single; var h = e('./every-combination'); t.exports = function (e, t, n) { const r = {}; if (!(e.length < 3)) { for (var i = 0, o = e.length; i < o; i++) { const u = e[i]; if (!u.unused && !u.hack && !u.variable) { const c = a[u.name]; if (c && c.componentOf) if (u.shorthand)s(e, i, r, t, n); else { const l = c.componentOf; r[l] = r[l] || {}, r[l][u.name] = u; } } }s(e, i, r, t, n); } }; }, {
    './clone': 54, './compactable': 55, './every-combination': 56, './has-inherit': 57, './populate-components': 61, './wrap-for-optimizing': 68,
  }],
  66: [function (e, t, n) { function r(e) { const t = `(\\-?\\.?\\d+\\.?\\d*(${s.slice(0).filter(t => !(t in e.units) || !0 === e.units[t]).join('|')}|)|auto|inherit)`; this.compatibleCssUnitRegex = new RegExp(`^${t}$`, 'i'), this.compatibleCssUnitAnyRegex = new RegExp(`^(none|${o.join('|')}|${t}|${l}|${u}|${c})$`, 'i'), this.colorOpacity = e.colors.opacity; } const i = e('../utils/split'); var o = ['thin', 'thick', 'medium', 'inherit', 'initial']; var s = ['px', '%', 'em', 'in', 'cm', 'mm', 'ex', 'pt', 'pc', 'ch', 'rem', 'vh', 'vm', 'vmin', 'vmax', 'vw']; const a = `(\\-?\\.?\\d+\\.?\\d*(${s.join('|')}|)|auto|inherit)`; var u = '[A-Z]+(\\-|[A-Z]|[0-9])+\\(.*?\\)'; var c = '\\-(\\-|[A-Z]|[0-9])+\\(.*?\\)'; var l = 'var\\(\\-\\-[^\\)]+\\)'; const p = `(${l}|${u}|${c})`; const h = `(${a}|(\\-moz\\-|\\-webkit\\-)?calc\\([^\\)]+\\))`; const f = `(none|${o.join('|')}|${a}|${l}|${u}|${c})`; const d = new RegExp(`^${u}$`, 'i'); const m = new RegExp(`^${c}$`, 'i'); const g = new RegExp(`^${l}$`, 'i'); const v = new RegExp(`^${p}$`, 'i'); const y = new RegExp(`^${a}$`, 'i'); const b = new RegExp(`^${h}$`, 'i'); const _ = new RegExp(`^${f}$`, 'i'); const x = ['repeat', 'no-repeat', 'repeat-x', 'repeat-y', 'inherit']; const w = ['inherit', 'scroll', 'fixed', 'local']; const k = ['center', 'top', 'bottom', 'left', 'right']; const E = ['contain', 'cover']; const A = ['border-box', 'content-box', 'padding-box']; const C = ['auto', 'inherit', 'hidden', 'none', 'dotted', 'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset']; const S = ['armenian', 'circle', 'cjk-ideographic', 'decimal', 'decimal-leading-zero', 'disc', 'georgian', 'hebrew', 'hiragana', 'hiragana-iroha', 'inherit', 'katakana', 'katakana-iroha', 'lower-alpha', 'lower-greek', 'lower-latin', 'lower-roman', 'none', 'square', 'upper-alpha', 'upper-latin', 'upper-roman']; const T = ['inside', 'outside', 'inherit']; r.prototype.isValidHexColor = function (e) { return (e.length === 4 || e.length === 7) && e[0] === '#'; }, r.prototype.isValidRgbaColor = function (e) { return (e = e.split(' ').join('')).length > 0 && e.indexOf('rgba(') === 0 && e.indexOf(')') === e.length - 1; }, r.prototype.isValidHslaColor = function (e) { return (e = e.split(' ').join('')).length > 0 && e.indexOf('hsla(') === 0 && e.indexOf(')') === e.length - 1; }, r.prototype.isValidNamedColor = function (e) { return e !== 'auto' && (e === 'transparent' || e === 'inherit' || /^[a-zA-Z]+$/.test(e)); }, r.prototype.isValidVariable = function (e) { return g.test(e); }, r.prototype.isValidColor = function (e) { return this.isValidNamedColor(e) || this.isValidColorValue(e) || this.isValidVariable(e) || this.isValidVendorPrefixedValue(e); }, r.prototype.isValidColorValue = function (e) { return this.isValidHexColor(e) || this.isValidRgbaColor(e) || this.isValidHslaColor(e); }, r.prototype.isValidUrl = function (e) { return e.indexOf('__ESCAPED_URL_CLEAN_CSS') === 0; }, r.prototype.isValidUnit = function (e) { return _.test(e); }, r.prototype.isValidUnitWithoutFunction = function (e) { return y.test(e); }, r.prototype.isValidAndCompatibleUnit = function (e) { return this.compatibleCssUnitAnyRegex.test(e); }, r.prototype.isValidAndCompatibleUnitWithoutFunction = function (e) { return this.compatibleCssUnitRegex.test(e); }, r.prototype.isValidFunctionWithoutVendorPrefix = function (e) { return d.test(e); }, r.prototype.isValidFunctionWithVendorPrefix = function (e) { return m.test(e); }, r.prototype.isValidFunction = function (e) { return v.test(e); }, r.prototype.isValidBackgroundRepeat = function (e) { return x.indexOf(e) >= 0 || this.isValidVariable(e); }, r.prototype.isValidBackgroundAttachment = function (e) { return w.indexOf(e) >= 0 || this.isValidVariable(e); }, r.prototype.isValidBackgroundBox = function (e) { return A.indexOf(e) >= 0 || this.isValidVariable(e); }, r.prototype.isValidBackgroundPositionPart = function (e) { return k.indexOf(e) >= 0 || b.test(e) || this.isValidVariable(e); }, r.prototype.isValidBackgroundPosition = function (e) { if (e === 'inherit') return !0; for (let t = e.split(' '), n = 0, r = t.length; n < r; n++) if (t[n] !== '' && !this.isValidBackgroundPositionPart(t[n]) && !this.isValidVariable(t[n])) return !1; return !0; }, r.prototype.isValidBackgroundSizePart = function (e) { return E.indexOf(e) >= 0 || y.test(e) || this.isValidVariable(e); }, r.prototype.isValidBackgroundPositionAndSize = function (e) { if (e.indexOf('/') < 0) return !1; const t = i(e, '/'); return this.isValidBackgroundSizePart(t.pop()) && this.isValidBackgroundPositionPart(t.pop()); }, r.prototype.isValidListStyleType = function (e) { return S.indexOf(e) >= 0 || this.isValidVariable(e); }, r.prototype.isValidListStylePosition = function (e) { return T.indexOf(e) >= 0 || this.isValidVariable(e); }, r.prototype.isValidStyle = function (e) { return this.isValidStyleKeyword(e) || this.isValidVariable(e); }, r.prototype.isValidStyleKeyword = function (e) { return C.indexOf(e) >= 0; }, r.prototype.isValidWidth = function (e) { return this.isValidUnit(e) || this.isValidWidthKeyword(e) || this.isValidVariable(e); }, r.prototype.isValidWidthKeyword = function (e) { return o.indexOf(e) >= 0; }, r.prototype.isValidVendorPrefixedValue = function (e) { return /^-([A-Za-z0-9]|-)*$/gi.test(e); }, r.prototype.areSameFunction = function (e, t) { return !(!this.isValidFunction(e) || !this.isValidFunction(t)) && e.substring(0, e.indexOf('(')) === t.substring(0, t.indexOf('(')); }, t.exports = r; }, { '../utils/split': 106 }],
  67: [function (e, t, n) { function r(e) { for (var t = [], n = 0, r = e.length; n < r; n++) for (let o = e[n], s = 0, a = o.value.length; s < a; s++) { const u = i.exec(o.value[s][0]); u && t.indexOf(u[0]) == -1 && t.push(u[0]); } return t; } var i = /$\-moz\-|\-ms\-|\-o\-|\-webkit\-/; t.exports = { same(e, t) { return r(e).sort().join(',') == r(t).sort().join(','); } }; }, {}],
  68: [function (e, t, n) {
    function r(e) { for (let t = 1, n = e.length; t < n; t++) if (e[t][0] == ',' || e[t][0] == '/') return !0; return !1; } function i(e) { let t = !1; const n = e[0][0]; const r = e[e.length - 1]; return n[0] == d ? t = 'underscore' : n[0] == f ? t = 'star' : r[0][0] != m || r[0].match(p) ? r[0].indexOf(m) > 0 && !r[0].match(p) ? t = 'bang' : r[0].indexOf(l) > 0 && r[0].indexOf(l) == r[0].length - l.length - 1 ? t = 'backslash' : r[0].indexOf(l) === 0 && r[0].length == 2 && (t = 'backslash') : t = 'bang', t; } function o(e) { if (e.length > 1) { const t = e[e.length - 1][0]; if (typeof t === 'string') return h.test(t); } return !1; } function s(e) { e.length > 0 && (e[e.length - 1][0] = e[e.length - 1][0].replace(h, '')); } function a(e) { e[0][0] = e[0][0].substring(1); } function u(e, t) { const n = e[e.length - 1]; n[0] = n[0].substring(0, n[0].indexOf(t == 'backslash' ? l : m)).trim(), n[0].length === 0 && e.pop(); } function c(e) {
      const t = o(e); t && s(e); const n = i(e); n == 'star' || n == 'underscore' ? a(e) : n != 'backslash' && n != 'bang' || u(e, n); const c = e[0][0].indexOf('--') === 0; return {
        block: c && e[1] && Array.isArray(e[1][0][0]), components: [], dirty: !1, hack: n, important: t, name: e[0][0], multiplex: e.length > 2 && r(e), position: 0, shorthand: !1, unused: e.length < 2, value: e.slice(1), variable: c,
      };
    } var l = '\\'; var p = new RegExp('important$', 'i'); var h = new RegExp('!important$', 'i'); var f = '*'; var d = '_'; var m = '!'; t.exports = { all(e) { for (var t = [], n = e.length - 1; n >= 0; n--) if (typeof e[n][0] !== 'string') { const r = c(e[n]); r.all = e, r.position = n, t.unshift(r); } return t; }, single: c };
  }, {}],
  69: [function (e, t, n) { function r(e) { for (let t = 0, n = e.length; t < n; t++) { const i = e[t]; let o = !1; switch (i[0]) { case 'selector': o = i[1].length === 0 || i[2].length === 0; break; case 'block': r(i[2]), o = i[2].length === 0; }o && (e.splice(t, 1), t--, n--); } } function i(e, t, n) { for (let r = 0, i = e.length; r < i; r++) { const o = e[r]; if (o[0] == 'block') { const a = /@(-moz-|-o-|-webkit-)?keyframes/.test(o[1][0]); s(o[2], t, n, !a); } } } function o(e, t, n) { for (let r = 0, i = e.length; r < i; r++) { const s = e[r]; switch (s[0]) { case 'selector': a(s[1], s[2], !1, !0, t, n); break; case 'block': o(s[2], t, n); } } } function s(e, t, n, a) { if (i(e, t, n), o(e, t, n), u(e), c(e, t, n), l(e, t, n), p(e, t, n), h(e, t), t.restructuring && a && (f(e, t), c(e, t, n)), t.mediaMerging) { d(e); for (let g = m(e), v = g.length - 1; v >= 0; v--)s(g[v][2], t, n, !1); }r(e); } var a = e('../properties/optimizer'); var u = e('./remove-duplicates'); var c = e('./merge-adjacent'); var l = e('./reduce-non-adjacent'); var p = e('./merge-non-adjacent-by-selector'); var h = e('./merge-non-adjacent-by-body'); var f = e('./restructure'); var d = e('./remove-duplicate-media-queries'); var m = e('./merge-media-queries'); t.exports = s; }, {
    '../properties/optimizer': 59, './merge-adjacent': 73, './merge-media-queries': 74, './merge-non-adjacent-by-body': 75, './merge-non-adjacent-by-selector': 76, './reduce-non-adjacent': 77, './remove-duplicate-media-queries': 78, './remove-duplicates': 79, './restructure': 81,
  }],
  70: [function (e, t, n) {
    function r(e, t) { return `[${t.replace(/ /g, '')}]`; } function i(e, t) { return e[0] > t[0] ? 1 : -1; } function o(e, t, n, r) { return t && n && r.length ? `${t + n} ` : t && n ? t + n : n; } const s = {
      selectors(e, t, n) { for (var s = [], a = [], u = 0, c = e.length; u < c; u++) { const l = e[u]; let p = l[0].replace(/\s+/g, ' ').replace(/ ?, ?/g, ',').replace(/\s*(\\)?([>+~])(\s*)/g, o).trim(); n && p.indexOf('nav') > 0 && (p = p.replace(/\+nav(\S|$)/, '+ nav$1')), (!t || p.indexOf('*+html ') == -1 && p.indexOf('*:first-child+html ') == -1) && (p.indexOf('*') > -1 && (p = p.replace(/\*([:#\.\[])/g, '$1').replace(/^(\:first\-child)?\+html/, '*$1+html')), p.indexOf('[') > -1 && (p = p.replace(/\[([^\]]+)\]/g, r)), a.indexOf(p) == -1 && (l[0] = p, a.push(p), s.push(l))); } return s.sort(i); }, selectorDuplicates(e) { for (var t = [], n = [], r = 0, o = e.length; r < o; r++) { const s = e[r]; n.indexOf(s[0]) == -1 && (n.push(s[0]), t.push(s)); } return t.sort(i); }, block(e, t) { e[0] = e[0].replace(/\s+/g, ' ').replace(/(,|:|\() /g, '$1').replace(/ \)/g, ')'), t || (e[0] = e[0].replace(/\) /g, ')')); }, atRule(e) { e[0] = e[0].replace(/\s+/g, ' ').trim(); },
    }; t.exports = s;
  }, {}],
  71: [function (e, t, n) { function r(e) { let t = []; if (e[0] == 'selector') for (let n = !/[\.\+>~]/.test(o(e[1])), u = 0, c = e[2].length; u < c; u++) { const l = e[2][u]; if (l.indexOf('__ESCAPED') !== 0 && l[0] != a) { const p = e[2][u][0][0]; if (p.length !== 0 && p.indexOf('--') !== 0) { const h = s(e[2], u); t.push([p, h, i(p), e[2][u], `${p}:${h}`, e[1], n]); } } } else if (e[0] == 'block') for (let f = 0, d = e[2].length; f < d; f++)t = t.concat(r(e[2][f])); return t; } function i(e) { return e == 'list-style' ? e : e.indexOf('-radius') > 0 ? 'border-radius' : e == 'border-collapse' || e == 'border-spacing' || e == 'border-image' ? e : e.indexOf('border-') === 0 && /^border\-\w+\-\w+$/.test(e) ? e.match(/border\-\w+/)[0] : e.indexOf('border-') === 0 && /^border\-\w+$/.test(e) ? 'border' : e.indexOf('text-') === 0 ? e : e.replace(/^\-\w+\-/, '').match(/([a-zA-Z]+)/)[0].toLowerCase(); } var o = e('../stringifier/one-time').selectors; var s = e('../stringifier/one-time').value; var a = 'at-rule'; t.exports = r; }, { '../stringifier/one-time': 85 }],
  72: [function (e, t, n) { t.exports = function (e, t) { return e.compatibility.selectors.special.test(t); }; }, {}],
  73: [function (e, t, n) { const r = e('../properties/optimizer'); const i = e('../stringifier/one-time').body; const o = e('../stringifier/one-time').selectors; const s = e('./clean-up').selectors; const a = e('./is-special'); t.exports = function (e, t, n) { for (let u = [null, [], []], c = t.compatibility.selectors.adjacentSpace, l = 0, p = e.length; l < p; l++) { const h = e[l]; if (h[0] == 'selector') if (u[0] == 'selector' && o(h[1]) == o(u[1])) { const f = [u[2].length]; Array.prototype.push.apply(u[2], h[2]), r(h[1], u[2], f, !0, t, n), h[2] = []; } else u[0] != 'selector' || i(h[2]) != i(u[2]) || a(t, o(h[1])) || a(t, o(u[1])) ? u = h : (u[1] = s(u[1].concat(h[1]), !1, c), h[2] = []); else u = [null, [], []]; } }; }, {
    '../properties/optimizer': 59, '../stringifier/one-time': 85, './clean-up': 70, './is-special': 72,
  }],
  74: [function (e, t, n) { const r = e('./reorderable').canReorder; const i = e('./extractor'); t.exports = function (e) { for (var t = {}, n = [], o = e.length - 1; o >= 0; o--) { const s = e[o]; if (s[0] == 'block') { let a = t[s[1][0]]; a || (a = [], t[s[1][0]] = a), a.push(o); } } for (const u in t) { const c = t[u]; e:for (let l = c.length - 1; l > 0; l--) { const p = c[l]; const h = e[p]; const f = c[l - 1]; const d = e[f]; t:for (let m = 1; m >= -1; m -= 2) { for (var g = m == 1, v = g ? p + 1 : f - 1, y = g ? f : p, b = g ? 1 : -1, _ = g ? h : d, x = g ? d : h, w = i(_); v != y;) { const k = i(e[v]); if (v += b, !r(w, k)) continue t; }x[2] = g ? _[2].concat(x[2]) : x[2].concat(_[2]), _[2] = [], n.push(x); continue e; } } } return n; }; }, { './extractor': 71, './reorderable': 80 }],
  75: [function (e, t, n) { function r(e) { return /\.|\*| :/.test(e); } function i(e) { const t = u(e[1]); return t.indexOf('__') > -1 || t.indexOf('--') > -1; } function o(e) { return e.replace(/--[^ ,>\+~:]+/g, ''); } function s(e, t) { const n = o(u(e[1])); for (const r in t) { const i = t[r]; const s = o(u(i[1])); (s.indexOf(n) > -1 || n.indexOf(s) > -1) && delete t[r]; } } const a = e('../stringifier/one-time').body; var u = e('../stringifier/one-time').selectors; const c = e('./clean-up').selectors; const l = e('./is-special'); t.exports = function (e, t) { for (let n = {}, o = t.compatibility.selectors.adjacentSpace, p = e.length - 1; p >= 0; p--) { const h = e[p]; if (h[0] == 'selector') { h[2].length > 0 && !t.semanticMerging && r(u(h[1])) && (n = {}), h[2].length > 0 && t.semanticMerging && i(h) && s(h, n); const f = a(h[2]); const d = n[f]; !d || l(t, u(h[1])) || l(t, u(d[1])) || (h[1] = h[2].length > 0 ? c(d[1].concat(h[1]), !1, o) : d[1].concat(h[1]), d[2] = [], n[f] = null), n[a(h[2])] = h; } } }; }, { '../stringifier/one-time': 85, './clean-up': 70, './is-special': 72 }],
  76: [function (e, t, n) { const r = e('../properties/optimizer'); const i = e('../stringifier/one-time').selectors; const o = e('./extractor'); const s = e('./reorderable').canReorder; t.exports = function (e, t, n) { let a; const u = {}; const c = []; for (a = e.length - 1; a >= 0; a--) if (e[a][0] == 'selector' && e[a][2].length !== 0) { const l = i(e[a][1]); u[l] = [a].concat(u[l] || []), u[l].length == 2 && c.push(l); } for (a = c.length - 1; a >= 0; a--) { const p = u[c[a]]; e:for (let h = p.length - 1; h > 0; h--) { const f = p[h - 1]; const d = e[f]; const m = p[h]; const g = e[m]; t:for (let v = 1; v >= -1; v -= 2) { for (var y, b = v == 1, _ = b ? f + 1 : m - 1, x = b ? m : f, w = b ? 1 : -1, k = b ? d : g, E = b ? g : d, A = o(k); _ != x;) { const C = o(e[_]); _ += w; const S = b ? s(A, C) : s(C, A); if (!S && !b) continue e; if (!S && b) continue t; }b ? (y = [k[2].length], Array.prototype.push.apply(k[2], E[2]), E[2] = k[2]) : (y = [E[2].length], Array.prototype.push.apply(E[2], k[2])), r(E[1], E[2], y, !0, t, n), k[2] = []; } } } }; }, {
    '../properties/optimizer': 59, '../stringifier/one-time': 85, './extractor': 71, './reorderable': 80,
  }],
  77: [function (e, t, n) {
    function r(e) { for (var t = [], n = 0; n < e.length; n++)t.push([e[n][0]]); return t; } function i(e, t, n, r, i) { for (let o = 0, a = t.length; o < a; o++) { const u = t[o]; var c = n[u]; s(e, u, c, { filterOut(e, t) { return c[e].isPartial && t.length === 0; }, callback(e, t, n, r) { c[n - r - 1].isPartial || (e[2] = t); } }, r, i); } } function o(e, t, n, r) { const i = {}; e:for (const o in t) { const a = t[o]; if (a[0].isComplex) { const c = a[a.length - 1].where; const p = e[c]; const h = []; const f = l(n, o) ? [o] : a[0].list; i.intoPosition = c, i.reducedBodies = h; for (let d = 0, m = f.length; d < m; d++) { const g = f[d]; const v = t[g]; if (v.length < 2) continue e; if (i.data = v, s(e, g, v, { filterOut(e) { return i.data[e].where < i.intoPosition; }, callback(e, t, n, r) { r === 0 && i.reducedBodies.push(t); } }, n, r), u(h[h.length - 1]) != u(h[0])) continue e; }p[2] = h[0]; } } } function s(e, t, n, r, i, o) { for (var s = [], u = [], c = [], l = [], h = n.length - 1, f = 0; h >= 0; h--) if (!r.filterOut(h, s)) { const d = n[h].where; const m = e[d]; const g = p(m[2]); s = s.concat(g), u.push(g), l.push(d); } for (h = 0, f = u.length; h < f; h++)u[h].length > 0 && c.push((c.length > 0 ? c[c.length - 1] : 0) + u[h].length); a(t, s, c, !1, i, o); for (let v = l.length, y = s.length - 1, b = v - 1; b >= 0;) if ((b === 0 || s[y] && u[b].indexOf(s[y]) > -1) && y > -1)y--; else { const _ = s.splice(y + 1); r.callback(e[l[b]], _, v, b), b--; } } var a = e('../properties/optimizer'); var u = e('../stringifier/one-time').body; const c = e('../stringifier/one-time').selectors; var l = e('./is-special'); var p = e('../utils/clone-array'); t.exports = function (e, t, n) {
      for (var s = {}, a = [], u = e.length - 1; u >= 0; u--) {
        const p = e[u]; if (p[0] == 'selector' && p[2].length !== 0) {
          for (let h = c(p[1]), f = p[1].length > 1 && !l(t, h), d = t.sourceMap ? r(p[1]) : p[1], m = f ? [h].concat(d) : [h], g = 0, v = m.length; g < v; g++) {
            const y = m[g]; s[y] ? a.push(y) : s[y] = [], s[y].push({
              where: u, list: d, isPartial: f && g > 0, isComplex: f && g === 0,
            });
          }
        }
      }i(e, a, s, t, n), o(e, s, t, n);
    };
  }, {
    '../properties/optimizer': 59, '../stringifier/one-time': 85, '../utils/clone-array': 99, './is-special': 72,
  }],
  78: [function (e, t, n) { const r = e('../stringifier/one-time').all; t.exports = function (e) { for (let t = {}, n = 0, i = e.length; n < i; n++) { const o = e[n]; if (o[0] == 'block') { const s = `${o[1][0]}%${r(o[2])}`; const a = t[s]; a && (a[2] = []), t[s] = o; } } }; }, { '../stringifier/one-time': 85 }],
  79: [function (e, t, n) { const r = e('../stringifier/one-time').body; const i = e('../stringifier/one-time').selectors; t.exports = function (e) { for (var t, n, o, s, a = {}, u = [], c = 0, l = e.length; c < l; c++)(n = e[c])[0] == 'selector' && (a[t = i(n[1])] && a[t].length == 1 ? u.push(t) : a[t] = a[t] || [], a[t].push(c)); for (c = 0, l = u.length; c < l; c++) { s = []; for (let p = a[t = u[c]].length - 1; p >= 0; p--)n = e[a[t][p]], o = r(n[2]), s.indexOf(o) > -1 ? n[2] = [] : s.push(o); } }; }, { '../stringifier/one-time': 85 }],
  80: [function (e, t, n) { function r(e, t) { const n = e[0]; const r = e[1]; const d = e[2]; const m = e[5]; const g = e[6]; const v = t[0]; const y = t[1]; const b = t[2]; const _ = t[5]; const x = t[6]; return !(n == 'font' && v == 'line-height' || v == 'font' && n == 'line-height') && ((!h.test(n) || !h.test(v)) && (!(d == b && o(n) == o(v) && i(n) ^ i(v)) && ((d != 'border' || !f.test(b) || !(n == 'border' || n == b || r != y && s(n, v))) && ((b != 'border' || !f.test(d) || !(v == 'border' || v == d || r != y && s(n, v))) && ((d != 'border' || b != 'border' || n == v || !(a(n) && u(v) || u(n) && a(v))) && (d != b || (!(n != v || d != b || r != y && !c(r, y)) || (n != v && d == b && n != d && v != b || (n != v && d == b && r == y || !(!x || !g || p(d) || p(b) || !l(_, m))))))))))); } function i(e) { return /^\-(?:moz|webkit|ms|o)\-/.test(e); } function o(e) { return e.replace(/^\-(?:moz|webkit|ms|o)\-/, ''); } function s(e, t) { return e.split('-').pop() == t.split('-').pop(); } function a(e) { return e == 'border-top' || e == 'border-right' || e == 'border-bottom' || e == 'border-left'; } function u(e) { return e == 'border-color' || e == 'border-style' || e == 'border-width'; } function c(e, t) { return i(e) && i(t) && e.split('-')[1] != t.split('-')[2]; } function l(e, t) { for (let n = 0, r = e.length; n < r; n++) for (let i = 0, o = t.length; i < o; i++) if (e[n][0] == t[i][0]) return !1; return !0; } function p(e) { return e == 'font' || e == 'line-height' || e == 'list-style'; } var h = /align\-items|box\-align|box\-pack|flex|justify/; var f = /^border\-(top|right|bottom|left|color|style|width|radius)/; t.exports = { canReorder(e, t) { for (let n = t.length - 1; n >= 0; n--) for (let i = e.length - 1; i >= 0; i--) if (!r(e[i], t[n])) return !1; return !0; }, canReorderSingle: r }; }, {}],
  81: [function (e, t, n) { function r(e, t) { return e > t; } function i(e, t) { const n = p(e); return n[5] = n[5].concat(t[5]), n; } const o = e('./extractor'); const s = e('./reorderable').canReorderSingle; const a = e('../stringifier/one-time').body; const u = e('../stringifier/one-time').selectors; const c = e('./clean-up').selectorDuplicates; const l = e('./is-special'); var p = e('../utils/clone-array'); t.exports = function (e, t) { function n(e, t, n) { for (let r = n.length - 1; r >= 0; r--) { const i = p(t, n[r][0]); if (C[i].length > 1 && k(e, C[i])) { h(i); break; } } } function p(e, t) { const n = f(t); return C[n] = C[n] || [], C[n].push([e, t]), n; } function h(e) { let t; const n = e.split(O); const r = []; for (const i in C) { const o = i.split(O); for (t = o.length - 1; t >= 0; t--) if (n.indexOf(o[t]) > -1) { r.push(i); break; } } for (t = r.length - 1; t >= 0; t--) delete C[r[t]]; } function f(e) { for (var t = [], n = 0, r = e.length; n < r; n++)t.push(u(e[n][1])); return t.join(O); } function d(e) { for (var n = [], r = [], i = e.length - 1; i >= 0; i--)l(t, u(e[i][1])) || (r.unshift(e[i]), e[i][2].length > 0 && n.indexOf(e[i]) == -1 && n.push(e[i])); return n.length > 1 ? r : []; } function m(e, t) { const r = t[0]; const i = t[1]; const o = t[4]; const s = r.length + i.length + 1; let a = []; const u = []; const l = d(E[o]); if (!(l.length < 2)) { const p = v(l, s, 1); const h = p[0]; if (h[1] > 0) return n(e, t, p); for (let f = h[0].length - 1; f >= 0; f--)a = h[0][f][1].concat(a), u.unshift(h[0][f]); _(e, [t], a = c(a), u); } } function g(e, t) { return e[1] > t[1]; } function v(e, t, n) { return y(e, t, n, T - 1).sort(g); } function y(e, t, n, r) { let i = [[e, b(e, t, n)]]; if (e.length > 2 && r > 0) for (let o = e.length - 1; o >= 0; o--) { const s = Array.prototype.slice.call(e, 0); s.splice(o, 1), i = i.concat(y(s, t, n, r - 1)); } return i; } function b(e, t, n) { for (var r = 0, i = e.length - 1; i >= 0; i--)r += e[i][2].length > n ? u(e[i][1]).length : -1; return r - (e.length - 1) * t + 1; } function _(t, n, r, i) { let o; let s; let u; let c; const l = []; for (o = i.length - 1; o >= 0; o--) { const p = i[o]; for (s = p[2].length - 1; s >= 0; s--) { const h = p[2][s]; for (u = 0, c = n.length; u < c; u++) { const f = n[u]; const d = h[0][0]; const m = f[0]; const g = f[4]; if (d == m && a([h]) == g) { p[2].splice(s, 1); break; } } } } for (o = n.length - 1; o >= 0; o--)l.unshift(n[o][3]); const v = ['selector', r, l]; e.splice(t, 0, v); } function x(e, t) { const n = t[4]; const r = E[n]; r && r.length > 1 && (w(e, t) || m(e, t)); } function w(e, t) { let n; let r; const i = []; const o = []; const s = t[4]; const a = d(E[s]); if (!(a.length < 2)) { e:for (const u in E) { const c = E[u]; for (n = a.length - 1; n >= 0; n--) if (c.indexOf(a[n]) == -1) continue e; i.push(u); } if (i.length < 2) return !1; for (n = i.length - 1; n >= 0; n--) for (r = A.length - 1; r >= 0; r--) if (A[r][4] == i[n]) { o.unshift([A[r], a]); break; } return k(e, o); } } function k(e, t) { for (var n, r = 0, i = [], o = t.length - 1; o >= 0; o--)r += (n = t[o][0])[4].length + (o > 0 ? 1 : 0), i.push(n); const s = v(t[0][1], r, i.length)[0]; if (s[1] > 0) return !1; let a = []; const u = []; for (o = s[0].length - 1; o >= 0; o--)a = s[0][o][1].concat(a), u.unshift(s[0][o]); for (_(e, i, a = c(a), u), o = i.length - 1; o >= 0; o--) { n = i[o]; const l = A.indexOf(n); delete E[n[4]], l > -1 && S.indexOf(l) == -1 && S.push(l); } return !0; } for (var E = {}, A = [], C = {}, S = [], T = 2, O = '%', F = e.length - 1; F >= 0; F--) { var B; var D; var L; var N; var M; const R = e[F]; if (R[0] == 'selector')B = !0; else { if (R[0] != 'block') continue; B = !1; } const P = A.length; const I = o(R); S = []; const j = []; for (D = I.length - 1; D >= 0; D--) for (L = D - 1; L >= 0; L--) if (!s(I[D], I[L])) { j.push(D); break; } for (D = I.length - 1; D >= 0; D--) { const V = I[D]; let z = !1; for (L = 0; L < P; L++) { const U = A[L]; S.indexOf(L) != -1 || s(V, U) || (function (e, t, n) { if (e[0] != t[0]) return !1; const r = t[4]; const i = E[r]; return i && i.indexOf(n) > -1; }(V, U, R)) || (x(F + 1, U), S.indexOf(L) == -1 && (S.push(L), delete E[U[4]])), z || (z = V[0] == U[0] && V[1] == U[1]) && (M = L); } if (B && !(j.indexOf(D) > -1)) { const $ = V[4]; E[$] = E[$] || [], E[$].push(R), z ? A[M] = i(A[M], V) : A.push(V); } } for (D = 0, N = (S = S.sort(r)).length; D < N; D++) { const q = S[D] - D; A.splice(q, 1); } } for (var H = e[0] && e[0][0] == 'at-rule' && e[0][1][0].indexOf('@charset') === 0 ? 1 : 0; H < e.length - 1; H++) { const W = e[H][0] === 'at-rule' && e[H][1][0].indexOf('@import') === 0; const G = e[H][0] === 'text' && e[H][1][0].indexOf('__ESCAPED_COMMENT_SPECIAL') === 0; if (!W && !G) break; } for (F = 0; F < A.length; F++)x(H, A[F]); }; }, {
    '../stringifier/one-time': 85, '../utils/clone-array': 99, './clean-up': 70, './extractor': 71, './is-special': 72, './reorderable': 80,
  }],
  82: [function (e, t, n) {
    function r(e, t) { return e.value[t] && e.value[t][0][0] == '-' && parseFloat(e.value[t][0]) < 0; } function i(e, t) {
      return t.indexOf('0') == -1 ? t : (t.indexOf('-') > -1 && (t = t.replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, '$10$2').replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, '$10$2')), t.replace(/(^|\s)0+([1-9])/g, '$1$2').replace(/(^|\D)\.0+(\D|$)/g, '$10$2').replace(/(^|\D)\.0+(\D|$)/g, '$10$2').replace(/\.([1-9]*)0+(\D|$)/g, (e, t, n) => (t.length > 0 ? '.' : '') + t + n)
        .replace(/(^|\D)0\.(\d)/g, '$1.$2'));
    } function o(e, t) { return t.indexOf('0deg') == -1 ? t : t.replace(/\(0deg\)/g, '(0)'); } function s(e, t) { return e.indexOf('filter') > -1 || t.indexOf(' ') == -1 ? t : ((t = t.replace(/\s+/g, ' ')).indexOf('calc') > -1 && (t = t.replace(/\) ?\/ ?/g, ')/ ')), t.replace(/\( /g, '(').replace(/ \)/g, ')').replace(/, /g, ',')); } function a(e, t, n) { return n.value === -1 || t.indexOf('.') === -1 ? t : t.replace(n.regexp, (e, t) => `${Math.round(parseFloat(t) * n.multiplier) / n.multiplier}px`).replace(/(\d)\.($|\D)/g, '$1$2'); } function u(e, t, n) { return /^(?:\-moz\-calc|\-webkit\-calc|calc)\(/.test(t) ? t : e == 'flex' || e == '-ms-flex' || e == '-webkit-flex' || e == 'flex-basis' || e == '-webkit-flex-basis' ? t : t.indexOf('%') > 0 && (e == 'height' || e == 'max-height' || e == 'width' || e == 'max-width') ? t : t.replace(n, '$10$2').replace(n, '$10$2'); } function c(e) { let t; const n = e.value; n.length == 4 && n[0][0] === '0' && n[1][0] === '0' && n[2][0] === '0' && n[3][0] === '0' && (t = e.name.indexOf('box-shadow') > -1 ? 2 : 1), t && (e.value.splice(t), e.dirty = !0); } function l(e, t, n) { return t.indexOf('#') === -1 && t.indexOf('rgb') == -1 && t.indexOf('hsl') == -1 ? S.shorten(t) : (t = t.replace(/rgb\((\-?\d+),(\-?\d+),(\-?\d+)\)/g, (e, t, n, r) => new A(t, n, r).toHex()).replace(/hsl\((-?\d+),(-?\d+)%?,(-?\d+)%?\)/g, (e, t, n, r) => new C(t, n, r).toHex()).replace(/(^|[^='"])#([0-9a-f]{6})/gi, (e, t, n) => (n[0] == n[1] && n[2] == n[3] && n[4] == n[5] ? `${t}#${n[0]}${n[2]}${n[4]}` : `${t}#${n}`)).replace(/(rgb|rgba|hsl|hsla)\(([^\)]+)\)/g, (e, t, n) => { const r = n.split(','); return t == 'hsl' && r.length == 3 || t == 'hsla' && r.length == 4 || t == 'rgb' && r.length == 3 && n.indexOf('%') > 0 || t == 'rgba' && r.length == 4 && n.indexOf('%') > 0 ? (r[1].indexOf('%') == -1 && (r[1] += '%'), r[2].indexOf('%') == -1 && (r[2] += '%'), `${t}(${r.join(',')})`) : e; }), n.colors.opacity && e.indexOf('background') == -1 && (t = t.replace(/(?:rgba|hsla)\(0,0%?,0%?,0\)/g, e => (E(t, ',').pop().indexOf('gradient(') > -1 ? e : 'transparent'))), S.shorten(t)); } function p(e, t, n) { return I.test(t) ? t.replace(I, (e, t) => { let r; const i = parseInt(t); return i === 0 ? e : (n.properties.shorterLengthUnits && n.units.pt && 3 * i % 4 == 0 && (r = `${3 * i / 4}pt`), n.properties.shorterLengthUnits && n.units.pc && i % 16 == 0 && (r = `${i / 16}pc`), n.properties.shorterLengthUnits && n.units.in && i % 96 == 0 && (r = `${i / 96}in`), r && (r = e.substring(0, e.indexOf(t)) + r), r && r.length < e.length ? r : e); }) : t; } function h(e, t) { return j.test(t) ? t.replace(j, (e, t, n) => { let r; return n == 'ms' ? r = `${parseInt(t) / 1e3}s` : n == 's' && (r = `${1e3 * parseFloat(t)}ms`), r.length < e.length ? r : e; }) : t; } function f(e) { let t; const n = e.value; n.length == 3 && n[1][0] == '/' && n[0][0] == n[2][0] ? t = 1 : n.length == 5 && n[2][0] == '/' && n[0][0] == n[3][0] && n[1][0] == n[4][0] ? t = 2 : n.length == 7 && n[3][0] == '/' && n[0][0] == n[4][0] && n[1][0] == n[5][0] && n[2][0] == n[6][0] ? t = 3 : n.length == 9 && n[4][0] == '/' && n[0][0] == n[5][0] && n[1][0] == n[6][0] && n[2][0] == n[7][0] && n[3][0] == n[8][0] && (t = 4), t && (e.value.splice(t), e.dirty = !0); } function d(e) { e.value.length == 1 && (e.value[0][0] = e.value[0][0].replace(/progid:DXImageTransform\.Microsoft\.(Alpha|Chroma)(\W)/, (e, t, n) => t.toLowerCase() + n)), e.value[0][0] = e.value[0][0].replace(/,(\S)/g, ', $1').replace(/ ?= ?/g, '='); } function m(e) { const t = e.value; if (!(M.indexOf(t[0][0]) > -1 || t[1] && M.indexOf(t[1][0]) > -1 || t[2] && M.indexOf(t[2][0]) > -1) && t[1] != '/') { let n = 0; if (t[0][0] == 'normal' && n++, t[1] && t[1][0] == 'normal' && n++, t[2] && t[2][0] == 'normal' && n++, !(n > 1)) { let r; P.indexOf(t[0][0]) > -1 ? r = 0 : t[1] && P.indexOf(t[1][0]) > -1 ? r = 1 : t[2] && P.indexOf(t[2][0]) > -1 ? r = 2 : R.indexOf(t[0][0]) > -1 ? r = 0 : t[1] && R.indexOf(t[1][0]) > -1 ? r = 1 : t[2] && R.indexOf(t[2][0]) > -1 && (r = 2), void 0 !== r && (e.value[r][0] = V['font-weight'](t[r][0]), e.dirty = !0); } } } function g(e, t) { for (var n, v, y, b = T(e), _ = 0, x = b.length; _ < x; _++) if (n = b[_], v = n.name, n.hack && ((n.hack == 'star' || n.hack == 'underscore') && !t.compatibility.properties.iePrefixHack || n.hack == 'backslash' && !t.compatibility.properties.ieSuffixHack || n.hack == 'bang' && !t.compatibility.properties.ieBangHack) && (n.unused = !0), v.indexOf('padding') === 0 && (r(n, 0) || r(n, 1) || r(n, 2) || r(n, 3)) && (n.unused = !0), !n.unused) if (n.variable)n.block && g(n.value[0], t); else { for (let w = 0, k = n.value.length; w < k; w++)y = n.value[w][0], V[v] && (y = V[v](y, w, k)), y = i(v, y = h(v, y = p(v, y = a(v, y = s(v, y), t.precision), t.compatibility))), t.compatibility.properties.zeroUnits && (y = u(v, y = o(v, y), t.unitsRegexp)), t.compatibility.properties.colors && (y = l(v, y, t.compatibility)), n.value[w][0] = y; c(n), v.indexOf('border') === 0 && v.indexOf('radius') > 0 ? f(n) : v == 'filter' ? d(n) : v == 'font' && m(n); }O(b, !0), F(b); } function v(e) { for (let t = !1, n = 0, r = e.length; n < r; n++) { const i = e[n]; i[0] == 'at-rule' && (L.test(i[1][0]) && (t || i[1][0].indexOf(D) == -1 ? (e.splice(n, 1), n--, r--) : (t = !0, e.splice(n, 1), e.unshift(['at-rule', [i[1][0].replace(L, D)]])))); } } function y(e) { const t = ['px', 'em', 'ex', 'cm', 'mm', 'in', 'pt', 'pc', '%']; return ['ch', 'rem', 'vh', 'vm', 'vmax', 'vmin', 'vw'].forEach((n) => { e.compatibility.units[n] && t.push(n); }), new RegExp(`(^|\\s|\\(|,)0(?:${t.join('|')})(\\W|$)`, 'g'); } function b(e) { const t = {}; return t.value = void 0 === e.roundingPrecision ? B : e.roundingPrecision, t.multiplier = Math.pow(10, t.value), t.regexp = new RegExp(`(\\d*\\.\\d{${t.value + 1},})px`, 'g'), t; } function _(e, t, n) { const r = t.compatibility.selectors.ie7Hack; const i = t.compatibility.selectors.adjacentSpace; const o = t.compatibility.properties.spaceAfterClosingBrace; let s = !1; let a = !1; t.unitsRegexp = y(t), t.precision = b(t); for (let u = 0, c = e.length; u < c; u++) { const l = e[u]; switch (l[0]) { case 'selector': l[1] = x(l[1], !r, i), g(l[2], t), a = !0; break; case 'block': w(l[1], o), _(l[2], t, n), a = !0; break; case 'flat-block': w(l[1], o), g(l[2], t), a = !0; break; case 'at-rule': k(l[1]), s = !0; }l[0] == 'at-rule' && N.test(l[1]) && a && (n.warnings.push(`Ignoring @import rule "${l[1]}" as it appears after rules thus browsers will ignore them.`), l[1] = ''), (l[1].length === 0 || l[2] && l[2].length === 0) && (e.splice(u, 1), u--, c--); }s && v(e); } var x = e('./clean-up').selectors; var w = e('./clean-up').block; var k = e('./clean-up').atRule; var E = e('../utils/split'); var A = e('../colors/rgb'); var C = e('../colors/hsl'); var S = e('../colors/hex-name-shortener'); var T = e('../properties/wrap-for-optimizing').all; var O = e('../properties/restore-from-optimizing'); var F = e('../properties/remove-unused'); var B = 2; var D = '@charset'; var L = new RegExp(`^${D}`, 'i'); var N = /^@import["'\s]/i; var M = ['100', '200', '300', '400', '500', '600', '700', '800', '900']; var R = ['normal', 'bold', 'bolder', 'lighter']; var P = ['bold', 'bolder', 'lighter']; var I = /(?:^|\s|\()(-?\d+)px/; var j = /^(\-?[\d\.]+)(m?s)$/; var V = { background(e, t, n) { return t !== 0 || n != 1 || e != 'none' && e != 'transparent' ? e : '0 0'; }, 'font-weight': function (e) { return e == 'normal' ? '400' : e == 'bold' ? '700' : e; }, outline(e, t, n) { return t === 0 && n == 1 && e == 'none' ? '0' : e; } }; t.exports = _;
  }, {
    '../colors/hex-name-shortener': 48, '../colors/hsl': 49, '../colors/rgb': 50, '../properties/remove-unused': 62, '../properties/restore-from-optimizing': 63, '../properties/wrap-for-optimizing': 68, '../utils/split': 106, './clean-up': 70,
  }],
  83: [function (e, t, n) { function r(e, t, n) { if (!n && e.indexOf('\n') == -1) return e.indexOf(a) === 0 ? e : void (t.column += e.length); for (var r = 0, i = e.split('\n'), o = i.length, s = 0; ;) { if (r == o - 1) break; const u = i[r]; if (/\S/.test(u)) break; s += u.length + 1, r++; } return t.line += r, t.column = r > 0 ? 0 : t.column, t.column += /^(\s)*/.exec(i[r])[0].length, e.substring(s).trimLeft(); } function i(e, t, n) { const r = e.source || t.source; return r && n.resolvePath ? n.resolvePath(t.source, r) : r; } function o(e, t, n) { const r = { line: t.line, column: t.column, source: t.source }; let o = null; const s = t.sourceMapTracker.isTracking(r.source) ? t.sourceMapTracker.originalPositionFor(r, e, n || 0) : {}; if (r.line = s.line || r.line, r.column = s.column || r.column, r.source = s.sourceResolved ? s.source : i(s, r, t), t.sourceMapInlineSources) { const a = t.sourceMapTracker.sourcesContentFor(t.source); o = a && a[r.source] ? a : t.sourceReader.sourceAt(t.source); } return o ? [r.line, r.column, r.source, o] : [r.line, r.column, r.source]; } function s(e, t) { for (let n = e.split('\n'), r = 0, i = n.length; r < i; r++) { const o = n[r]; let s = 0; for (r > 0 && (t.line++, t.column = 0); ;) { const u = o.indexOf(a, s); if (u == -1) { t.column += o.substring(s).length; break; }t.column += u - s, s += u - s; const c = o.substring(u, o.indexOf('__', u + 1) + 2); const l = c.substring(c.indexOf('(') + 1, c.indexOf(')')).split(','); t.line += ~~l[0], t.column = (~~l[0] == 0 ? t.column : 0) + ~~l[1], s += c.length; } } } var a = '__ESCAPED_'; t.exports = function (e, t, n, i) { const a = r(e, t, n); const u = n ? o(a, t, i) : []; return a && s(a, t), u; }; }, {}],
  84: [function (e, t, n) {
    function r(e, t) { for (let n = t, r = e.length; n < r; n++) if (typeof e[n] !== 'string') return !0; return !1; } function i(e) { return e[0][0] == 'background' || e[0][0] == 'transform' || e[0][0] == 'src'; } function o(e, t) { return e[t][0][e[t][0].length - 1] == ')' || e[t][0].indexOf('__ESCAPED_URL_CLEAN_CSS') === 0; } function s(e, t) { return e[t][0] == ','; } function a(e, t) { return e[t][0] == '/'; } function u(e, t) { return e[t + 1] && e[t + 1][0] == ','; } function c(e, t) { return e[t + 1] && e[t + 1][0] == '/'; } function l(e) { return e[0][0] == 'filter' || e[0][0] == '-ms-filter'; } function p(e, t, n) { return !n.spaceAfterClosingBrace && i(e) && o(e, t) || c(e, t) || a(e, t) || u(e, t) || s(e, t); } function h(e, t) { for (let n = t.store, r = 0, i = e.length; r < i; r++)n(e[r], t), r < i - 1 && n(',', t); } function f(e, t) { for (let n = 0, r = e.length; n < r; n++)d(e, n, n == r - 1, t); } function d(e, t, n, r) { const i = r.store; const o = e[t]; typeof o === 'string' ? i(o, r) : o[0] == _ ? m(o[1], !1, r) : (i(o[0], r), i(':', r), g(e, t, n, r)); } function m(e, t, n) { const r = n.store; r(e, n), t || r(x, n); } function g(e, t, n, i) { const o = i.store; const s = e[t]; const a = s[0][0].indexOf('--') === 0; const u = a && Array.isArray(s[1][0]); if (a && u && v(s[1])) return o('{', i), f(s[1], i), void o('};', i); for (let c = 1, h = s.length; c < h; c++)o(s[c], i), c < h - 1 && (l(s) || !p(s, c, i)) ? o(' ', i) : c == h - 1 && !n && r(e, t + 1) && o(x, i); } function v(e) { for (let t = 0, n = e.length; t < n; t++) if (e[t][0] == _ || Array.isArray(e[t][0])) return !0; return !1; } function y(e, t) { for (let n = t.keepBreaks ? b : '', r = t.store, i = 0, o = e.length; i < o; i++) { const s = e[i]; switch (s[0]) { case 'at-rule': case 'text': r(s[1][0], t), r(n, t); break; case 'block': h([s[1]], t), r('{', t), y(s[2], t), r('}', t), r(n, t); break; case 'flat-block': h([s[1]], t), r('{', t), f(s[2], t), r('}', t), r(n, t); break; default: h(s[1], t), r('{', t), f(s[2], t), r('}', t), r(n, t); } } } var b = e('os').EOL; var _ = 'at-rule'; var x = ';'; t.exports = {
      all: y, body: f, property: d, selectors: h, value: g,
    };
  }, { os: 29 }],
  85: [function (e, t, n) {
    function r(e, t) { t.output.push(typeof e === 'string' ? e : e[0]); } function i() { return { output: [], store: r }; } const o = e('./helpers'); t.exports = {
      all(e) { const t = i(); return o.all(e, t), t.output.join(''); }, body(e) { const t = i(); return o.body(e, t), t.output.join(''); }, property(e, t) { const n = i(); return o.property(e, t, !0, n), n.output.join(''); }, selectors(e) { const t = i(); return o.selectors(e, t), t.output.join(''); }, value(e, t) { const n = i(); return o.value(e, t, !0, n), n.output.join(''); },
    };
  }, { './helpers': 84 }],
  86: [function (e, t, n) {
    function r(e, t) { t.output.push(typeof e === 'string' ? e : e[0]); } const i = e('./helpers').all; t.exports = function (e, t, n) {
      const o = {
        keepBreaks: t.keepBreaks, output: [], spaceAfterClosingBrace: t.compatibility.properties.spaceAfterClosingBrace, store: r,
      }; return i(e, o, !1), { styles: n(o.output.join('')).trim() };
    };
  }, { './helpers': 84 }],
  87: [function (e, t, n) {
    (function (n) {
      function r(e, t) { const n = typeof e === 'string'; let r = n ? e : e[0]; r.indexOf('_') > -1 && (r = t.restore(r, i(t.output))), o(r, n ? null : e, t), t.output.push(r); } function i(e) { for (var t = [], n = e.length - 1; n >= 0; n--) { const r = e[n]; if (t.unshift(r), r == '{' || r == ';') break; } return t.join(''); } function o(e, t, n) { t && s(t, n); const r = e.split('\n'); n.line += r.length - 1, n.column = r.length > 1 ? 0 : n.column + r.pop().length; } function s(e, t) { const n = e[e.length - 1]; if (Array.isArray(n)) for (let r = 0, i = n.length; r < i; r++)a(n[r], t); } function a(e, t) { let n = e[2] || p; l && (n = n.replace(/\\/g, '/')), t.outputMap.addMapping({ generated: { line: t.line, column: t.column }, source: n, original: { line: e[0], column: e[1] } }), e[3] && t.outputMap.setSourceContent(n, e[3][e[2]]); } const u = e('source-map').SourceMapGenerator; const c = e('./helpers').all; var l = n.platform == 'win32'; var p = '$stdin'; t.exports = function (e, t, n, i) {
        const o = {
          column: 0, inputMapTracker: i, keepBreaks: t.keepBreaks, line: 1, output: [], outputMap: new u(), restore: n, sourceMapInlineSources: t.sourceMapInlineSources, spaceAfterClosingBrace: t.compatibility.properties.spaceAfterClosingBrace, store: r,
        }; return c(e, o, !1), { sourceMap: o.outputMap, styles: o.output.join('').trim() };
      };
    }).call(this, e('_process'));
  }, { './helpers': 84, _process: 31, 'source-map': 107 }],
  88: [function (e, t, n) { function r(e, t, n, r) { this.comments = new s('COMMENT'), this.specialComments = new s('COMMENT_SPECIAL'), this.context = e, this.restored = 0, this.keepAll = t == '*', this.keepOne = t == '1' || t === 1, this.keepBreaks = n, this.saveWaypoints = r; } function i(e) { const t = []; return new a(e).each((e, n, r) => { t.push([r, r + e.length]); }), function (e) { for (let n = 0, r = t.length; n < r; n++) if (t[n][0] < e && t[n][1] > e) return !0; return !1; }; } function o(e, t, n, r) { for (var i = [], o = 0; o < t.length;) { const s = n.nextMatch(t, o); if (s.start < 0) break; i.push(t.substring(o, s.start)); const a = n.restore(s.match); r && (e.keepAll || e.keepOne && e.restored === 0) ? (e.restored++, i.push(a), o = s.end) : o = s.end + (e.keepBreaks && t.substring(s.end, s.end + u.length) == u ? u.length : 0); } return i.length > 0 ? i.join('') + t.substring(o, t.length) : t; } var s = e('./escape-store'); var a = e('../utils/quote-scanner'); var u = e('os').EOL; r.prototype.escape = function (e) { for (var t, n, r, o = [], s = 0, a = 0, c = 0, l = 0, p = i(e), h = this.saveWaypoints; a < e.length && (s = e.indexOf('/*', c)) != -1;) if (p(s))o.push(e.substring(c, s + '/*'.length)), c = s + '/*'.length; else { (a = e.indexOf('*/', s + '/*'.length)) == -1 && (this.context.warnings.push(`Broken comment: '${e.substring(s)}'.`), a = e.length - 2), o.push(e.substring(c, s)); const f = e.substring(s, a + '*/'.length); const d = f.indexOf('/*!') === 0; if (h && (t = f.split(u).length - 1, r = (n = f.lastIndexOf(u)) > 0 ? f.substring(n + u.length).length : l + f.length), h || d) { const m = h ? [t, r] : null; const g = d ? this.specialComments.store(f, m) : this.comments.store(f, m); o.push(g); }h && (l = r + 1), c = a + '*/'.length; } return o.length > 0 ? o.join('') + e.substring(c, e.length) : e; }, r.prototype.restore = function (e) { return e = o(this, e, this.comments, !1), e = o(this, e, this.specialComments, !0); }, t.exports = r; }, { '../utils/quote-scanner': 103, './escape-store': 89, os: 29 }],
  89: [function (e, t, n) {
    function r(e) { this.placeholderRoot = `ESCAPED_${e}_CLEAN_CSS`, this.placeholderToData = {}, this.dataToPlaceholder = {}, this.count = 0, this.restoreMatcher = new RegExp(`${this.placeholderRoot}(\\d+)`); }r.prototype._nextPlaceholder = function (e) { return { index: this.count, value: `__${this.placeholderRoot}${this.count++}${e}__` }; }, r.prototype.store = function (e, t) {
      const n = t ? `(${t.join(',')})` : ''; let
        r = this.dataToPlaceholder[e]; if (!r) { const i = this._nextPlaceholder(n); r = i.value, this.placeholderToData[i.index] = e, this.dataToPlaceholder[e] = i.value; } return t && (r = r.replace(/\([^\)]+\)/, n)), r;
    }, r.prototype.nextMatch = function (e, t) { const n = {}; return n.start = e.indexOf(this.placeholderRoot, t) - '__'.length, n.end = e.indexOf('__', n.start + '__'.length) + '__'.length, n.start > -1 && n.end > -1 && (n.match = e.substring(n.start, n.end)), n; }, r.prototype.restore = function (e) { const t = this.restoreMatcher.exec(e)[1]; return this.placeholderToData[t]; }, t.exports = r;
  }, {}],
  90: [function (e, t, n) { function r(e, t) { for (var n = t + s.length, r = 0, i = !1, o = !1; ;) { const c = e[n++]; if (i ? i = c != "'" && c != '"' : (i = c == "'" || c == '"', c == a && r++, c == u && r--, c == l && (o = !0), c != p || o || r != 1 || (n--, r--)), r === 0 && c == u) break; if (!c) { n = e.substring(0, n).lastIndexOf(p); break; } } return n; } function i(e) { this.expressions = new o('EXPRESSION'), this.saveWaypoints = e; } var o = e('./escape-store'); var s = 'expression'; var a = '('; var u = ')'; const c = s + a; var l = '{'; var p = '}'; const h = e('os').EOL; i.prototype.escape = function (e) { for (var t, n, i, o = 0, s = 0, a = 0, u = [], l = 0, p = this.saveWaypoints; s < e.length && (o = e.indexOf(c, s)) != -1;) { s = r(e, o); const f = e.substring(o, s); p && (t = f.split(h).length - 1, i = (n = f.lastIndexOf(h)) > 0 ? f.substring(n + h.length).length : l + f.length); const d = p ? [t, i] : null; const m = this.expressions.store(f, d); u.push(e.substring(a, o)), u.push(m), p && (l = i + 1), a = s; } return u.length > 0 ? u.join('') + e.substring(a, e.length) : e; }, i.prototype.restore = function (e) { for (var t = [], n = 0; n < e.length;) { const r = this.expressions.nextMatch(e, n); if (r.start < 0) break; t.push(e.substring(n, r.start)); const i = this.expressions.restore(r.match); t.push(i), n = r.end; } return t.length > 0 ? t.join('') + e.substring(n, e.length) : e; }, t.exports = i; }, { './escape-store': 89, os: 29 }],
  91: [function (e, t, n) { function r(e) { this.matches = new o('FREE_TEXT'), this.saveWaypoints = e; } function i(e, t, n, r) { let i = t; n && (r = (i = n + t.substring(0, t.indexOf('__ESCAPED_FREE_TEXT_CLEAN_CSS'))).length); const o = i.lastIndexOf(';', r); const s = i.lastIndexOf('{', r); let a = 0; a = o > -1 && s > -1 ? Math.max(o, s) : o == -1 ? s : o; const u = i.substring(a + 1, r); if (/\[[\w\d\-]+[\*\|\~\^\$]?=$/.test(u) && (e = e.replace(/\\\n|\\\r\n/g, '').replace(/\n|\r\n/g, '')), /^['"][a-zA-Z][a-zA-Z\d\-_]+['"]$/.test(e) && !/format\($/.test(u)) { const c = /^(font|font\-family):/.test(u); const l = /\[[\w\d\-]+[\*\|\~\^\$]?=$/.test(u); const p = /@(-moz-|-o-|-webkit-)?keyframes /.test(u); const h = /^(-moz-|-o-|-webkit-)?animation(-name)?:/.test(u); (c || l || p || h) && (e = e.substring(1, e.length - 1)); } return e; } var o = e('./escape-store'); const s = e('../utils/quote-scanner'); const a = e('os').EOL; r.prototype.escape = function (e) { let t; let n; let r; let i; const o = this; const u = this.saveWaypoints; return new s(e).each((e, s) => { u && (t = e.split(a).length - 1, n = e.lastIndexOf(a), r = n > 0 ? e.substring(n + a.length).length : e.length, i = [t, r]); const c = o.matches.store(e, i); s.push(c); }); }, r.prototype.restore = function (e, t) { for (var n = [], r = 0; r < e.length;) { const o = this.matches.nextMatch(e, r); if (o.start < 0) break; n.push(e.substring(r, o.start)); const s = i(this.matches.restore(o.match), e, t, o.start); n.push(s), r = o.end; } return n.length > 0 ? n.join('') + e.substring(r, e.length) : e; }, t.exports = r; }, { '../utils/quote-scanner': 103, './escape-store': 89, os: 29 }],
  92: [function (e, t, n) {
    function r(e, t, n) { this.urls = new o('URL'), this.context = e, this.saveWaypoints = t, this.keepUrlQuotes = n; } function i(e, t) {
      return e = e.replace(/^url/gi, 'url').replace(/\\?\n|\\?\r\n/g, '').replace(/(\s{2,}|\s)/g, ' ').replace(/^url\((['"])? /, 'url($1')
        .replace(/ (['"])?\)$/, '$1)'), /url\(".*'.*"\)/.test(e) || /url\('.*".*'\)/.test(e) ? e : (t || /^['"].+['"]$/.test(e) || /url\(.*[\s\(\)].*\)/.test(e) || /url\(['"]data:[^;]+;charset/.test(e) || (e = e.replace(/["']/g, '')), e);
    } var o = e('./escape-store'); const s = e('../urls/reduce'); const a = e('os').EOL; r.prototype.escape = function (e) { let t; let n; let r; const i = this.saveWaypoints; const o = this; return s(e, this.context, (e, s) => { i && (t = e.split(a).length - 1, n = e.lastIndexOf(a), r = n > 0 ? e.substring(n + a.length).length : e.length); const u = o.urls.store(e, i ? [t, r] : null); s.push(u); }); }, r.prototype.restore = function (e) { for (var t = [], n = 0; n < e.length;) { const r = this.urls.nextMatch(e, n); if (r.start < 0) break; t.push(e.substring(n, r.start)); const o = i(this.urls.restore(r.match), this.keepUrlQuotes); t.push(o), n = r.end; } return t.length > 0 ? t.join('') + e.substring(n, e.length) : e; }, t.exports = r;
  }, { '../urls/reduce': 97, './escape-store': 89, os: 29 }],
  93: [function (e, t, n) { function r(e) { return e[0]; } function i() {} function o(e, t, n, r) { for (let o = n ? /^__ESCAPED_COMMENT_/ : /__ESCAPED_COMMENT_/, s = n ? r.track : i; o.test(e);) { const a = e.indexOf('__'); const u = e.indexOf('__', a + 1) + 2; const c = e.substring(a, u); e = e.substring(0, a) + e.substring(u), s(c), t.push(c); } return e; } function s(e, t, n) { return o(e, t, !0, n); } function a(e, t, n) { return o(e, t, !1, n); } function u(e, t, n) { for (let r = 0, i = e.length; r < i; r++)n.track(e[r]), t.push(e[r]); } function c(e, t, n) { const i = []; let o = []; const v = /[\s,\/]/; if (typeof e !== 'string') return []; e.indexOf(')') > -1 && (e = e.replace(/\)([^\s_;:,\)])/g, n.sourceMap ? ') __ESCAPED_COMMENT_CLEAN_CSS(0,-1)__ $1' : ') $1')), e.indexOf('ESCAPED_URL_CLEAN_CSS') > -1 && (e = e.replace(/(ESCAPED_URL_CLEAN_CSS[^_]+?__)/g, n.sourceMap ? '$1 __ESCAPED_COMMENT_CLEAN_CSS(0,-1)__ ' : '$1 ')); for (let y = l(e, ';', !1, '{', '}'), b = 0, _ = y.length; b < _; b++) { const x = y[b]; const w = x.indexOf(':'); if (x.trim()[0] == '@')n.track(x), i.push([f, x.trim()]); else if (w != -1) if (x.indexOf('{') > 0 && x.indexOf('{') < w)n.track(x); else { const k = []; let E = x.substring(0, w); o = [], E.indexOf('__ESCAPED_COMMENT') > -1 && (E = s(E, i, n)), E.indexOf('__ESCAPED_COMMENT') > -1 && (E = a(E, o, n)), k.push([E.trim()].concat(n.track(E, !0))), n.track(':'), u(o, i, n); const A = x.indexOf('{'); if (E.trim().indexOf('--') === 0 && A > 0) { const C = x.substring(w + 1, A + 1); const S = x.substring(x.indexOf('}')); const T = x.substring(A + 1, x.length - S.length); n.track(C), k.push(c(T, t, n)), i.push(k), n.track(S), n.track(b < _ - 1 ? ';' : ''); } else { const O = l(x.substring(w + 1), v, !0); if (O.length != 1 || O[0] !== '') { for (let F = 0, B = O.length; F < B; F++) { const D = O[F]; let L = D.trim(); if (L.length !== 0) { const N = L[L.length - 1]; const M = L.length > 1 && (N == p || N == h); if (M && (L = L.substring(0, L.length - 1)), L.indexOf('__ESCAPED_COMMENT_CLEAN_CSS(0,-') > -1)n.track(L); else if (o = [], L.indexOf('__ESCAPED_COMMENT') > -1 && (L = s(L, i, n)), L.indexOf('__ESCAPED_COMMENT') > -1 && (L = a(L, o, n)), L.length !== 0) { const R = k.length - 1; m.test(L) && k[R][0] == '!' ? (n.track(L), k[R - 1][0] += d, k.pop()) : g.test(L) || m.test(L) && k[R][0][k[R][0].length - 1] == '!' ? (n.track(L), k[R][0] += L) : (k.push([L].concat(n.track(D, !0))), u(o, i, n), M && (k.push([N]), n.track(N))); } else u(o, i, n); } }b < _ - 1 && n.track(';'), i.push(k); } else n.warnings.push(`Empty property '${E}' inside '${t.filter(r).join(',')}' selector. Ignoring.`); } } else n.track(x), x.indexOf('__ESCAPED_COMMENT_SPECIAL') > -1 && i.push(x.trim()); } return i; } var l = e('../utils/split'); var p = ','; var h = '/'; var f = 'at-rule'; var d = '!important'; var m = new RegExp('^important$', 'i'); var g = new RegExp(`^${d}$`, 'i'); t.exports = c; }, { '../utils/split': 106 }],
  94: [function (e, t, n) { const r = e('../utils/split'); t.exports = function (e, t) { for (var n, i = [], o = r(e, ','), s = 0, a = o.length; s < a; s++)n = t.track(o[s], !0, s), t.track(','), i.push([o[s].trim()].concat(n)); return i; }; }, { '../utils/split': 106 }],
  95: [function (e, t, n) {
    function r(e) { return e.replace(/\r\n/g, '\n'); } function i(e, t) { const n = f.relative(e, t); return function (e, t) { return e != t ? f.normalize(f.join(f.relative(n, f.dirname(e)), t)) : t; }; } function o(e) { let t; const n = e.mode; let r = e.chunk; if (r.length == e.cursor) { if (e.chunks.length === 0) return null; e.chunk = r = e.chunks.shift(), e.cursor = 0; } if (n == 'body') return r[e.cursor] == '}' ? [e.cursor, 'bodyEnd'] : r.indexOf('}', e.cursor) == -1 ? null : (t = e.cursor + h(r.substring(e.cursor - 1), '}', !0, '{', '}')[0].length - 2, [t, 'bodyEnd']); let i = s(e, '@'); let o = r.indexOf('__ESCAPED_', e.cursor); const a = s(e, '{'); const u = s(e, '}'); return i > -1 && e.cursor > 0 && !/\s|\{|\}|\/|_|,|;/.test(r.substring(i - 1, i)) && (i = -1), o > -1 && /\S/.test(r.substring(e.cursor, o)) && (o = -1), ((t = i) == -1 || o > -1 && o < t) && (t = o), (t == -1 || a > -1 && a < t) && (t = a), (t == -1 || u > -1 && u < t) && (t = u), t != -1 ? o === t ? [t, 'escape'] : a === t ? [t, 'bodyStart'] : u === t ? [t, 'bodyEnd'] : i === t ? [t, 'special'] : void 0 : void 0; } function s(e, t) { for (var n, r = e.cursor, i = e.chunk; (n = i.indexOf(t, r)) > -1;) { if (!a(i, n)) return n; r = n + 1; } return -1; } function a(e, t) { for (var n = t, r = 0; n > 0 && e[n - 1] == m;)r++, n--; return r % 2 != 0; } function u(e) { for (var t, n, r = e.chunk, i = []; ;) { const s = o(e); if (!s) { const a = e.chunk.substring(e.cursor); a.trim().length > 0 && (e.mode == 'body' ? e.warnings.push(`Missing '}' after '${a}'. Ignoring.`) : i.push(['text', [a]]), e.cursor += a.length); break; } var p; var h; const f = s[0]; const m = s[1]; if (r = e.chunk, e.cursor != f && m != 'bodyEnd') { const g = r.substring(e.cursor, f); const v = /^\s+/.exec(g); v && (e.cursor += v[0].length, e.track(v[0])); } if (m == 'special') { const y = r.indexOf('{', f); const b = r.indexOf(';', f); const _ = b > -1 && (y == -1 || b < y); if (y == -1 && b == -1)e.warnings.push(`Broken declaration: '${r.substring(e.cursor)}'.`), e.cursor = r.length; else if (_)p = r.indexOf(';', f + 1), n = r.substring(e.cursor, p + 1), i.push(['at-rule', [n].concat(e.track(n, !0))]), e.track(';'), e.cursor = p + 1; else { p = r.indexOf('{', f + 1); const x = (n = r.substring(e.cursor, p)).trim(); const w = d.test(x); h = e.mode, e.cursor = p + 1, e.mode = w ? 'body' : 'block', (t = [w ? 'flat-block' : 'block']).push([x].concat(e.track(n, !0))), e.track('{'), t.push(u(e)), typeof t[2] === 'string' && (t[2] = c(t[2], [[x]], e)), e.mode = h, e.track('}'), i.push(t); } } else if (m == 'escape') { p = r.indexOf('__', f + 1); const k = r.substring(e.cursor, p + 2); const E = !!e.sourceTracker.nextStart(k); const A = !!e.sourceTracker.nextEnd(k); if (E)e.track(k), e.state.push({ source: e.source, line: e.line, column: e.column }), e.source = e.sourceTracker.nextStart(k).filename, e.line = 1, e.column = 0; else if (A) { const C = e.state.pop(); e.source = C.source, e.line = C.line, e.column = C.column, e.track(k); } else k.indexOf('__ESCAPED_COMMENT_SPECIAL') === 0 && i.push(['text', [k]]), e.track(k); e.cursor = p + 2; } else if (m == 'bodyStart') { const S = l(r.substring(e.cursor, f), e); h = e.mode, e.cursor = f + 1, e.mode = 'body'; const T = c(u(e), S, e); e.track('{'), e.mode = h, i.push(['selector', S, T]); } else if (m == 'bodyEnd') { if (e.mode == 'top') { const O = e.cursor; const F = r[e.cursor] == '}' ? `Unexpected '}' in '${r.substring(O - 20, O + 20)}'. Ignoring.` : `Unexpected content: '${r.substring(O, f + 1)}'. Ignoring.`; e.warnings.push(F), e.cursor = f + 1; continue; }e.mode == 'block' && e.track(r.substring(e.cursor, f)), e.mode != 'block' && (i = r.substring(e.cursor, f)), e.cursor = f + 1; break; } } return i; } var c = e('./extract-properties'); var l = e('./extract-selectors'); const p = e('../source-maps/track'); var h = e('../utils/split'); var f = e('path'); var d = /(@(font\-face|page|\-ms\-viewport|\-o\-viewport|viewport|counter\-style)|\\@.+?)/; var m = '\\'; t.exports = function (e, t) {
      const n = h(r(e), '}', !0, '{', '}'); if (n.length === 0) return []; var o = {
        chunk: n.shift(), chunks: n, column: 0, cursor: 0, line: 1, mode: 'top', resolvePath: t.options.explicitTarget ? i(t.options.root, t.options.target) : null, source: void 0, sourceMap: t.options.sourceMap, sourceMapInlineSources: t.options.sourceMapInlineSources, sourceMapTracker: t.inputSourceMapTracker, sourceReader: t.sourceReader, sourceTracker: t.sourceTracker, state: [], track: t.options.sourceMap ? function (e, t, n) { return [[p(e, o, t, n)]]; } : function () { return []; }, warnings: t.warnings,
      }; return u(o);
    };
  }, {
    '../source-maps/track': 83, '../utils/split': 106, './extract-properties': 93, './extract-selectors': 94, path: 30,
  }],
  96: [function (e, t, n) { const r = e('path'); const i = e('./rewrite'); t.exports = function (e, t) { const n = { absolute: t.options.explicitRoot, relative: !t.options.explicitRoot && t.options.explicitTarget, fromBase: t.options.relativeTo }; return n.absolute || n.relative ? (n.absolute && t.options.explicitTarget && t.warnings.push("Both 'root' and output file given so rebasing URLs as absolute paths"), n.absolute && (n.toBase = r.resolve(t.options.root)), n.relative && (n.toBase = r.resolve(t.options.target)), n.fromBase && n.toBase ? i(e, n, t) : e) : e; }; }, { './rewrite': 98, path: 30 }],
  97: [function (e, t, n) { function r(e, t, n) { for (var r, i = 0, f = 0, d = 0, m = 0, g = [], v = e.indexOf(a) > -1; d < e.length && (i = e.indexOf(s, d), f = v ? e.indexOf(a, d) : -1, i != -1 || f != -1);)i == -1 && f > -1 && (i = f), (d = e[i + s.length] == '"' ? e.indexOf(l, i) : e[i + s.length] == "'" ? e.indexOf(c, i) : p.test(e.substring(i + s.length)) ? (r = o(e.substring(i), h, !1, '(', ')', !0).pop()) && r[r.length - 1] == u ? i + r.length - u.length : -1 : e.indexOf(u, i)) == -1 ? ((d = e.indexOf('}', i)) == -1 ? d = e.length : d--, t.warnings.push(`Broken URL declaration: '${e.substring(i, d + 1)}'.`)) : e[d] != u && (d = e.indexOf(u, d)), g.push(e.substring(m, i)), n(e.substring(i, d + 1), g), m = d + 1; return g.length > 0 ? g.join('') + e.substring(m, e.length) : e; } function i(e, t, n) { for (var r, i, o = 0, s = 0, a = 0, u = 0, c = 0, l = [], p = 0, h = 0; u < e.length && (o = e.indexOf(f, u), s = e.indexOf(d, u), o != -1 || s != -1);) { if (o > -1 && s > -1 && s < o && (o = s), p = e.indexOf("'", o), h = e.indexOf('"', o), p > -1 && h > -1 && p < h)a = p, i = "'"; else if (p > -1 && h > -1 && p > h)a = h, i = '"'; else if (p > -1)a = p, i = "'"; else { if (!(h > -1)) break; a = h, i = '"'; } if (l.push(e.substring(c, a)), u = e.indexOf(i, a + 1), r = e.substring(o, u), u == -1 || /^@import\s+(url\(|__ESCAPED)/i.test(r) || m.test(r)) { c = a; break; }n(e.substring(a, u + 1), l), c = u + 1; } return l.length > 0 ? l.join('') + e.substring(c, e.length) : e; } var o = e('../utils/split'); var s = 'url('; var a = 'URL('; var u = ')'; var c = "')"; var l = '")'; var p = /^\s*['"]?\s*data:/; var h = /[\s\};,\/!]/; var f = '@import'; var d = '@IMPORT'; var m = /\*\//; t.exports = function (e, t, n) { return e = r(e, t, n), e = i(e, t, n); }; }, { '../utils/split': 106 }],
  98: [function (e, t, n) { (function (n) { function r(e) { return e[0] == '/'; } function i(e) { return e[0] == '#'; } function o(e) { return e.indexOf('__ESCAPED_URL_CLEAN_CSS__') === 0; } function s(e) { return /^\w+:\w+/.test(e); } function a(e) { return /^[^:]+?:\/\//.test(e) || e.indexOf('//') === 0; } function u(e, t) { return v.parse(e).protocol == v.parse(t).protocol && v.parse(e).host == v.parse(t).host; } function c(e) { return e.lastIndexOf('.css') === e.length - 4; } function l(e) { return e.indexOf('data:') === 0; } function p(e, t) { return g.resolve(g.join(t.fromBase || '', e)).replace(t.toBase, ''); } function h(e, t) { return g.relative(t.toBase, g.join(t.fromBase || '', e)); } function f(e) { return b ? e.replace(/\\/g, '/') : e; } function d(e, t) { return r(e) || i(e) || o(e) || s(e) ? e : !1 !== t.rebase || c(e) ? !t.imports && c(e) ? e : l(e) ? `'${e}'` : a(e) && !a(t.toBase) ? e : a(e) && !u(e, t.toBase) ? e : !a(e) && a(t.toBase) ? v.resolve(t.toBase, e) : f(t.absolute ? p(e, t) : h(e, t)) : e; } function m(e) { return e.indexOf("'") > -1 ? '"' : e.indexOf('"') > -1 ? "'" : /\s/.test(e) || /[\(\)]/.test(e) ? "'" : ''; } var g = e('path'); var v = e('url'); const y = e('./reduce'); var b = n.platform == 'win32'; t.exports = function (e, t, n) { return y(e, n, (e, n) => { let r; const i = e.replace(/^(url\()?\s*['"]?|['"]?\s*\)?$/g, ''); const o = e.match(/^(url\()?\s*(['"]).*?(['"])\s*\)?$/); r = t.urlQuotes && o && o[2] === o[3] ? o[2] : m(i), n.push(`url(${r}${d(i, t)}${r})`); }); }; }).call(this, e('_process')); }, {
    './reduce': 97, _process: 31, path: 30, url: 148,
  }],
  99: [function (e, t, n) { function r(e) { for (var t = e.slice(0), n = 0, i = t.length; n < i; n++)Array.isArray(t[n]) && (t[n] = r(t[n])); return t; }t.exports = r; }, {}],
  100: [function (e, t, n) {
    function r(e) { this.source = e || {}; } function i(e, t) { for (const n in e) { const r = e[n]; typeof r !== 'object' || s.isRegExp(r) ? t[n] = n in t ? t[n] : r : t[n] = i(r, t[n] || {}); } return t; } function o(e) { if (typeof e === 'object') return e; if (!/[,\+\-]/.test(e)) return a[e] || a['*']; const t = e.split(','); const n = t[0] in a ? a[t.shift()] : a['*']; return e = {}, t.forEach((t) => { const n = t[0] == '+'; const r = t.substring(1).split('.'); const i = r[0]; const o = r[1]; e[i] = e[i] || {}, e[i][o] = n; }), i(n, e); } var s = e('util'); var a = {
      '*': {
        colors: { opacity: !0 },
        properties: {
          backgroundClipMerging: !1, backgroundOriginMerging: !1, backgroundSizeMerging: !1, colors: !0, ieBangHack: !1, iePrefixHack: !1, ieSuffixHack: !0, merging: !0, shorterLengthUnits: !1, spaceAfterClosingBrace: !0, urlQuotes: !1, zeroUnits: !0,
        },
        selectors: { adjacentSpace: !1, ie7Hack: !1, special: /(\-moz\-|\-ms\-|\-o\-|\-webkit\-|:dir\([a-z-]*\)|:first(?![a-z-])|:fullscreen|:left|:read-only|:read-write|:right|:placeholder|:host|:content|\/deep\/|:shadow|:selection|^,)/ },
        units: {
          ch: !0, in: !0, pc: !0, pt: !0, rem: !0, vh: !0, vm: !0, vmax: !0, vmin: !0, vw: !0,
        },
      },
      ie8: {
        colors: { opacity: !1 },
        properties: {
          backgroundClipMerging: !1, backgroundOriginMerging: !1, backgroundSizeMerging: !1, colors: !0, ieBangHack: !1, iePrefixHack: !0, ieSuffixHack: !0, merging: !1, shorterLengthUnits: !1, spaceAfterClosingBrace: !0, urlQuotes: !1, zeroUnits: !0,
        },
        selectors: { adjacentSpace: !1, ie7Hack: !1, special: /(\-moz\-|\-ms\-|\-o\-|\-webkit\-|:root|:nth|:first\-of|:last|:only|:empty|:target|:checked|::selection|:enabled|:disabled|:not|:placeholder|:host|::content|\/deep\/|::shadow|^,)/ },
        units: {
          ch: !1, in: !0, pc: !0, pt: !0, rem: !1, vh: !1, vm: !1, vmax: !1, vmin: !1, vw: !1,
        },
      },
      ie7: {
        colors: { opacity: !1 },
        properties: {
          backgroundClipMerging: !1, backgroundOriginMerging: !1, backgroundSizeMerging: !1, colors: !0, ieBangHack: !0, iePrefixHack: !0, ieSuffixHack: !0, merging: !1, shorterLengthUnits: !1, spaceAfterClosingBrace: !0, urlQuotes: !1, zeroUnits: !0,
        },
        selectors: { adjacentSpace: !1, ie7Hack: !0, special: /(\-moz\-|\-ms\-|\-o\-|\-webkit\-|:focus|:before|:after|:root|:nth|:first\-of|:last|:only|:empty|:target|:checked|::selection|:enabled|:disabled|:not|:placeholder|:host|::content|\/deep\/|::shadow|^,)/ },
        units: {
          ch: !1, in: !0, pc: !0, pt: !0, rem: !1, vh: !1, vm: !1, vmax: !1, vmin: !1, vw: !1,
        },
      },
    }; r.prototype.toOptions = function () { return i(a['*'], o(this.source)); }, t.exports = r;
  }, { util: 152 }],
  101: [function (e, t, n) { (function (n, r, i) { function o(e) { this.options = e.options, this.errors = e.errors, this.warnings = e.warnings, this.sourceTracker = e.sourceTracker, this.timeout = this.options.inliner.timeout, this.requestOptions = this.options.inliner.request, this.localOnly = e.localOnly, this.relativeTo = e.options.target || n.cwd(), this.maps = {}, this.sourcesContent = {}; } function s(e, t, n) { return e.trackLoaded(void 0, void 0, e.options.sourceMap), n(); } function a(e, t, n, r) { for (var i = 0; r.cursor < t.length;) { const o = t.substring(r.cursor); const s = e.sourceTracker.nextStart(o) || { index: -1 }; const l = e.sourceTracker.nextEnd(o) || { index: -1 }; const p = x.exec(o) || { index: -1 }; const h = p[1]; if (i = t.length, s.index > -1 && (i = s.index), l.index > -1 && l.index < i && (i = l.index), p.index > -1 && p.index < i && (i = p.index), i == t.length) break; if (i == s.index)r.files.push(s.filename); else if (i == l.index)r.files.pop(); else if (i == p.index) { const f = /^https?:\/\//.test(h) || /^\/\//.test(h); const d = k.test(h); if (f) return c(e, h, r, () => { r.cursor += i + 1, a(e, t, n, r); }); var v; var y; const b = r.files[r.files.length - 1]; const _ = b ? g.dirname(b) : e.options.relativeTo; d ? (v = g.resolve(e.options.root, b || ''), y = u(h)) : (v = g.resolve(e.options.root, g.join(_ || '', h)), y = m.readFileSync(v, 'utf-8')), e.trackLoaded(b || void 0, v, y); }r.cursor += i + 1; } return n(); } function u(e) { const t = k.exec(e); const n = t[2] ? t[2].split(/[=;]/)[2] : 'us-ascii'; const r = t[3] ? t[3].split(';')[1] : 'utf8'; const o = r == 'utf8' ? E(t[4]) : t[4]; const s = new i(o, r); return s.charset = n, s.toString(); } function c(e, t, n, r) { l(e, t, (i) => { e.trackLoaded(n.files[n.files.length - 1] || void 0, t, i), r(); }, e => n.errors.push(`Broken source map at "${t}" - ${e}`), r()); } function l(e, t, n, r) { const i = t.indexOf('https') === 0 ? y : v; const o = _(b.parse(t), e.requestOptions); let s = !1; i.get(o, (e) => { if (e.statusCode < 200 || e.statusCode > 299) return r(e.statusCode); const t = []; e.on('data', (e) => { t.push(e.toString()); }), e.on('end', () => { n(t.join('')); }); }).on('error', (e) => { s || (r(e.message), s = !0); }).on('timeout', () => { s || (r('timeout'), s = !0); }).setTimeout(e.timeout); } function p(e, t, n, r, i) { for (var o, s = r.length, a = { line: t, column: n + s }; s-- > 0 && (a.column--, !(o = e.data.originalPositionFor(a))););return o.line === null && t > 1 && i > 0 ? p(e, t - 1, n, r, i - 1) : (e.path && o.source && (o.source = w.test(e.path) ? b.resolve(e.path, o.source) : g.join(e.path, o.source), o.sourceResolved = !0), o); } function h(e, t) { const n = e.maps[t].data; const r = w.test(t); const i = {}; n.sources.forEach((o, s) => { const a = r ? b.resolve(g.dirname(t), o) : g.relative(e.relativeTo, g.resolve(g.dirname(t || '.'), o)); i[a] = n.sourcesContent && n.sourcesContent[s]; }), e.sourcesContent[t] = i; } function f(e, t, n) { function r() { return f(e, t, n); } if (t.length === 0) return n(); const i = t.shift(); const o = i[0]; const s = i[1]; const a = w.test(o); if (a && e.localOnly) return e.warnings.push(`No callback given to \`#minify\` method, cannot fetch a remote file from "${s}"`), r(); if (!a) { const u = g.join(e.options.root, s); return m.existsSync(u) ? e.sourcesContent[o][s] = m.readFileSync(u, 'utf-8') : e.warnings.push(`Missing original source file at "${u}".`), r(); }l(e, s, (t) => { e.sourcesContent[o][s] = t, r(); }, (t) => { e.warnings.push(`Broken original source file at "${s}" - ${t}`), r(); }); } const d = e('source-map').SourceMapConsumer; var m = e('fs'); var g = e('path'); var v = e('http'); var y = e('https'); var b = e('url'); var _ = e('../utils/object.js').override; var x = /\/\*# sourceMappingURL=(\S+) \*\//; var w = /^(https?:)?\/\//; var k = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/; var E = r.unescape; o.prototype.track = function (e, t) { return typeof this.options.sourceMap === 'string' ? s(this, 0, t) : a(this, e, t, { files: [], cursor: 0, errors: this.errors }); }, o.prototype.trackLoaded = function (e, t, n) { const r = this.options.explicitTarget ? this.options.target : this.options.root; const i = w.test(e); t && (t = i ? g.dirname(t) : g.dirname(g.relative(r, t))), this.maps[e] = { path: t, data: new d(n) }, h(this, e); }, o.prototype.isTracking = function (e) { return !!this.maps[e]; }, o.prototype.originalPositionFor = function (e, t, n) { return p(this.maps[e.source], e.line, e.column, t, n); }, o.prototype.sourcesContentFor = function (e) { return this.sourcesContent[e]; }, o.prototype.resolveSources = function (e) { const t = []; for (const n in this.sourcesContent) { const r = this.sourcesContent[n]; for (const i in r)r[i] || t.push([n, i]); } return f(this, t, e); }, t.exports = o; }).call(this, e('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}, e('buffer').Buffer); }, {
    '../utils/object.js': 102, _process: 31, buffer: 11, fs: 10, http: 10, https: 10, path: 30, 'source-map': 107, url: 148,
  }],
  102: [function (e, t, n) { t.exports = { override(e, t) { const n = {}; for (const r in e)n[r] = e[r]; for (const i in t)n[i] = t[i]; return n; } }; }, {}],
  103: [function (e, t, n) { function r(e) { this.data = e; } function i(e, t) { for (var n = t; n > -1 && !((n = e.lastIndexOf(s, n)) > -1 && e[n - 1] != '*');)n--; return n; } function o(e, t, n) { for (let r = n; ;) { if ((r = e.indexOf(t, r + 1)) == -1) return -1; if (e[r - 1] != '\\') return r; } } var s = '/*'; const a = function (e, t, n, r) { const o = e.substring(r, n); const s = o.lastIndexOf('*/', n); const a = i(o, n); let u = !1; if (s >= n && a > -1 && (u = !0), a < n && a > s && (u = !0), u) { let c = e.indexOf('*/', n); return c > -1 ? c : (c = e.indexOf('}', n)) > -1 ? c - 1 : e.length; } for (;;) { if (void 0 === e[n]) break; if (e[n] == t && (e[n - 1] != '\\' || e[n - 2] == '\\')) break; n++; } return n; }; r.prototype.each = function (e) { for (var t = this.data, n = [], r = 0, i = 0, s = 0, u = null, c = t.length; i < t.length;) { let l = o(t, "'", i); let p = o(t, '"', i); if (l == -1 && (l = c), p == -1 && (p = c), l < p ? (r = l, u = "'") : (r = p, u = '"'), r == -1) break; if ((i = a(t, u, r + 1, s)) == -1) break; const h = t.substring(r, i + 1); n.push(t.substring(s, r)), h.length > 0 && e(h, n, r), s = i + 1; } return n.length > 0 ? n.join('') + t.substring(s, t.length) : t; }, t.exports = r; }, {}],
  104: [function (e, t, n) {
    (function (n) {
      function r(e, t) { this.outerContext = e, this.data = t, this.sources = {}; } function i(e) { const t = e.data; return e.trackSource(void 0, t), t; } function o(e) { const t = e.data.toString(); return e.trackSource(void 0, t), t; } function s(e) { return e.data.map(t => (!1 === e.outerContext.options.processImport ? `${t}@shallow` : t)).map(t => (!e.outerContext.options.relativeTo || /^https?:\/\//.test(t) ? t : u.relative(e.outerContext.options.relativeTo, t))).map(e => `@import url(${e});`).join(''); } function a(e) {
        const t = []; const n = u.resolve(e.outerContext.options.target || e.outerContext.options.root); for (const r in e.data) {
          let i = e.data[r].styles; const o = e.data[r].sourceMap; const s = l.test(r); const a = s ? r : u.resolve(r); const p = u.dirname(a); const h = {
            absolute: e.outerContext.options.explicitRoot, relative: !e.outerContext.options.explicitRoot, imports: !0, rebase: e.outerContext.options.rebase, fromBase: p, toBase: s ? p : n, urlQuotes: e.outerContext.options.compatibility.properties.urlQuotes,
          }; i = c(i, h, e.outerContext), e.trackSource(r, i), i = e.outerContext.sourceTracker.store(r, i), e.outerContext.options.sourceMap && o && e.outerContext.inputSourceMapTracker.trackLoaded(r, r, o), t.push(i);
        } return t.join('');
      } var u = e('path'); var c = e('../urls/rewrite'); var l = /^(https?:)?\/\//; r.prototype.sourceAt = function (e) { return this.sources[e]; }, r.prototype.trackSource = function (e, t) { this.sources[e] = {}, this.sources[e][e] = t; }, r.prototype.toString = function () { return typeof this.data === 'string' ? i(this) : n.isBuffer(this.data) ? o(this) : Array.isArray(this.data) ? s(this) : a(this); }, t.exports = r;
    }).call(this, { isBuffer: e('../../../../../is-buffer/index.js') });
  }, { '../../../../../is-buffer/index.js': 22, '../urls/rewrite': 98, path: 30 }],
  105: [function (e, t, n) { function r() { this.sources = []; }r.prototype.store = function (e, t) { return this.sources.push(e), `__ESCAPED_SOURCE_CLEAN_CSS${this.sources.length - 1}__${t}__ESCAPED_SOURCE_END_CLEAN_CSS__`; }, r.prototype.nextStart = function (e) { const t = /__ESCAPED_SOURCE_CLEAN_CSS(\d+)__/.exec(e); return t ? { index: t.index, filename: this.sources[~~t[1]] } : null; }, r.prototype.nextEnd = function (e) { return /__ESCAPED_SOURCE_END_CLEAN_CSS__/g.exec(e); }, r.prototype.removeAll = function (e) { return e.replace(/__ESCAPED_SOURCE_CLEAN_CSS\d+__/g, '').replace(/__ESCAPED_SOURCE_END_CLEAN_CSS__/g, ''); }, t.exports = r; }, {}],
  106: [function (e, t, n) { t.exports = function (e, t, n, r, i, o) { const s = typeof t !== 'string'; if (!(s ? t.test(e) : e.indexOf(t))) return [e]; if (r = r || '(', i = i || ')', e.indexOf(r) == -1 && !n && !o) return e.split(t); for (var a = !1, u = !1, c = 0, l = 0, p = 0, h = e.length, f = []; l < h && (a = e[l] == '\\', u || (e[l] == r ? c++ : e[l] == i && c--), !(!u && c === 0 && l > 0 && l + 1 < h && (s ? t.test(e[l]) : e[l] == t) && (f.push(e.substring(p, l + (n ? 1 : 0))), p = l + 1, o && f.length == 1)));)u = a, l++; if (p < l + 1) { let d = e.substring(p); const m = d[d.length - 1]; !n && (s ? t.test(m) : m == t) && (d = d.substring(0, d.length - 1)), f.push(d); } return f; }; }, {}],
  107: [function (e, t, n) { n.SourceMapGenerator = e('./source-map/source-map-generator').SourceMapGenerator, n.SourceMapConsumer = e('./source-map/source-map-consumer').SourceMapConsumer, n.SourceNode = e('./source-map/source-node').SourceNode; }, { './source-map/source-map-consumer': 114, './source-map/source-map-generator': 115, './source-map/source-node': 116 }],
  108: [function (e, t, n) { if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => { function r() { this._array = [], this._set = {}; } const i = e('./util'); r.fromArray = function (e, t) { for (var n = new r(), i = 0, o = e.length; i < o; i++)n.add(e[i], t); return n; }, r.prototype.size = function () { return Object.getOwnPropertyNames(this._set).length; }, r.prototype.add = function (e, t) { const n = this.has(e); const r = this._array.length; n && !t || this._array.push(e), n || (this._set[i.toSetString(e)] = r); }, r.prototype.has = function (e) { return Object.prototype.hasOwnProperty.call(this._set, i.toSetString(e)); }, r.prototype.indexOf = function (e) { if (this.has(e)) return this._set[i.toSetString(e)]; throw new Error(`"${e}" is not in the set.`); }, r.prototype.at = function (e) { if (e >= 0 && e < this._array.length) return this._array[e]; throw new Error(`No element indexed by ${e}`); }, r.prototype.toArray = function () { return this._array.slice(); }, t.ArraySet = r; }); }, { './util': 117, amdefine: 4 }],
  109: [function (e, t, n) { if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => { function r(e) { return e < 0 ? 1 + (-e << 1) : 0 + (e << 1); } function i(e) { const t = e >> 1; return (1 & e) == 1 ? -t : t; } const o = e('./base64'); t.encode = function (e) { let t; let n = ''; let i = r(e); do { t = 31 & i, (i >>>= 5) > 0 && (t |= 32), n += o.encode(t); } while (i > 0);return n; }, t.decode = function (e, t, n) { let r; let s; const a = e.length; let u = 0; let c = 0; do { if (t >= a) throw new Error('Expected more digits in base 64 VLQ value.'); if ((s = o.decode(e.charCodeAt(t++))) === -1) throw new Error(`Invalid base64 digit: ${e.charAt(t - 1)}`); r = !!(32 & s), u += (s &= 31) << c, c += 5; } while (r);n.value = i(u), n.rest = t; }; }); }, { './base64': 110, amdefine: 4 }],
  110: [function (e, t, n) { if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => { const r = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(''); t.encode = function (e) { if (e >= 0 && e < r.length) return r[e]; throw new TypeError(`Must be between 0 and 63: ${aNumber}`); }, t.decode = function (e) { return e >= 65 && e <= 90 ? e - 65 : e >= 97 && e <= 122 ? e - 97 + 26 : e >= 48 && e <= 57 ? e - 48 + 52 : e == 43 ? 62 : e == 47 ? 63 : -1; }; }); }, { amdefine: 4 }],
  111: [function (e, t, n) { if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => { function r(e, n, i, o, s, a) { const u = Math.floor((n - e) / 2) + e; const c = s(i, o[u], !0); return c === 0 ? u : c > 0 ? n - u > 1 ? r(u, n, i, o, s, a) : a == t.LEAST_UPPER_BOUND ? n < o.length ? n : -1 : u : u - e > 1 ? r(e, u, i, o, s, a) : a == t.LEAST_UPPER_BOUND ? u : e < 0 ? -1 : e; }t.GREATEST_LOWER_BOUND = 1, t.LEAST_UPPER_BOUND = 2, t.search = function (e, n, i, o) { if (n.length === 0) return -1; let s = r(-1, n.length, e, n, i, o || t.GREATEST_LOWER_BOUND); if (s < 0) return -1; for (;s - 1 >= 0 && i(n[s], n[s - 1], !0) === 0;)--s; return s; }; }); }, { amdefine: 4 }],
  112: [function (e, t, n) { if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => { function r(e, t) { const n = e.generatedLine; const r = t.generatedLine; const i = e.generatedColumn; const s = t.generatedColumn; return r > n || r == n && s >= i || o.compareByGeneratedPositionsInflated(e, t) <= 0; } function i() { this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 }; } var o = e('./util'); i.prototype.unsortedForEach = function (e, t) { this._array.forEach(e, t); }, i.prototype.add = function (e) { r(this._last, e) ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e)); }, i.prototype.toArray = function () { return this._sorted || (this._array.sort(o.compareByGeneratedPositionsInflated), this._sorted = !0), this._array; }, t.MappingList = i; }); }, { './util': 117, amdefine: 4 }],
  113: [function (e, t, n) { if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => { function r(e, t, n) { const r = e[t]; e[t] = e[n], e[n] = r; } function i(e, t) { return Math.round(e + Math.random() * (t - e)); } function o(e, t, n, s) { if (n < s) { let a = n - 1; r(e, i(n, s), s); for (var u = e[s], c = n; c < s; c++)t(e[c], u) <= 0 && r(e, a += 1, c); r(e, a + 1, c); const l = a + 1; o(e, t, n, l - 1), o(e, t, l + 1, s); } }t.quickSort = function (e, t) { o(e, t, 0, e.length - 1); }; }); }, { amdefine: 4 }],
  114: [function (e, t, n) {
    if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => {
      function r(e) { let t = e; return typeof e === 'string' && (t = JSON.parse(e.replace(/^\)\]\}'/, ''))), t.sections != null ? new s(t) : new i(t); } function i(e) { let t = e; typeof e === 'string' && (t = JSON.parse(e.replace(/^\)\]\}'/, ''))); const n = a.getArg(t, 'version'); let r = a.getArg(t, 'sources'); const i = a.getArg(t, 'names', []); const o = a.getArg(t, 'sourceRoot', null); const s = a.getArg(t, 'sourcesContent', null); const u = a.getArg(t, 'mappings'); const l = a.getArg(t, 'file', null); if (n != this._version) throw new Error(`Unsupported version: ${n}`); r = r.map(a.normalize), this._names = c.fromArray(i, !0), this._sources = c.fromArray(r, !0), this.sourceRoot = o, this.sourcesContent = s, this._mappings = u, this.file = l; } function o() { this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null; } function s(e) { let t = e; typeof e === 'string' && (t = JSON.parse(e.replace(/^\)\]\}'/, ''))); const n = a.getArg(t, 'version'); const i = a.getArg(t, 'sections'); if (n != this._version) throw new Error(`Unsupported version: ${n}`); this._sources = new c(), this._names = new c(); let o = { line: -1, column: 0 }; this._sections = i.map((e) => { if (e.url) throw new Error('Support for url field in sections not implemented.'); const t = a.getArg(e, 'offset'); const n = a.getArg(t, 'line'); const i = a.getArg(t, 'column'); if (n < o.line || n === o.line && i < o.column) throw new Error('Section offsets must be ordered and non-overlapping.'); return o = t, { generatedOffset: { generatedLine: n + 1, generatedColumn: i + 1 }, consumer: new r(a.getArg(e, 'map')) }; }); } var a = e('./util'); const u = e('./binary-search'); var c = e('./array-set').ArraySet; const l = e('./base64-vlq'); const p = e('./quick-sort').quickSort; r.fromSourceMap = function (e) { return i.fromSourceMap(e); }, r.prototype._version = 3, r.prototype.__generatedMappings = null, Object.defineProperty(r.prototype, '_generatedMappings', { get() { return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings; } }), r.prototype.__originalMappings = null, Object.defineProperty(r.prototype, '_originalMappings', { get() { return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings; } }), r.prototype._charIsMappingSeparator = function (e, t) { const n = e.charAt(t); return n === ';' || n === ','; }, r.prototype._parseMappings = function (e, t) { throw new Error('Subclasses must implement _parseMappings'); }, r.GENERATED_ORDER = 1, r.ORIGINAL_ORDER = 2, r.GREATEST_LOWER_BOUND = 1, r.LEAST_UPPER_BOUND = 2, r.prototype.eachMapping = function (e, t, n) {
        let i; const o = t || null; switch (n || r.GENERATED_ORDER) { case r.GENERATED_ORDER: i = this._generatedMappings; break; case r.ORIGINAL_ORDER: i = this._originalMappings; break; default: throw new Error('Unknown order of iteration.'); } const s = this.sourceRoot; i.map(function (e) {
          let t = e.source === null ? null : this._sources.at(e.source); return t != null && s != null && (t = a.join(s, t)), {
            source: t, generatedLine: e.generatedLine, generatedColumn: e.generatedColumn, originalLine: e.originalLine, originalColumn: e.originalColumn, name: e.name === null ? null : this._names.at(e.name),
          };
        }, this).forEach(e, o);
      }, r.prototype.allGeneratedPositionsFor = function (e) { const t = a.getArg(e, 'line'); const n = { source: a.getArg(e, 'source'), originalLine: t, originalColumn: a.getArg(e, 'column', 0) }; if (this.sourceRoot != null && (n.source = a.relative(this.sourceRoot, n.source)), !this._sources.has(n.source)) return []; n.source = this._sources.indexOf(n.source); const r = []; let i = this._findMapping(n, this._originalMappings, 'originalLine', 'originalColumn', a.compareByOriginalPositions, u.LEAST_UPPER_BOUND); if (i >= 0) { let o = this._originalMappings[i]; if (void 0 === e.column) for (let s = o.originalLine; o && o.originalLine === s;)r.push({ line: a.getArg(o, 'generatedLine', null), column: a.getArg(o, 'generatedColumn', null), lastColumn: a.getArg(o, 'lastGeneratedColumn', null) }), o = this._originalMappings[++i]; else for (let c = o.originalColumn; o && o.originalLine === t && o.originalColumn == c;)r.push({ line: a.getArg(o, 'generatedLine', null), column: a.getArg(o, 'generatedColumn', null), lastColumn: a.getArg(o, 'lastGeneratedColumn', null) }), o = this._originalMappings[++i]; } return r; }, t.SourceMapConsumer = r, (i.prototype = Object.create(r.prototype)).consumer = r, i.fromSourceMap = function (e) { const t = Object.create(i.prototype); const n = t._names = c.fromArray(e._names.toArray(), !0); const r = t._sources = c.fromArray(e._sources.toArray(), !0); t.sourceRoot = e._sourceRoot, t.sourcesContent = e._generateSourcesContent(t._sources.toArray(), t.sourceRoot), t.file = e._file; for (let s = e._mappings.toArray().slice(), u = t.__generatedMappings = [], l = t.__originalMappings = [], h = 0, f = s.length; h < f; h++) { const d = s[h]; const m = new o(); m.generatedLine = d.generatedLine, m.generatedColumn = d.generatedColumn, d.source && (m.source = r.indexOf(d.source), m.originalLine = d.originalLine, m.originalColumn = d.originalColumn, d.name && (m.name = n.indexOf(d.name)), l.push(m)), u.push(m); } return p(t.__originalMappings, a.compareByOriginalPositions), t; }, i.prototype._version = 3, Object.defineProperty(i.prototype, 'sources', { get() { return this._sources.toArray().map(function (e) { return this.sourceRoot != null ? a.join(this.sourceRoot, e) : e; }, this); } }), i.prototype._parseMappings = function (e, t) { for (var n, r, i, s, u, c = 1, h = 0, f = 0, d = 0, m = 0, g = 0, v = e.length, y = 0, b = {}, _ = {}, x = [], w = []; y < v;) if (e.charAt(y) === ';')c++, y++, h = 0; else if (e.charAt(y) === ',')y++; else { for ((n = new o()).generatedLine = c, s = y; s < v && !this._charIsMappingSeparator(e, s); s++);if (r = e.slice(y, s), i = b[r])y += r.length; else { for (i = []; y < s;)l.decode(e, y, _), u = _.value, y = _.rest, i.push(u); if (i.length === 2) throw new Error('Found a source, but no line and column'); if (i.length === 3) throw new Error('Found a source and line, but no column'); b[r] = i; }n.generatedColumn = h + i[0], h = n.generatedColumn, i.length > 1 && (n.source = m + i[1], m += i[1], n.originalLine = f + i[2], f = n.originalLine, n.originalLine += 1, n.originalColumn = d + i[3], d = n.originalColumn, i.length > 4 && (n.name = g + i[4], g += i[4])), w.push(n), typeof n.originalLine === 'number' && x.push(n); }p(w, a.compareByGeneratedPositionsDeflated), this.__generatedMappings = w, p(x, a.compareByOriginalPositions), this.__originalMappings = x; }, i.prototype._findMapping = function (e, t, n, r, i, o) { if (e[n] <= 0) throw new TypeError(`Line must be greater than or equal to 1, got ${e[n]}`); if (e[r] < 0) throw new TypeError(`Column must be greater than or equal to 0, got ${e[r]}`); return u.search(e, t, i, o); }, i.prototype.computeColumnSpans = function () { for (let e = 0; e < this._generatedMappings.length; ++e) { const t = this._generatedMappings[e]; if (e + 1 < this._generatedMappings.length) { const n = this._generatedMappings[e + 1]; if (t.generatedLine === n.generatedLine) { t.lastGeneratedColumn = n.generatedColumn - 1; continue; } }t.lastGeneratedColumn = 1 / 0; } }, i.prototype.originalPositionFor = function (e) {
        const t = { generatedLine: a.getArg(e, 'line'), generatedColumn: a.getArg(e, 'column') }; const n = this._findMapping(t, this._generatedMappings, 'generatedLine', 'generatedColumn', a.compareByGeneratedPositionsDeflated, a.getArg(e, 'bias', r.GREATEST_LOWER_BOUND)); if (n >= 0) {
          const i = this._generatedMappings[n]; if (i.generatedLine === t.generatedLine) {
            let o = a.getArg(i, 'source', null); o !== null && (o = this._sources.at(o), this.sourceRoot != null && (o = a.join(this.sourceRoot, o))); let s = a.getArg(i, 'name', null); return s !== null && (s = this._names.at(s)), {
              source: o, line: a.getArg(i, 'originalLine', null), column: a.getArg(i, 'originalColumn', null), name: s,
            };
          }
        } return {
          source: null, line: null, column: null, name: null,
        };
      }, i.prototype.hasContentsOfAllSources = function () { return !!this.sourcesContent && (this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(e => e == null)); }, i.prototype.sourceContentFor = function (e, t) { if (!this.sourcesContent) return null; if (this.sourceRoot != null && (e = a.relative(this.sourceRoot, e)), this._sources.has(e)) return this.sourcesContent[this._sources.indexOf(e)]; let n; if (this.sourceRoot != null && (n = a.urlParse(this.sourceRoot))) { const r = e.replace(/^file:\/\//, ''); if (n.scheme == 'file' && this._sources.has(r)) return this.sourcesContent[this._sources.indexOf(r)]; if ((!n.path || n.path == '/') && this._sources.has(`/${e}`)) return this.sourcesContent[this._sources.indexOf(`/${e}`)]; } if (t) return null; throw new Error(`"${e}" is not in the SourceMap.`); }, i.prototype.generatedPositionFor = function (e) { let t = a.getArg(e, 'source'); if (this.sourceRoot != null && (t = a.relative(this.sourceRoot, t)), !this._sources.has(t)) return { line: null, column: null, lastColumn: null }; const n = { source: t = this._sources.indexOf(t), originalLine: a.getArg(e, 'line'), originalColumn: a.getArg(e, 'column') }; const i = this._findMapping(n, this._originalMappings, 'originalLine', 'originalColumn', a.compareByOriginalPositions, a.getArg(e, 'bias', r.GREATEST_LOWER_BOUND)); if (i >= 0) { const o = this._originalMappings[i]; if (o.source === n.source) return { line: a.getArg(o, 'generatedLine', null), column: a.getArg(o, 'generatedColumn', null), lastColumn: a.getArg(o, 'lastGeneratedColumn', null) }; } return { line: null, column: null, lastColumn: null }; }, t.BasicSourceMapConsumer = i, (s.prototype = Object.create(r.prototype)).constructor = r, s.prototype._version = 3, Object.defineProperty(s.prototype, 'sources', { get() { for (var e = [], t = 0; t < this._sections.length; t++) for (let n = 0; n < this._sections[t].consumer.sources.length; n++)e.push(this._sections[t].consumer.sources[n]); return e; } }), s.prototype.originalPositionFor = function (e) {
        const t = { generatedLine: a.getArg(e, 'line'), generatedColumn: a.getArg(e, 'column') }; const n = u.search(t, this._sections, (e, t) => { const n = e.generatedLine - t.generatedOffset.generatedLine; return n || e.generatedColumn - t.generatedOffset.generatedColumn; }); const r = this._sections[n]; return r ? r.consumer.originalPositionFor({ line: t.generatedLine - (r.generatedOffset.generatedLine - 1), column: t.generatedColumn - (r.generatedOffset.generatedLine === t.generatedLine ? r.generatedOffset.generatedColumn - 1 : 0), bias: e.bias }) : {
          source: null, line: null, column: null, name: null,
        };
      }, s.prototype.hasContentsOfAllSources = function () { return this._sections.every(e => e.consumer.hasContentsOfAllSources()); }, s.prototype.sourceContentFor = function (e, t) { for (let n = 0; n < this._sections.length; n++) { const r = this._sections[n].consumer.sourceContentFor(e, !0); if (r) return r; } if (t) return null; throw new Error(`"${e}" is not in the SourceMap.`); }, s.prototype.generatedPositionFor = function (e) { for (let t = 0; t < this._sections.length; t++) { const n = this._sections[t]; if (n.consumer.sources.indexOf(a.getArg(e, 'source')) !== -1) { const r = n.consumer.generatedPositionFor(e); if (r) return { line: r.line + (n.generatedOffset.generatedLine - 1), column: r.column + (n.generatedOffset.generatedLine === r.line ? n.generatedOffset.generatedColumn - 1 : 0) }; } } return { line: null, column: null }; }, s.prototype._parseMappings = function (e, t) {
        this.__generatedMappings = [], this.__originalMappings = []; for (let n = 0; n < this._sections.length; n++) {
          for (let r = this._sections[n], i = r.consumer._generatedMappings, o = 0; o < i.length; o++) {
            const s = i[n]; let u = r.consumer._sources.at(s.source); r.consumer.sourceRoot !== null && (u = a.join(r.consumer.sourceRoot, u)), this._sources.add(u), u = this._sources.indexOf(u); let c = r.consumer._names.at(s.name); this._names.add(c), c = this._names.indexOf(c); const l = {
              source: u, generatedLine: s.generatedLine + (r.generatedOffset.generatedLine - 1), generatedColumn: s.column + (r.generatedOffset.generatedLine === s.generatedLine) ? r.generatedOffset.generatedColumn - 1 : 0, originalLine: s.originalLine, originalColumn: s.originalColumn, name: c,
            }; this.__generatedMappings.push(l), typeof l.originalLine === 'number' && this.__originalMappings.push(l);
          }
        }p(this.__generatedMappings, a.compareByGeneratedPositionsDeflated), p(this.__originalMappings, a.compareByOriginalPositions);
      }, t.IndexedSourceMapConsumer = s;
    });
  }, {
    './array-set': 108, './base64-vlq': 109, './binary-search': 111, './quick-sort': 113, './util': 117, amdefine: 4,
  }],
  115: [function (e, t, n) {
    if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => {
      function r(e) { e || (e = {}), this._file = o.getArg(e, 'file', null), this._sourceRoot = o.getArg(e, 'sourceRoot', null), this._skipValidation = o.getArg(e, 'skipValidation', !1), this._sources = new s(), this._names = new s(), this._mappings = new a(), this._sourcesContents = null; } const i = e('./base64-vlq'); var o = e('./util'); var s = e('./array-set').ArraySet; var a = e('./mapping-list').MappingList; r.prototype._version = 3, r.fromSourceMap = function (e) { const t = e.sourceRoot; const n = new r({ file: e.file, sourceRoot: t }); return e.eachMapping((e) => { const r = { generated: { line: e.generatedLine, column: e.generatedColumn } }; e.source != null && (r.source = e.source, t != null && (r.source = o.relative(t, r.source)), r.original = { line: e.originalLine, column: e.originalColumn }, e.name != null && (r.name = e.name)), n.addMapping(r); }), e.sources.forEach((t) => { const r = e.sourceContentFor(t); r != null && n.setSourceContent(t, r); }), n; }, r.prototype.addMapping = function (e) {
        const t = o.getArg(e, 'generated'); const n = o.getArg(e, 'original', null); const r = o.getArg(e, 'source', null); const i = o.getArg(e, 'name', null); this._skipValidation || this._validateMapping(t, n, r, i), r == null || this._sources.has(r) || this._sources.add(r), i == null || this._names.has(i) || this._names.add(i), this._mappings.add({
          generatedLine: t.line, generatedColumn: t.column, originalLine: n != null && n.line, originalColumn: n != null && n.column, source: r, name: i,
        });
      }, r.prototype.setSourceContent = function (e, t) { let n = e; this._sourceRoot != null && (n = o.relative(this._sourceRoot, n)), t != null ? (this._sourcesContents || (this._sourcesContents = {}), this._sourcesContents[o.toSetString(n)] = t) : this._sourcesContents && (delete this._sourcesContents[o.toSetString(n)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null)); }, r.prototype.applySourceMap = function (e, t, n) {
        let r = t; if (t == null) { if (e.file == null) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.'); r = e.file; } const i = this._sourceRoot; i != null && (r = o.relative(i, r)); const a = new s();


        const u = new s(); this._mappings.unsortedForEach((t) => { if (t.source === r && t.originalLine != null) { const s = e.originalPositionFor({ line: t.originalLine, column: t.originalColumn }); s.source != null && (t.source = s.source, n != null && (t.source = o.join(n, t.source)), i != null && (t.source = o.relative(i, t.source)), t.originalLine = s.line, t.originalColumn = s.column, s.name != null && (t.name = s.name)); } const c = t.source; c == null || a.has(c) || a.add(c); const l = t.name; l == null || u.has(l) || u.add(l); }, this), this._sources = a, this._names = u, e.sources.forEach(function (t) { const r = e.sourceContentFor(t); r != null && (n != null && (t = o.join(n, t)), i != null && (t = o.relative(i, t)), this.setSourceContent(t, r)); }, this);
      }, r.prototype._validateMapping = function (e, t, n, r) {
        if ((!(e && 'line' in e && 'column' in e && e.line > 0 && e.column >= 0) || t || n || r) && !(e && 'line' in e && 'column' in e && t && 'line' in t && 'column' in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && n)) {
          throw new Error(`Invalid mapping: ${JSON.stringify({
            generated: e, source: n, original: t, name: r,
          })}`);
        }
      }, r.prototype._serializeMappings = function () { for (var e, t = 0, n = 1, r = 0, s = 0, a = 0, u = 0, c = '', l = this._mappings.toArray(), p = 0, h = l.length; p < h; p++) { if ((e = l[p]).generatedLine !== n) for (t = 0; e.generatedLine !== n;)c += ';', n++; else if (p > 0) { if (!o.compareByGeneratedPositionsInflated(e, l[p - 1])) continue; c += ','; }c += i.encode(e.generatedColumn - t), t = e.generatedColumn, e.source != null && (c += i.encode(this._sources.indexOf(e.source) - u), u = this._sources.indexOf(e.source), c += i.encode(e.originalLine - 1 - s), s = e.originalLine - 1, c += i.encode(e.originalColumn - r), r = e.originalColumn, e.name != null && (c += i.encode(this._names.indexOf(e.name) - a), a = this._names.indexOf(e.name))); } return c; }, r.prototype._generateSourcesContent = function (e, t) { return e.map(function (e) { if (!this._sourcesContents) return null; t != null && (e = o.relative(t, e)); const n = o.toSetString(e); return Object.prototype.hasOwnProperty.call(this._sourcesContents, n) ? this._sourcesContents[n] : null; }, this); }, r.prototype.toJSON = function () {
        const e = {
          version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings(),
        }; return this._file != null && (e.file = this._file), this._sourceRoot != null && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e;
      }, r.prototype.toString = function () { return JSON.stringify(this.toJSON()); }, t.SourceMapGenerator = r;
    });
  }, {
    './array-set': 108, './base64-vlq': 109, './mapping-list': 112, './util': 117, amdefine: 4,
  }],
  116: [function (e, t, n) {
    if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => {
      function r(e, t, n, r, i) { this.children = [], this.sourceContents = {}, this.line = e == null ? null : e, this.column = t == null ? null : t, this.source = n == null ? null : n, this.name = i == null ? null : i, this[a] = !0, r != null && this.add(r); } const i = e('./source-map-generator').SourceMapGenerator; const o = e('./util'); const s = /(\r?\n)/; var a = '$$$isSourceNode$$$'; r.fromStringWithSourceMap = function (e, t, n) {
        function i(e, t) { if (e === null || void 0 === e.source)a.add(t); else { const i = n ? o.join(n, e.source) : e.source; a.add(new r(e.originalLine, e.originalColumn, i, t, e.name)); } } var a = new r();


        const u = e.split(s);


        const c = function () { return u.shift() + (u.shift() || ''); }; let l = 1;


        let p = 0; let
          h = null; return t.eachMapping((e) => { if (h !== null) { if (!(l < e.generatedLine)) { t = (n = u[0]).substr(0, e.generatedColumn - p); return u[0] = n.substr(e.generatedColumn - p), p = e.generatedColumn, i(h, t), void (h = e); } var t = ''; i(h, c()), l++, p = 0; } for (;l < e.generatedLine;)a.add(c()), l++; if (p < e.generatedColumn) { var n = u[0]; a.add(n.substr(0, e.generatedColumn)), u[0] = n.substr(e.generatedColumn), p = e.generatedColumn; }h = e; }, this), u.length > 0 && (h && i(h, c()), a.add(u.join(''))), t.sources.forEach((e) => { const r = t.sourceContentFor(e); r != null && (n != null && (e = o.join(n, e)), a.setSourceContent(e, r)); }), a;
      }, r.prototype.add = function (e) { if (Array.isArray(e))e.forEach(function (e) { this.add(e); }, this); else { if (!e[a] && typeof e !== 'string') throw new TypeError(`Expected a SourceNode, string, or an array of SourceNodes and strings. Got ${e}`); e && this.children.push(e); } return this; }, r.prototype.prepend = function (e) { if (Array.isArray(e)) for (let t = e.length - 1; t >= 0; t--) this.prepend(e[t]); else { if (!e[a] && typeof e !== 'string') throw new TypeError(`Expected a SourceNode, string, or an array of SourceNodes and strings. Got ${e}`); this.children.unshift(e); } return this; }, r.prototype.walk = function (e) {
        for (var t, n = 0, r = this.children.length; n < r; n++) {
          (t = this.children[n])[a] ? t.walk(e) : t !== '' && e(t, {
            source: this.source, line: this.line, column: this.column, name: this.name,
          });
        }
      }, r.prototype.join = function (e) { let t; let n; const r = this.children.length; if (r > 0) { for (t = [], n = 0; n < r - 1; n++)t.push(this.children[n]), t.push(e); t.push(this.children[n]), this.children = t; } return this; }, r.prototype.replaceRight = function (e, t) { const n = this.children[this.children.length - 1]; return n[a] ? n.replaceRight(e, t) : typeof n === 'string' ? this.children[this.children.length - 1] = n.replace(e, t) : this.children.push(''.replace(e, t)), this; }, r.prototype.setSourceContent = function (e, t) { this.sourceContents[o.toSetString(e)] = t; }, r.prototype.walkSourceContents = function (e) { for (var t = 0, n = this.children.length; t < n; t++) this.children[t][a] && this.children[t].walkSourceContents(e); for (var r = Object.keys(this.sourceContents), t = 0, n = r.length; t < n; t++)e(o.fromSetString(r[t]), this.sourceContents[r[t]]); }, r.prototype.toString = function () { let e = ''; return this.walk((t) => { e += t; }), e; }, r.prototype.toStringWithSourceMap = function (e) {
        const t = { code: '', line: 1, column: 0 }; const n = new i(e); let r = !1; let o = null; let s = null; let a = null; let u = null; return this.walk((e, i) => {
          t.code += e, i.source !== null && i.line !== null && i.column !== null ? (o === i.source && s === i.line && a === i.column && u === i.name || n.addMapping({
            source: i.source, original: { line: i.line, column: i.column }, generated: { line: t.line, column: t.column }, name: i.name,
          }), o = i.source, s = i.line, a = i.column, u = i.name, r = !0) : r && (n.addMapping({ generated: { line: t.line, column: t.column } }), o = null, r = !1); for (let c = 0, l = e.length; c < l; c++) {
            e.charCodeAt(c) === 10 ? (t.line++, t.column = 0, c + 1 === l ? (o = null, r = !1) : r && n.addMapping({
              source: i.source, original: { line: i.line, column: i.column }, generated: { line: t.line, column: t.column }, name: i.name,
            })) : t.column++;
          }
        }), this.walkSourceContents((e, t) => { n.setSourceContent(e, t); }), { code: t.code, map: n };
      }, t.SourceNode = r;
    });
  }, { './source-map-generator': 115, './util': 117, amdefine: 4 }],
  117: [function (e, t, n) {
    if (typeof r !== 'function') var r = e('amdefine')(t, e); r((e, t, n) => {
      function r(e) {
        const t = e.match(a); return t ? {
          scheme: t[1], auth: t[2], host: t[3], port: t[4], path: t[5],
        } : null;
      } function i(e) { let t = ''; return e.scheme && (t += `${e.scheme}:`), t += '//', e.auth && (t += `${e.auth}@`), e.host && (t += e.host), e.port && (t += `:${e.port}`), e.path && (t += e.path), t; } function o(e) { let t = e; const n = r(e); if (n) { if (!n.path) return e; t = n.path; } for (var o, s = t.charAt(0) === '/', a = t.split(/\/+/), u = 0, c = a.length - 1; c >= 0; c--)(o = a[c]) === '.' ? a.splice(c, 1) : o === '..' ? u++ : u > 0 && (o === '' ? (a.splice(c + 1, u), u = 0) : (a.splice(c, 2), u--)); return (t = a.join('/')) === '' && (t = s ? '/' : '.'), n ? (n.path = t, i(n)) : t; } function s(e, t) { return e === t ? 0 : e > t ? 1 : -1; }t.getArg = function (e, t, n) { if (t in e) return e[t]; if (arguments.length === 3) return n; throw new Error(`"${t}" is a required argument.`); }; var a = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/; const u = /^data:.+\,.+$/; t.urlParse = r, t.urlGenerate = i, t.normalize = o, t.join = function (e, t) { e === '' && (e = '.'), t === '' && (t = '.'); const n = r(t); const s = r(e); if (s && (e = s.path || '/'), n && !n.scheme) return s && (n.scheme = s.scheme), i(n); if (n || t.match(u)) return t; if (s && !s.host && !s.path) return s.host = t, i(s); const a = t.charAt(0) === '/' ? t : o(`${e.replace(/\/+$/, '')}/${t}`); return s ? (s.path = a, i(s)) : a; }, t.relative = function (e, t) { e === '' && (e = '.'), e = e.replace(/\/$/, ''); for (var n = 0; t.indexOf(`${e}/`) !== 0;) { const r = e.lastIndexOf('/'); if (r < 0) return t; if ((e = e.slice(0, r)).match(/^([^\/]+:\/)?\/*$/)) return t; ++n; } return Array(n + 1).join('../') + t.substr(e.length + 1); }, t.toSetString = function (e) { return `$${e}`; }, t.fromSetString = function (e) { return e.substr(1); }, t.compareByOriginalPositions = function (e, t, n) { let r = e.source - t.source; return r !== 0 ? r : (r = e.originalLine - t.originalLine) != 0 ? r : (r = e.originalColumn - t.originalColumn) != 0 || n ? r : (r = e.generatedColumn - t.generatedColumn) != 0 ? r : (r = e.generatedLine - t.generatedLine) != 0 ? r : e.name - t.name; }, t.compareByGeneratedPositionsDeflated = function (e, t, n) { let r = e.generatedLine - t.generatedLine; return r !== 0 ? r : (r = e.generatedColumn - t.generatedColumn) != 0 || n ? r : (r = e.source - t.source) != 0 ? r : (r = e.originalLine - t.originalLine) != 0 ? r : (r = e.originalColumn - t.originalColumn) != 0 ? r : e.name - t.name; }, t.compareByGeneratedPositionsInflated = function (e, t) { let n = e.generatedLine - t.generatedLine; return n !== 0 ? n : (n = e.generatedColumn - t.generatedColumn) != 0 ? n : (n = s(e.source, t.source)) !== 0 ? n : (n = e.originalLine - t.originalLine) != 0 ? n : (n = e.originalColumn - t.originalColumn) != 0 ? n : s(e.name, t.name); };
    });
  }, { amdefine: 4 }],
  118: [function (e, t, n) {
    function r() { throw e('pug-error')(...arguments); } function i(e) { h(e.type === 'Block', 'The top level element should always be a block'); let t = null; if (e.nodes.length) { const n = e.nodes[0].type === 'Extends'; p(e, n), n && (t = e.nodes.shift()); } if (e = u(e), e.declaredBlocks = o(e), t) { const s = []; const c = []; e.nodes.forEach(function e(t) { t.type === 'NamedBlock' ? c.push(t) : t.type === 'Block' ? t.nodes.forEach(e) : t.type === 'Mixin' && !1 === t.call ? s.push(t) : r('UNEXPECTED_NODES_IN_EXTENDING_ROOT', 'Only named blocks and mixins can appear at the top level of an extending template', t); }); const l = i(t.file.ast); a(l.declaredBlocks, e); const d = []; return f(l, (e) => { e.type === 'NamedBlock' && d.push(e.name); }), c.forEach((e) => { d.indexOf(e.name) === -1 && r('UNEXPECTED_BLOCK', `Unexpected block ${e.name}`, e); }), Object.keys(e.declaredBlocks).forEach((t) => { l.declaredBlocks[t] = e.declaredBlocks[t]; }), l.nodes = s.concat(l.nodes), l.hasExtends = !0, l; } return e; } function o(e) { const t = {}; return f(e, (e) => { e.type === 'NamedBlock' && e.mode === 'replace' && (t[e.name] = t[e.name] || [], t[e.name].push(e)); }), t; } function s(e, t) { return t = t || [], e.forEach((e) => { e.parents && s(e.parents, t), t.push(e); }), t; } function a(e, t) { const n = {}; f(t, (t) => { if (t.type === 'NamedBlock') { if (n[t.name] === t.name) return t.ignore = !0; n[t.name] = t.name; const r = e[t.name] ? s(e[t.name]) : []; r.length && (t.parents = r, r.forEach((e) => { switch (t.mode) { case 'append': e.nodes = e.nodes.concat(t.nodes); break; case 'prepend': e.nodes = t.nodes.concat(e.nodes); break; case 'replace': e.nodes = t.nodes; } })); } }, (e) => { e.type !== 'NamedBlock' || e.ignore || delete n[e.name]; }); } function u(e, t) { return f(e, (e, t) => { e.type === 'RawInclude' && t({ type: 'Text', val: e.file.str.replace(/\r/g, '') }); }, (e, t) => { if (e.type === 'Include') { let n = i(e.file.ast); n.hasExtends && (n = c(n)), t(l(n, e.block)); } }); } function c(e) { return f(e, (e, t) => { e.type === 'NamedBlock' && t({ type: 'Block', nodes: e.nodes }); }); } function l(e, t) { function n(e) { for (var t = e, r = 0; r < e.nodes.length; r++)e.nodes[r].textOnly || (e.nodes[r].type === 'Block' ? t = n(e.nodes[r]) : e.nodes[r].block && e.nodes[r].block.nodes.length && (t = n(e.nodes[r].block))); return t; } if (!t || !t.nodes.length) return e; let r = !1; return e = f(e, null, (e, n) => { e.type === 'YieldBlock' && (r = !0, e.type = 'Block', e.nodes = [t]); }), r || n(e).nodes.push(t), e; } function p(e, t) { let n = !1; f(e, (e) => { e.type === 'Extends' && (t && !n ? n = !0 : r('EXTENDS_NOT_FIRST', 'Declaration of template inheritance ("extends") should be the first thing in the file. There can only be one extends statement per file.', e)); }); } var h = e('assert'); var f = e('pug-walk'); t.exports = i;
  }, { assert: 7, 'pug-error': 42, 'pug-walk': 129 }],
  119: [function (e, t, n) {
    function r(e, t) { return t = i(t), e = JSON.parse(JSON.stringify(e)), a(e, (e) => { if (void 0 === e.str && (e.type === 'Include' || e.type === 'RawInclude' || e.type === 'Extends')) { const n = e.file; if (n.type !== 'FileReference') throw new Error('Expected file.type to be "FileReference"'); let i; let o; try { i = t.resolve(n.path, n.filename, t), n.fullPath = i, o = t.read(i, t); } catch (t) { throw t.message += `\n    at ${e.filename} line ${e.line}`, t; }n.str = o, e.type !== 'Extends' && e.type !== 'Include' || (n.ast = r.string(o, u({}, t, { filename: i }))); } }); } function i(e) { return r.validateOptions(e), u({ resolve: r.resolve, read: r.read }, e); } const o = e('fs'); const s = e('path'); var a = e('pug-walk'); var u = e('object-assign'); t.exports = r, r.string = function (e, t) { const n = (t = u(i(t), { src: e })).lex(e, t); return r(t.parse(n, t), t); }, r.file = function (e, t) { const n = (t = u(i(t), { filename: e })).read(e); return r.string(n, t); }, r.resolve = function (e, t, n) { if ((e = e.trim())[0] !== '/' && !t) throw new Error('the "filename" option is required to use includes and extends with "relative" paths'); if (e[0] === '/' && !n.basedir) throw new Error('the "basedir" option is required to use includes and extends with "absolute" paths'); return e = s.join(e[0] === '/' ? n.basedir : s.dirname(t.trim()), e); }, r.read = function (e, t) { return o.readFileSync(e, 'utf8'); }, r.validateOptions = function (e) { if (typeof e !== 'object') throw new TypeError('options must be an object'); if (typeof e.lex !== 'function') throw new TypeError('options.lex must be a function'); if (typeof e.parse !== 'function') throw new TypeError('options.parse must be a function'); if (e.resolve && typeof e.resolve !== 'function') throw new TypeError('options.resolve must be a function'); if (e.read && typeof e.read !== 'function') throw new TypeError('options.read must be a function'); };
  }, {
    fs: 10, 'object-assign': 28, path: 30, 'pug-walk': 129,
  }],
  120: [function (e, t, n) {
    function r(e, t) { if (t = t || {}, !Array.isArray(e)) throw new Error(`Expected tokens to be an Array but got "${typeof e}"`); if (typeof t !== 'object') throw new Error(`Expected "options" to be an object but got "${typeof t}"`); this.tokens = new o(e), this.filename = t.filename, this.src = t.src, this.inMixin = 0, this.plugins = t.plugins || []; } const i = e('assert'); var o = e('token-stream'); const s = e('pug-error'); const a = e('./lib/inline-tags'); t.exports = function (e, t) { const n = new r(e, t).parse(); return JSON.parse(JSON.stringify(n)); }, t.exports.Parser = r, r.prototype = {
      constructor: r,
      error(e, t, n) {
        throw s(e, t, {
          line: n.line, column: n.col, filename: this.filename, src: this.src,
        });
      },
      advance() { return this.tokens.advance(); },
      peek() { return this.tokens.peek(); },
      lookahead(e) { return this.tokens.lookahead(e); },
      parse() { for (var e = this.emptyBlock(0); this.peek().type != 'eos';) if (this.peek().type == 'newline') this.advance(); else if (this.peek().type == 'text-html')e.nodes = e.nodes.concat(this.parseTextHtml()); else { const t = this.parseExpr(); t && (t.type === 'Block' ? e.nodes = e.nodes.concat(t.nodes) : e.nodes.push(t)); } return e; },
      expect(e) { if (this.peek().type === e) return this.advance(); this.error('INVALID_TOKEN', `expected "${e}", but got "${this.peek().type}"`, this.peek()); },
      accept(e) { if (this.peek().type === e) return this.advance(); },
      initBlock(e, t) {
        if ((0 | e) !== e) throw new Error('`line` is not an integer'); if (!Array.isArray(t)) throw new Error('`nodes` is not an array'); return {
          type: 'Block', nodes: t, line: e, filename: this.filename,
        };
      },
      emptyBlock(e) { return this.initBlock(e, []); },
      runPlugin(e, t) { for (var n = [this], r = 2; r < arguments.length; r++)n.push(arguments[r]); for (var i, r = 0; r < this.plugins.length; r++) { const o = this.plugins[r]; if (o[e] && o[e][t.type]) { if (i) throw new Error(`Multiple plugin handlers found for context ${JSON.stringify(e)}, token type ${JSON.stringify(t.type)}`); i = o[e]; } } if (i) return i[t.type](...n); },
      parseExpr() {
        switch (this.peek().type) {
          case 'tag': return this.parseTag(); case 'mixin': return this.parseMixin(); case 'block': return this.parseBlock(); case 'mixin-block': return this.parseMixinBlock(); case 'case': return this.parseCase(); case 'extends': return this.parseExtends(); case 'include': return this.parseInclude(); case 'doctype': return this.parseDoctype(); case 'filter': return this.parseFilter(); case 'comment': return this.parseComment(); case 'text': case 'interpolated-code': case 'start-pug-interpolation': return this.parseText({ block: !0 }); case 'text-html': return this.initBlock(this.peek().line, this.parseTextHtml()); case 'dot': return this.parseDot(); case 'each': return this.parseEach(); case 'code': return this.parseCode(); case 'blockcode': return this.parseBlockCode(); case 'if': return this.parseConditional(); case 'while': return this.parseWhile(); case 'call': return this.parseCall(); case 'interpolation': return this.parseInterpolation(); case 'yield': return this.parseYield(); case 'id': case 'class': return this.tokens.defer({
            type: 'tag', val: 'div', line: this.peek().line, col: this.peek().col, filename: this.filename,
          }), this.parseExpr(); default: var e = this.runPlugin('expressionTokens', this.peek()); if (e) return e; this.error('INVALID_TOKEN', `unexpected token "${this.peek().type}"`, this.peek());
        }
      },
      parseDot() { return this.advance(), this.parseTextBlock(); },
      parseText(e) {
        const t = []; const n = this.peek().line; let r = this.peek(); e:for (;;) {
          switch (r.type) {
            case 'text': i = this.advance(); t.push({
              type: 'Text', val: i.val, line: i.line, column: i.col, filename: this.filename,
            }); break; case 'interpolated-code': i = this.advance(); t.push({
              type: 'Code', val: i.val, buffer: i.buffer, mustEscape: !1 !== i.mustEscape, isInline: !0, line: i.line, column: i.col, filename: this.filename,
            }); break; case 'newline': if (!e || !e.block) break e; var i = this.advance(); var o = this.peek().type; o !== 'text' && o !== 'interpolated-code' || t.push({
              type: 'Text', val: '\n', line: i.line, column: i.col, filename: this.filename,
            }); break; case 'start-pug-interpolation': this.advance(), t.push(this.parseExpr()), this.expect('end-pug-interpolation'); break; default: if (this.runPlugin('textTokens', r, t)) break; break e;
          }r = this.peek();
        } return t.length === 1 ? t[0] : this.initBlock(n, t);
      },
      parseTextHtml() {
        const e = []; let t = null; e:for (;;) {
          switch (this.peek().type) {
            case 'text-html': var n = this.advance(); t ? t.val += `\n${n.val}` : (t = {
              type: 'Text', val: n.val, filename: this.filename, line: n.line, column: n.col, isHtml: !0,
            }, e.push(t)); break; case 'indent': this.block().nodes.forEach((n) => { n.isHtml ? t ? t.val += `\n${n.val}` : (t = n, e.push(t)) : (t = null, e.push(n)); }); break; case 'code': t = null, e.push(this.parseCode(!0)); break; case 'newline': this.advance(); break; default: break e;
          }
        } return e;
      },
      parseBlockExpansion() { const e = this.accept(':'); if (e) { const t = this.parseExpr(); return t.type === 'Block' ? t : this.initBlock(e.line, [t]); } return this.block(); },
      parseCase() {
        const e = this.expect('case'); const t = {
          type: 'Case', expr: e.val, line: e.line, column: e.col, filename: this.filename,
        }; const n = this.emptyBlock(e.line + 1); for (this.expect('indent'); this.peek().type != 'outdent';) switch (this.peek().type) { case 'comment': case 'newline': this.advance(); break; case 'when': n.nodes.push(this.parseWhen()); break; case 'default': n.nodes.push(this.parseDefault()); break; default: if (this.runPlugin('caseTokens', this.peek(), n)) break; this.error('INVALID_TOKEN', `Unexpected token "${this.peek().type}", expected "when", "default" or "newline"`, this.peek()); } return this.expect('outdent'), t.block = n, t;
      },
      parseWhen() {
        const e = this.expect('when'); return this.peek().type !== 'newline' ? {
          type: 'When', expr: e.val, block: this.parseBlockExpansion(), debug: !1, line: e.line, column: e.col, filename: this.filename,
        } : {
          type: 'When', expr: e.val, debug: !1, line: e.line, column: e.col, filename: this.filename,
        };
      },
      parseDefault() {
        const e = this.expect('default'); return {
          type: 'When', expr: 'default', block: this.parseBlockExpansion(), debug: !1, line: e.line, column: e.col, filename: this.filename,
        };
      },
      parseCode(e) {
        const t = this.expect('code'); i(typeof t.mustEscape === 'boolean', 'Please update to the newest version of pug-lexer.'); const n = {
          type: 'Code', val: t.val, buffer: t.buffer, mustEscape: !1 !== t.mustEscape, isInline: !!e, line: t.line, column: t.col, filename: this.filename,
        }; if (n.val.match(/^ *else/) && (n.debug = !1), e) return n; return this.peek().type == 'indent' && (t.buffer && this.error('BLOCK_IN_BUFFERED_CODE', 'Buffered code cannot have a block attached to it', this.peek()), n.block = this.block()), n;
      },
      parseConditional() {
        let e = this.expect('if'); const t = {
          type: 'Conditional', test: e.val, consequent: this.emptyBlock(e.line), alternate: null, line: e.line, column: e.col, filename: this.filename,
        }; this.peek().type == 'indent' && (t.consequent = this.block()); for (let n = t; ;) {
          if (this.peek().type === 'newline') this.expect('newline'); else {
            if (this.peek().type !== 'else-if') { if (this.peek().type === 'else') { this.expect('else'), this.peek().type === 'indent' && (n.alternate = this.block()); break; } break; }e = this.expect('else-if'), n = n.alternate = {
              type: 'Conditional', test: e.val, consequent: this.emptyBlock(e.line), alternate: null, line: e.line, column: e.col, filename: this.filename,
            }, this.peek().type == 'indent' && (n.consequent = this.block());
          }
        } return t;
      },
      parseWhile() {
        const e = this.expect('while'); const t = {
          type: 'While', test: e.val, line: e.line, column: e.col, filename: this.filename,
        }; return this.peek().type == 'indent' ? t.block = this.block() : t.block = this.emptyBlock(e.line), t;
      },
      parseBlockCode() {
        let e = this.expect('blockcode'); const t = e.line; const n = e.col; let r = ''; if (this.peek().type === 'start-pipeless-text') { for (this.advance(); this.peek().type !== 'end-pipeless-text';) switch ((e = this.advance()).type) { case 'text': r += e.val; break; case 'newline': r += '\n'; break; default: var i = this.runPlugin('blockCodeTokens', e, e); if (i) { r += i; break; } this.error('INVALID_TOKEN', `Unexpected token type: ${e.type}`, e); } this.advance(); } return {
          type: 'Code', val: r, buffer: !1, mustEscape: !1, isInline: !1, line: t, column: n, filename: this.filename,
        };
      },
      parseComment() {
        let e; const t = this.expect('comment'); return (e = this.parseTextBlock()) ? {
          type: 'BlockComment', val: t.val, block: e, buffer: t.buffer, line: t.line, column: t.col, filename: this.filename,
        } : {
          type: 'Comment', val: t.val, buffer: t.buffer, line: t.line, column: t.col, filename: this.filename,
        };
      },
      parseDoctype() {
        const e = this.expect('doctype'); return {
          type: 'Doctype', val: e.val, line: e.line, column: e.col, filename: this.filename,
        };
      },
      parseIncludeFilter() {
        const e = this.expect('filter'); let t = []; return this.peek().type === 'start-attributes' && (t = this.attrs()), {
          type: 'IncludeFilter', name: e.val, attrs: t, line: e.line, column: e.col, filename: this.filename,
        };
      },
      parseFilter() {
        let e; const t = this.expect('filter'); let n = []; if (this.peek().type === 'start-attributes' && (n = this.attrs()), this.peek().type === 'text') {
          const r = this.advance(); e = this.initBlock(r.line, [{
            type: 'Text', val: r.val, line: r.line, column: r.col, filename: this.filename,
          }]);
        } else e = this.peek().type === 'filter' ? this.initBlock(t.line, [this.parseFilter()]) : this.parseTextBlock() || this.emptyBlock(t.line); return {
          type: 'Filter', name: t.val, block: e, attrs: n, line: t.line, column: t.col, filename: this.filename,
        };
      },
      parseEach() {
        const e = this.expect('each'); const t = {
          type: 'Each', obj: e.code, val: e.val, key: e.key, block: this.block(), line: e.line, column: e.col, filename: this.filename,
        }; return this.peek().type == 'else' && (this.advance(), t.alternate = this.block()), t;
      },
      parseExtends() {
        const e = this.expect('extends'); const t = this.expect('path'); return {
          type: 'Extends',
          file: {
            type: 'FileReference', path: t.val.trim(), line: t.line, column: t.col, filename: this.filename,
          },
          line: e.line,
          column: e.col,
          filename: this.filename,
        };
      },
      parseBlock() { const e = this.expect('block'); const t = this.peek().type == 'indent' ? this.block() : this.emptyBlock(e.line); return t.type = 'NamedBlock', t.name = e.val.trim(), t.mode = e.mode, t.line = e.line, t.column = e.col, t; },
      parseMixinBlock() {
        const e = this.expect('mixin-block'); return this.inMixin || this.error('BLOCK_OUTISDE_MIXIN', 'Anonymous blocks are not allowed unless they are part of a mixin.', e), {
          type: 'MixinBlock', line: e.line, column: e.col, filename: this.filename,
        };
      },
      parseYield() {
        const e = this.expect('yield'); return {
          type: 'YieldBlock', line: e.line, column: e.col, filename: this.filename,
        };
      },
      parseInclude() {
        for (var e = this.expect('include'), t = {
            type: 'Include', file: { type: 'FileReference', filename: this.filename }, line: e.line, column: e.col, filename: this.filename,
          }, n = []; this.peek().type === 'filter';)n.push(this.parseIncludeFilter()); const r = this.expect('path'); return t.file.path = r.val.trim(), t.file.line = r.line, t.file.column = r.col, !/\.jade$/.test(t.file.path) && !/\.pug$/.test(t.file.path) || n.length ? (t.type = 'RawInclude', t.filters = n, this.peek().type === 'indent' && this.error('RAW_INCLUDE_BLOCK', 'Raw inclusion cannot contain a block', this.peek())) : (t.block = this.peek().type == 'indent' ? this.block() : this.emptyBlock(e.line), /\.jade$/.test(t.file.path) && console.warn(`${this.filename}, line ${e.line}:\nThe .jade extension is deprecated, use .pug for "${t.file.path}".`)), t;
      },
      parseCall() {
        const e = this.expect('call'); const t = {
          type: 'Mixin', name: e.val, args: e.args, block: this.emptyBlock(e.line), call: !0, attrs: [], attributeBlocks: [], line: e.line, column: e.col, filename: this.filename,
        }; return this.tag(t), t.code && (t.block.nodes.push(t.code), delete t.code), t.block.nodes.length === 0 && (t.block = null), t;
      },
      parseMixin() {
        const e = this.expect('mixin'); const t = e.val; const n = e.args; if (this.peek().type == 'indent') {
          this.inMixin++; const r = {
            type: 'Mixin', name: t, args: n, block: this.block(), call: !1, line: e.line, column: e.col, filename: this.filename,
          }; return this.inMixin--, r;
        } this.error('MIXIN_WITHOUT_BODY', `Mixin ${t} declared without body`, e);
      },
      parseTextBlock() {
        let e = this.accept('start-pipeless-text'); if (e) {
          for (var t = this.emptyBlock(e.line); this.peek().type !== 'end-pipeless-text';) {
            switch ((e = this.advance()).type) {
              case 'text': t.nodes.push({
                type: 'Text', val: e.val, line: e.line, column: e.col, filename: this.filename,
              }); break; case 'newline': t.nodes.push({
                type: 'Text', val: '\n', line: e.line, column: e.col, filename: this.filename,
              }); break; case 'start-pug-interpolation': t.nodes.push(this.parseExpr()), this.expect('end-pug-interpolation'); break; case 'interpolated-code': t.nodes.push({
                type: 'Code', val: e.val, buffer: e.buffer, mustEscape: !1 !== e.mustEscape, isInline: !0, line: e.line, column: e.col, filename: this.filename,
              }); break; default: if (this.runPlugin('textBlockTokens', e, t, e)) break; this.error('INVALID_TOKEN', `Unexpected token type: ${e.type}`, e);
            }
          } return this.advance(), t;
        }
      },
      block() { for (var e = this.expect('indent'), t = this.emptyBlock(e.line); this.peek().type != 'outdent';) if (this.peek().type == 'newline') this.advance(); else if (this.peek().type == 'text-html')t.nodes = t.nodes.concat(this.parseTextHtml()); else { const n = this.parseExpr(); n.type === 'Block' ? t.nodes = t.nodes.concat(n.nodes) : t.nodes.push(n); } return this.expect('outdent'), t; },
      parseInterpolation() {
        const e = this.advance(); const t = {
          type: 'InterpolatedTag', expr: e.val, selfClosing: !1, block: this.emptyBlock(e.line), attrs: [], attributeBlocks: [], isInline: !1, line: e.line, column: e.col, filename: this.filename,
        }; return this.tag(t, { selfClosingAllowed: !0 });
      },
      parseTag() {
        const e = this.advance(); const t = {
          type: 'Tag', name: e.val, selfClosing: !1, block: this.emptyBlock(e.line), attrs: [], attributeBlocks: [], isInline: a.indexOf(e.val) !== -1, line: e.line, column: e.col, filename: this.filename,
        }; return this.tag(t, { selfClosingAllowed: !0 });
      },
      tag(e, t) {
        let n = !1; const r = []; const i = t && t.selfClosingAllowed; e:for (;;) {
          switch (this.peek().type) {
            case 'id': case 'class': (o = this.advance()).type === 'id' && (r.indexOf('id') !== -1 && this.error('DUPLICATE_ID', 'Duplicate attribute "id" is not allowed.', o), r.push('id')), e.attrs.push({
              name: o.type, val: `'${o.val}'`, line: o.line, column: o.col, filename: this.filename, mustEscape: !1,
            }); continue; case 'start-attributes': n && console.warn(`${this.filename}, line ${this.peek().line}:\nYou should not have pug tags with multiple attributes.`), n = !0, e.attrs = e.attrs.concat(this.attrs(r)); continue; case '&attributes': var o = this.advance(); e.attributeBlocks.push({
              type: 'AttributeBlock', val: o.val, line: o.line, column: o.col, filename: this.filename,
            }); break; default: if (u = this.runPlugin('tagAttributeTokens', this.peek(), e, r)) break; break e;
          }
        } switch (this.peek().type == 'dot' && (e.textOnly = !0, this.advance()), this.peek().type) { case 'text': case 'interpolated-code': var s = this.parseText(); s.type === 'Block' ? e.block.nodes.push.apply(e.block.nodes, s.nodes) : e.block.nodes.push(s); break; case 'code': e.block.nodes.push(this.parseCode(!0)); break; case ':': this.advance(); var a = this.parseExpr(); e.block = a.type === 'Block' ? a : this.initBlock(e.line, [a]); break; case 'newline': case 'indent': case 'outdent': case 'eos': case 'start-pipeless-text': case 'end-pug-interpolation': break; case 'slash': if (i) { this.advance(), e.selfClosing = !0; break; } default: var u = this.runPlugin('tagTokens', this.peek(), e, t); if (u) break; this.error('INVALID_TOKEN', `Unexpected token \`${this.peek().type}\` expected \`text\`, \`interpolated-code\`, \`code\`, \`:\`${i ? ', `slash`' : ''}, \`newline\` or \`eos\``, this.peek()); } for (;this.peek().type == 'newline';) this.advance(); if (e.textOnly)e.block = this.parseTextBlock() || this.emptyBlock(e.line); else if (this.peek().type == 'indent') for (let c = this.block(), l = 0, p = c.nodes.length; l < p; ++l)e.block.nodes.push(c.nodes[l]); return e;
      },
      attrs(e) {
        this.expect('start-attributes'); for (var t = [], n = this.advance(); n.type === 'attribute';) {
          n.name !== 'class' && e && (e.indexOf(n.name) !== -1 && this.error('DUPLICATE_ATTRIBUTE', `Duplicate attribute "${n.name}" is not allowed.`, n), e.push(n.name)), t.push({
            name: n.name, val: n.val, line: n.line, column: n.col, filename: this.filename, mustEscape: !1 !== n.mustEscape,
          }), n = this.advance();
        } return this.tokens.defer(n), this.expect('end-attributes'), t;
      },
    };
  }, {
    './lib/inline-tags': 121, assert: 7, 'pug-error': 42, 'token-stream': 146,
  }],
  121: [function (e, t, n) {
    t.exports = ['a', 'abbr', 'acronym', 'b', 'br', 'code', 'em', 'font', 'i', 'img', 'ins', 'kbd', 'map', 'samp', 'small', 'span', 'strong', 'sub', 'sup'];
  }, {}],
  122: [function (e, t, n) {
    e('fs'); const r = e('./lib/dependencies.js'); const i = e('./lib/internals.js'); const o = e('./lib/sources.js'); t.exports = function (e) { const t = []; e = e.filter(e => !i[e]); for (let n = 0; n < e.length; n++)t.indexOf(e[n]) === -1 && (t.push(e[n]), e.push(...r[e[n]])); return t.sort().map(e => o[e]).join('\n'); };
  }, {
    './lib/dependencies.js': 124, './lib/internals.js': 125, './lib/sources.js': 126, fs: 9,
  }],
  123: [function (e, t, n) {
    function r(e, t) { if (arguments.length === 1) { for (var n = e[0], i = 1; i < e.length; i++)n = r(n, e[i]); return n; } for (const o in t) if (o === 'class') { s = e[o] || []; e[o] = (Array.isArray(s) ? s : [s]).concat(t[o] || []); } else if (o === 'style') { var s = a(e[o]); const u = a(t[o]); e[o] = s + u; } else e[o] = t[o]; return e; } function i(e, t) { for (var n, r = '', i = '', o = Array.isArray(t), a = 0; a < e.length; a++)(n = s(e[a])) && (o && t[a] && (n = c(n)), r = r + i + n, i = ' '); return r; } function o(e) { let t = ''; let n = ''; for (const r in e)r && e[r] && p.call(e, r) && (t = t + n + r, n = ' '); return t; } function s(e, t) { return Array.isArray(e) ? i(e, t) : e && typeof e === 'object' ? o(e) : e || ''; } function a(e) { if (!e) return ''; if (typeof e === 'object') { let t = ''; for (const n in e)p.call(e, n) && (t = `${t + n}:${e[n]};`); return t; } return (e += '')[e.length - 1] !== ';' ? `${e};` : e; } function u(e, t, n, r) { return !1 !== t && t != null && (t || e !== 'class' && e !== 'style') ? !0 === t ? ` ${r ? e : `${e}="${e}"`}` : (typeof t.toJSON === 'function' && (t = t.toJSON()), typeof t === 'string' || (t = JSON.stringify(t), n || t.indexOf('"') === -1) ? (n && (t = c(t)), ` ${e}="${t}"`) : ` ${e}='${t.replace(/'/g, '&#39;')}'`) : ''; } function c(e) { const t = `${e}`; const n = h.exec(t); if (!n) return e; let r; let i; let o; let s = ''; for (r = n.index, i = 0; r < t.length; r++) { switch (t.charCodeAt(r)) { case 34: o = '&quot;'; break; case 38: o = '&amp;'; break; case 60: o = '&lt;'; break; case 62: o = '&gt;'; break; default: continue; }i !== r && (s += t.substring(i, r)), i = r + 1, s += o; } return i !== r ? s + t.substring(i, r) : s; } function l(t, n, r, i) { if (!(t instanceof Error)) throw t; if (!(typeof window === 'undefined' && n || i)) throw t.message += ` on line ${r}`, t; try { i = i || e('fs').readFileSync(n, 'utf8'); } catch (e) { l(t, null, r); } var o = 3; const s = i.split('\n'); const a = Math.max(r - o, 0); const u = Math.min(s.length, r + o); var o = s.slice(a, u).map((e, t) => { const n = t + a + 1; return `${(n == r ? '  > ' : '    ') + n}| ${e}`; }).join('\n'); throw t.path = n, t.message = `${n || 'Pug'}:${r}\n${o}\n\n${t.message}`, t; } var p = Object.prototype.hasOwnProperty; n.merge = r, n.classes = s, n.style = a, n.attr = u, n.attrs = function (e, t) { let n = ''; for (const r in e) if (p.call(e, r)) { let i = e[r]; if (r === 'class') { n = u(r, i = s(i), !1, t) + n; continue; }r === 'style' && (i = a(i)), n += u(r, i, !1, t); } return n; }; var h = /["&<>]/; n.escape = c, n.rethrow = l;
  }, { fs: 9 }],
  124: [function (e, t, n) {
    t.exports = {
      has_own_property: [], merge: ['style'], classes_array: ['classes', 'escape'], classes_object: ['has_own_property'], classes: ['classes_array', 'classes_object'], style: ['has_own_property'], attr: ['escape'], attrs: ['attr', 'classes', 'has_own_property', 'style'], match_html: [], escape: ['match_html'], rethrow: [],
    };
  }, {}],
  125: [function (e, t, n) {
    t.exports = {
      dependencies: !0, internals: !0, has_own_property: !0, classes_array: !0, classes_object: !0, match_html: !0,
    };
  }, {}],
  126: [function (e, t, n) {
    t.exports = {
      has_own_property: 'var pug_has_own_property=Object.prototype.hasOwnProperty;', merge: 'function pug_merge(r,e){if(1===arguments.length){for(var t=r[0],a=1;a<r.length;a++)t=pug_merge(t,r[a]);return t}for(var g in e)if("class"===g){var l=r[g]||[];r[g]=(Array.isArray(l)?l:[l]).concat(e[g]||[])}else if("style"===g){var l=pug_style(r[g]),n=pug_style(e[g]);r[g]=l+n}else r[g]=e[g];return r}', classes_array: 'function pug_classes_array(r,a){for(var s,e="",u="",c=Array.isArray(a),g=0;g<r.length;g++)s=pug_classes(r[g]),s&&(c&&a[g]&&(s=pug_escape(s)),e=e+u+s,u=" ");return e}', classes_object: 'function pug_classes_object(r){var a="",n="";for(var o in r)o&&r[o]&&pug_has_own_property.call(r,o)&&(a=a+n+o,n=" ");return a}', classes: 'function pug_classes(s,r){return Array.isArray(s)?pug_classes_array(s,r):s&&"object"==typeof s?pug_classes_object(s):s||""}', style: 'function pug_style(r){if(!r)return"";if("object"==typeof r){var t="";for(var e in r)pug_has_own_property.call(r,e)&&(t=t+e+":"+r[e]+";");return t}return r+="",";"!==r[r.length-1]?r+";":r}', attr: 'function pug_attr(t,e,n,f){return e!==!1&&null!=e&&(e||"class"!==t&&"style"!==t)?e===!0?" "+(f?t:t+\'="\'+t+\'"\'):("function"==typeof e.toJSON&&(e=e.toJSON()),"string"==typeof e||(e=JSON.stringify(e),n||e.indexOf(\'"\')===-1)?(n&&(e=pug_escape(e))," "+t+\'="\'+e+\'"\'):" "+t+"=\'"+e.replace(/\'/g,"&#39;")+"\'"):""}', attrs: 'function pug_attrs(t,r){var a="";for(var s in t)if(pug_has_own_property.call(t,s)){var u=t[s];if("class"===s){u=pug_classes(u),a=pug_attr(s,u,!1,r)+a;continue}"style"===s&&(u=pug_style(u)),a+=pug_attr(s,u,!1,r)}return a}', match_html: 'var pug_match_html=/["&<>]/;', escape: 'function pug_escape(e){var a=""+e,t=pug_match_html.exec(a);if(!t)return e;var r,c,n,s="";for(r=t.index,c=0;r<a.length;r++){switch(a.charCodeAt(r)){case 34:n="&quot;";break;case 38:n="&amp;";break;case 60:n="&lt;";break;case 62:n="&gt;";break;default:continue}c!==r&&(s+=a.substring(c,r)),c=r+1,s+=n}return c!==r?s+a.substring(c,r):s}', rethrow: 'function pug_rethrow(n,e,r,t){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&e||t))throw n.message+=" on line "+r,n;try{t=t||require("fs").readFileSync(e,"utf8")}catch(e){pug_rethrow(n,null,r)}var i=3,a=t.split("\\n"),o=Math.max(r-i,0),h=Math.min(a.length,r+i),i=a.slice(o,h).map(function(n,e){var t=e+o+1;return(t==r?"  > ":"    ")+t+"| "+n}).join("\\n");throw n.path=e,n.message=(e||"Pug")+":"+r+"\\n"+i+"\\n\\n"+n.message,n}',
    };
  }, {}],
  127: [function (e, t, n) { const r = e('./'); t.exports = function (e, t) { return t = t || 'template', Function('pug', `${e}\nreturn ${t};`)(r); }; }, { './': 123 }],
  128: [function (e, t, n) {
    function r(e, t, n, r) { throw i('UNEXPECTED_TOKEN', `\`${e}\` encountered when ${t}`, { filename: n, line: r }); } var i = e('pug-error'); t.exports = function (e, t) { const n = !1 !== (t = t || {}).stripUnbuffered; const i = !0 === t.stripBuffered; const o = t.filename; let s = !1; let a = !1; return e.filter((e) => { switch (e.type) { case 'comment': if (!s) return !(s = e.buffer ? i : n); r('comment', 'already in a comment', o, e.line); case 'start-pipeless-text': return !s || (a && r('start-pipeless-text', 'already in pipeless text mode', o, e.line), a = !0, !1); case 'end-pipeless-text': return !s || (a || r('end-pipeless-text', 'not in pipeless text mode', o, e.line), a = !1, s = !1, !1); case 'text': return !s; default: return !a && (s = !1, !0); } }); };
  }, { 'pug-error': 42 }],
  129: [function (e, t, n) {
    function r(e, t, n, i) { function o(e) { return e.reduce((e, o) => { const s = r(o, t, n, i); return Array.isArray(s) ? e.concat(s) : e.concat([s]); }, []); }n && typeof n === 'object' && void 0 === i && (i = n, n = null); const s = (i = i || { includeDependencies: !1 }).parents = i.parents || []; const a = function t(n) { if (Array.isArray(n) && !t.arrayAllowed) throw new Error('replace() can only be called with an array if the last parent is a Block or NamedBlock'); e = n; }; if (a.arrayAllowed = s[0] && (/^(Named)?Block$/.test(s[0].type) || s[0].type === 'RawInclude' && e.type === 'IncludeFilter'), t) { if (!1 === t(e, a)) return e; if (Array.isArray(e)) return o(e); } switch (s.unshift(e), e.type) { case 'NamedBlock': case 'Block': e.nodes = o(e.nodes); break; case 'Case': case 'Filter': case 'Mixin': case 'Tag': case 'InterpolatedTag': case 'When': case 'Code': case 'While': e.block && (e.block = r(e.block, t, n, i)); break; case 'Each': e.block && (e.block = r(e.block, t, n, i)), e.alternate && (e.alternate = r(e.alternate, t, n, i)); break; case 'Conditional': e.consequent && (e.consequent = r(e.consequent, t, n, i)), e.alternate && (e.alternate = r(e.alternate, t, n, i)); break; case 'Include': r(e.block, t, n, i), r(e.file, t, n, i); break; case 'Extends': r(e.file, t, n, i); break; case 'RawInclude': e.filters = o(e.filters), r(e.file, t, n, i); break; case 'Attrs': case 'BlockComment': case 'Comment': case 'Doctype': case 'IncludeFilter': case 'MixinBlock': case 'YieldBlock': case 'Text': break; case 'FileReference': i.includeDependencies && e.ast && r(e.ast, t, n, i); break; default: throw new Error(`Unexpected node type ${e.type}`); } return s.shift(), n && n(e, a), e; }t.exports = r;
  }, {}],
  130: [function (e, t, n) {
    function r(e, t) { if (t = t || {}, typeof e !== 'string') throw new Error(`Expected source code to be a string but got "${typeof e}"`); if (typeof t !== 'object') throw new Error(`Expected "options" to be an object but got "${typeof t}"`); e = e.replace(/^\uFEFF/, ''), this.input = e.replace(/\r\n|\r/g, '\n'), this.originalInput = this.input, this.filename = t.filename, this.interpolated = t.interpolated || !1, this.lineno = t.startingLine || 1, this.colno = t.startingColumn || 1, this.plugins = t.plugins || [], this.indentStack = [0], this.indentRe = null, this.interpolationAllowed = !0, this.tokens = [], this.ended = !1; } const i = e('assert'); const o = e('is-expression'); const s = e('character-parser'); const a = e('pug-error'); t.exports = function (e, t) { const n = new r(e, t); return JSON.parse(JSON.stringify(n.getTokens())); }, t.exports.Lexer = r, r.prototype = {
      constructor: r,
      error(e, t) {
        throw a(e, t, {
          line: this.lineno, column: this.colno, filename: this.filename, src: this.originalInput,
        });
      },
      assert(e, t) { e || this.error('ASSERT_FAILED', t); },
      isExpression(e) { return o(e, { throw: !0 }); },
      assertExpression(e, t) { try { return this.callLexerFunction('isExpression', e), !0; } catch (e) { if (t) return !1; if (!e.loc) throw e; this.incrementLine(e.loc.line - 1), this.incrementColumn(e.loc.column); const n = `Syntax Error: ${e.message.replace(/ \([0-9]+:[0-9]+\)$/, '')}`; this.error('SYNTAX_ERROR', n); } },
      assertNestingCorrect(e) { s(e).isNesting() && this.error('INCORRECT_NESTING', `Nesting must match on expression \`${e}\``); },
      tok(e, t) { const n = { type: e, line: this.lineno, col: this.colno }; return void 0 !== t && (n.val = t), n; },
      incrementLine(e) { this.lineno += e, e && (this.colno = 1); },
      incrementColumn(e) { this.colno += e; },
      consume(e) { this.input = this.input.substr(e); },
      scan(e, t) { let n; if (n = e.exec(this.input)) { const r = n[0].length; const i = n[1]; const o = r - (i ? i.length : 0); const s = this.tok(t, i); return this.consume(r), this.incrementColumn(o), s; } },
      scanEndOfLine(e, t) { let n; if (n = e.exec(this.input)) { let r; let i; let o = 0; (r = /^([ ]+)([^ ]*)/.exec(n[0])) && (o = r[1].length, this.incrementColumn(o)); const s = this.input.substr(n[0].length); if (s[0] === ':') return this.input = s, i = this.tok(t, n[1]), this.incrementColumn(n[0].length - o), i; if (/^[ \t]*(\n|$)/.test(s)) return this.input = s.substr(/^[ \t]*/.exec(s)[0].length), i = this.tok(t, n[1]), this.incrementColumn(n[0].length - o), i; } },
      bracketExpression(e) { e = e || 0; const t = this.input[e]; i(t === '(' || t === '{' || t === '[', 'The start character should be "(", "{" or "["'); let n; const r = s.BRACKETS[t]; try { n = s.parseUntil(this.input, r, { start: e + 1 }); } catch (t) { if (void 0 !== t.index) { for (var o = t.index, a = this.input.substr(e).indexOf('\n'), u = a + e, c = 0; o > u && a !== -1;) this.incrementLine(1), o -= u + 1, c += u + 1, a = u = this.input.substr(c).indexOf('\n'); this.incrementColumn(o); } throw t.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED' ? this.error('NO_END_BRACKET', `The end of the string reached with no closing bracket ${r} found.`) : t.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET' && this.error('BRACKET_MISMATCH', t.message), t; } return n; },
      scanIndentation() { let e; let t; return this.indentRe ? e = this.indentRe.exec(this.input) : ((e = (t = /^\n(\t*) */).exec(this.input)) && !e[1].length && (e = (t = /^\n( *)/).exec(this.input)), e && e[1].length && (this.indentRe = t)), e; },
      eos() { if (!this.input.length) { this.interpolated && this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.'); for (let e = 0; this.indentStack[e]; e++) this.tokens.push(this.tok('outdent')); return this.tokens.push(this.tok('eos')), this.ended = !0, !0; } },
      blank() { let e; if (e = /^\n[ \t]*\n/.exec(this.input)) return this.consume(e[0].length - 1), this.incrementLine(1), !0; },
      comment() { let e; if (e = /^\/\/(-)?([^\n]*)/.exec(this.input)) { this.consume(e[0].length); const t = this.tok('comment', e[2]); return t.buffer = e[1] != '-', this.interpolationAllowed = t.buffer, this.tokens.push(t), this.incrementColumn(e[0].length), this.callLexerFunction('pipelessText'), !0; } },
      interpolation() { if (/^#\{/.test(this.input)) { const e = this.bracketExpression(1); this.consume(e.end + 1); const t = this.tok('interpolation', e.src); this.tokens.push(t), this.incrementColumn(2), this.assertExpression(e.src); const n = e.src.split('\n'); const r = n.length - 1; return this.incrementLine(r), this.incrementColumn(n[r].length + 1), !0; } },
      tag() { let e; if (e = /^(\w(?:[-:\w]*\w)?)/.exec(this.input)) { let t; const n = e[1]; const r = e[0].length; return this.consume(r), t = this.tok('tag', n), this.tokens.push(t), this.incrementColumn(r), !0; } },
      filter(e) { const t = this.scan(/^:([\w\-]+)/, 'filter'); const n = e && e.inInclude; if (t) return this.tokens.push(t), this.incrementColumn(t.val.length), this.callLexerFunction('attrs'), n || (this.interpolationAllowed = !1, this.callLexerFunction('pipelessText')), !0; },
      doctype() { const e = this.scanEndOfLine(/^doctype *([^\n]*)/, 'doctype'); if (e) return this.tokens.push(e), !0; },
      id() { const e = this.scan(/^#([\w-]+)/, 'id'); if (e) return this.tokens.push(e), this.incrementColumn(e.val.length), !0; /^#/.test(this.input) && this.error('INVALID_ID', `"${/.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0]}" is not a valid ID.`); },
      className() { const e = this.scan(/^\.(-?-?[_a-z][_a-z0-9\-]*)/i, 'class'); if (e) return this.tokens.push(e), this.incrementColumn(e.val.length), !0; /^\.\-/i.test(this.input) && this.error('INVALID_CLASS_NAME', 'If a class name begins with a "-" or "--", it must be followed by a letter or underscore.'), /^\.[0-9]/i.test(this.input) && this.error('INVALID_CLASS_NAME', 'Class names must begin with "-", "_" or a letter.'), /^\./.test(this.input) && this.error('INVALID_CLASS_NAME', `"${/.[^ \t\(\#\.\:]*/.exec(this.input.substr(1))[0]}" is not a valid class name.  Class names must begin with "-", "_" or a letter and can only contain "_", "-", a-z and 0-9.`); },
      endInterpolation() { if (this.interpolated && this.input[0] === ']') return this.input = this.input.substr(1), this.ended = !0, !0; },
      addText(e, t, n, r) {
        if (t + n !== '') {
          n = n || ''; let i = this.interpolated ? t.indexOf(']') : -1; let o = this.interpolationAllowed ? t.indexOf('#[') : -1; let a = this.interpolationAllowed ? t.indexOf('\\#[') : -1; const u = /(\\)?([#!]){((?:.|\n)*)$/.exec(t); const c = this.interpolationAllowed && u ? u.index : 1 / 0; if (i === -1 && (i = 1 / 0), o === -1 && (o = 1 / 0), a === -1 && (a = 1 / 0), a !== 1 / 0 && a < i && a < o && a < c) return n = `${n + t.substring(0, a)}#[`, this.addText(e, t.substring(a + 3), n, !0); if (o !== 1 / 0 && o < i && o < a && o < c) {
            this.tokens.push(this.tok(e, n + t.substring(0, o))), this.incrementColumn(n.length + o), r && this.incrementColumn(1), this.tokens.push(this.tok('start-pug-interpolation')), this.incrementColumn(2); let l; const p = new this.constructor(t.substr(o + 2), {
              filename: this.filename, interpolated: !0, startingLine: this.lineno, startingColumn: this.colno,
            }); try { l = p.getTokens(); } catch (e) { throw e.code && /^PUG:/.test(e.code) && (this.colno = e.column, this.error(e.code.substr(4), e.msg)), e; } return this.colno = p.colno, this.tokens = this.tokens.concat(l), this.tokens.push(this.tok('end-pug-interpolation')), this.incrementColumn(1), void this.addText(e, p.input);
          } if (i !== 1 / 0 && i < o && i < a && i < c) return n + t.substring(0, i) && this.addText(e, t.substring(0, i), n), this.ended = !0, void (this.input = t.substr(t.indexOf(']') + 1) + this.input); if (c !== 1 / 0) { if (u[1]) return n = `${n + t.substring(0, c)}#{`, this.addText(e, t.substring(c + 3), n); let h = t.substr(0, c); (n || h) && (h = n + h, this.tokens.push(this.tok(e, h)), this.incrementColumn(h.length)); let f; let d = u[3]; const m = this.tok('interpolated-code'); this.incrementColumn(2); try { f = s.parseUntil(d, '}'); } catch (e) { if (void 0 !== e.index && this.incrementColumn(e.index), e.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.'); else { if (e.code !== 'CHARACTER_PARSER:MISMATCHED_BRACKET') throw e; this.error('BRACKET_MISMATCH', e.message); } } return m.mustEscape = u[2] === '#', m.buffer = !0, m.val = f.src, this.assertExpression(f.src), this.tokens.push(m), void (f.end + 1 < d.length ? (d = d.substr(f.end + 1), this.incrementColumn(f.end + 1), this.addText(e, d)) : this.incrementColumn(d.length)); }t = n + t, this.tokens.push(this.tok(e, t)), this.incrementColumn(t.length);
        }
      },
      text() { const e = this.scan(/^(?:\| ?| )([^\n]+)/, 'text') || this.scan(/^( )/, 'text') || this.scan(/^\|( ?)/, 'text'); if (e) return this.addText('text', e.val), !0; },
      textHtml() { const e = this.scan(/^(<[^\n]*)/, 'text-html'); if (e) return this.addText('text-html', e.val), !0; },
      dot() { let e; if (e = this.scanEndOfLine(/^\./, 'dot')) return this.tokens.push(e), this.callLexerFunction('pipelessText'), !0; },
      extends() { const e = this.scan(/^extends?(?= |$|\n)/, 'extends'); if (e) return this.tokens.push(e), this.callLexerFunction('path') || this.error('NO_EXTENDS_PATH', 'missing path for extends'), !0; this.scan(/^extends?\b/) && this.error('MALFORMED_EXTENDS', 'malformed extends'); },
      prepend() { let e; if (e = /^(?:block +)?prepend +([^\n]+)/.exec(this.input)) { let t = e[1].trim(); let n = ''; if (t.indexOf('//') !== -1 && (n = `//${t.split('//').slice(1).join('//')}`, t = t.split('//')[0].trim()), !t) return; this.consume(e[0].length - n.length); const r = this.tok('block', t); return r.mode = 'prepend', this.tokens.push(r), !0; } },
      append() { let e; if (e = /^(?:block +)?append +([^\n]+)/.exec(this.input)) { let t = e[1].trim(); let n = ''; if (t.indexOf('//') !== -1 && (n = `//${t.split('//').slice(1).join('//')}`, t = t.split('//')[0].trim()), !t) return; this.consume(e[0].length - n.length); const r = this.tok('block', t); return r.mode = 'append', this.tokens.push(r), !0; } },
      block() { let e; if (e = /^block +([^\n]+)/.exec(this.input)) { let t = e[1].trim(); let n = ''; if (t.indexOf('//') !== -1 && (n = `//${t.split('//').slice(1).join('//')}`, t = t.split('//')[0].trim()), !t) return; this.consume(e[0].length - n.length); const r = this.tok('block', t); return r.mode = 'replace', this.tokens.push(r), !0; } },
      mixinBlock() { let e; if (e = this.scanEndOfLine(/^block/, 'mixin-block')) return this.tokens.push(e), !0; },
      yield() { const e = this.scanEndOfLine(/^yield/, 'yield'); if (e) return this.tokens.push(e), !0; },
      include() { const e = this.scan(/^include(?=:| |$|\n)/, 'include'); if (e) { for (this.tokens.push(e); this.callLexerFunction('filter', { inInclude: !0 }););return this.callLexerFunction('path') || (/^[^ \n]+/.test(this.input) ? this.fail() : this.error('NO_INCLUDE_PATH', 'missing path for include')), !0; } this.scan(/^include\b/) && this.error('MALFORMED_INCLUDE', 'malformed include'); },
      path() { const e = this.scanEndOfLine(/^ ([^\n]+)/, 'path'); if (e && (e.val = e.val.trim())) return this.tokens.push(e), !0; },
      case() { const e = this.scanEndOfLine(/^case +([^\n]+)/, 'case'); if (e) return this.incrementColumn(-e.val.length), this.assertExpression(e.val), this.incrementColumn(e.val.length), this.tokens.push(e), !0; this.scan(/^case\b/) && this.error('NO_CASE_EXPRESSION', 'missing expression for case'); },
      when() { const e = this.scanEndOfLine(/^when +([^:\n]+)/, 'when'); if (e) { for (let t = s(e.val); t.isNesting() || t.isString();) { const n = /:([^:\n]+)/.exec(this.input); if (!n) break; e.val += n[0], this.consume(n[0].length), this.incrementColumn(n[0].length), t = s(e.val); } return this.incrementColumn(-e.val.length), this.assertExpression(e.val), this.incrementColumn(e.val.length), this.tokens.push(e), !0; } this.scan(/^when\b/) && this.error('NO_WHEN_EXPRESSION', 'missing expression for when'); },
      default() { const e = this.scanEndOfLine(/^default/, 'default'); if (e) return this.tokens.push(e), !0; this.scan(/^default\b/) && this.error('DEFAULT_WITH_EXPRESSION', 'default should not have an expression'); },
      call() { let e; let t; let n; if (t = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) { if (t[3])n = t[0].length, this.consume(n), e = this.tok('call', t[3]); else { const r = this.bracketExpression(2 + t[1].length); n = r.end + 1, this.consume(n), this.assertExpression(r.src), e = this.tok('call', `#{${r.src}}`); } if (this.incrementColumn(n), e.args = null, t = /^ *\(/.exec(this.input)) { const i = this.bracketExpression(t[0].length - 1); if (!/^\s*[-\w]+ *=/.test(i.src)) { this.incrementColumn(1), this.consume(i.end + 1), e.args = i.src, this.assertExpression(`[${e.args}]`); for (let o = 0; o <= e.args.length; o++)e.args[o] === '\n' ? this.incrementLine(1) : this.incrementColumn(1); } } return this.tokens.push(e), !0; } },
      mixin() { let e; if (e = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) { this.consume(e[0].length); const t = this.tok('mixin', e[1]); return t.args = e[2] || null, this.tokens.push(t), !0; } },
      conditional() { let e; if (e = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) { this.consume(e[0].length); const t = e[1].replace(/ /g, '-'); const n = e[2] && e[2].trim(); const r = this.tok(t, n); switch (this.incrementColumn(e[0].length - n.length), t) { case 'if': case 'else-if': this.assertExpression(n); break; case 'unless': this.assertExpression(n), r.val = `!(${n})`, r.type = 'if'; break; case 'else': n && this.error('ELSE_CONDITION', '`else` cannot have a condition, perhaps you meant `else if`'); } return this.tokens.push(r), !0; } },
      while() { let e; if (e = /^while +([^\n]+)/.exec(this.input)) return this.consume(e[0].length), this.assertExpression(e[1]), this.tokens.push(this.tok('while', e[1])), !0; this.scan(/^while\b/) && this.error('NO_WHILE_EXPRESSION', 'missing expression for while'); },
      each() { let e; if (e = /^(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) { this.consume(e[0].length); const t = this.tok('each', e[1]); return t.key = e[2] || null, this.incrementColumn(e[0].length - e[3].length), this.assertExpression(e[3]), t.code = e[3], this.incrementColumn(e[3].length), this.tokens.push(t), !0; } this.scan(/^(?:each|for)\b/) && this.error('MALFORMED_EACH', 'malformed each'), (e = /^- *(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? +in +([^\n]+)/.exec(this.input)) && this.error('MALFORMED_EACH', 'Pug each and for should no longer be prefixed with a dash ("-"). They are pug keywords and not part of JavaScript.'); },
      code() { let e; if (e = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) { const t = e[1]; let n = e[2]; let r = 0; if (this.interpolated) { let i; try { i = s.parseUntil(n, ']'); } catch (t) { if (void 0 !== t.index && this.incrementColumn(e[0].length - n.length + t.index), t.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.'); else { if (t.code !== 'CHARACTER_PARSER:MISMATCHED_BRACKET') throw t; this.error('BRACKET_MISMATCH', t.message); } }r = n.length - i.end, n = i.src; } const o = e[0].length - r; this.consume(o); const a = this.tok('code', n); return a.mustEscape = t.charAt(0) === '=', a.buffer = t.charAt(0) === '=' || t.charAt(1) === '=', this.incrementColumn(e[0].length - e[2].length), a.buffer && this.assertExpression(n), this.tokens.push(a), this.incrementColumn(n.length), !0; } },
      blockCode() { let e; if (e = this.scanEndOfLine(/^-/, 'blockcode')) return this.tokens.push(e), this.interpolationAllowed = !1, this.callLexerFunction('pipelessText'), !0; },
      attrs() { if (this.input.charAt(0) == '(') { const e = this.lineno; this.tokens.push(this.tok('start-attributes')); const t = this.bracketExpression().end; const n = this.input.substr(1, t - 1); this.incrementColumn(1), this.assertNestingCorrect(n); let r = ''; const i = this; this.consume(t + 1); for (var o, a = /[ \n\t]/, u = /['"]/, c = !0, l = '', p = '', h = s.defaultState(), f = e, d = this.colno, m = 'key', g = function (e) { if (l.trim() === '') return d = this.colno, !1; if (e === n.length) return !0; if (m === 'key') { if (a.test(n[e])) for (t = e; t < n.length; t++) if (!a.test(n[t])) return n[t] !== '=' && n[t] !== '!' && n[t] !== ','; return n[e] === ','; } if (m === 'value') { if (h.isNesting() || h.isString()) return !1; if (a.test(n[e])) for (var t = e; t < n.length; t++) if (!a.test(n[t])) return (!s.isPunctuator(n[t]) || u.test(n[t]) || n[t] === ':') && i.assertExpression(p, !0); return n[e] === ',' && i.assertExpression(p, !0); } }, v = 0; v <= n.length; v++) { if (g.call(this, v)) { if (p.trim()) { const y = this.colno; this.colno = o, this.assertExpression(p), this.colno = y; }p = p.trim(), l = l.trim(), l = l.replace(/^['"]|['"]$/g, ''); const b = this.tok('attribute'); b.name = l, b.val = p == '' || p, b.col = d, b.mustEscape = c, this.tokens.push(b), l = p = '', m = 'key', c = !1, this.lineno = f; } else switch (m) { case 'key-char': n[v] === r ? (m = 'key', v + 1 < n.length && !/[ ,!=\n\t]/.test(n[v + 1]) && this.error('INVALID_KEY_CHARACTER', `Unexpected character "${n[v + 1]}" expected \` \`, \`\\n\`, \`\t\`, \`,\`, \`!\` or \`=\``)) : l += n[v]; break; case 'key': l === '' && u.test(n[v]) ? (m = 'key-char', r = n[v]) : n[v] === '!' || n[v] === '=' ? (c = n[v] !== '!', n[v] === '!' && (this.incrementColumn(1), v++), n[v] !== '=' && this.error('INVALID_KEY_CHARACTER', `Unexpected character ${n[v]} expected \`=\``), m = 'value', o = this.colno + 1, h = s.defaultState()) : l += n[v]; break; case 'value': h = s.parseChar(n[v], h), p += n[v]; }n[v] === '\n' ? (f++, this.colno = 1, l.trim() || (this.lineno = f)) : void 0 !== n[v] && this.incrementColumn(1); } return this.lineno = e + (n.match(/\n/g) || []).length, this.tokens.push(this.tok('end-attributes')), this.incrementColumn(1), !0; } },
      attributesBlock() { if (/^&attributes\b/.test(this.input)) { let e = 11; this.consume(e); const t = this.tok('&attributes'); this.incrementColumn(e); const n = this.bracketExpression(); return e = n.end + 1, this.consume(e), t.val = n.src, this.tokens.push(t), this.incrementColumn(e), !0; } },
      indent() { const e = this.scanIndentation(); if (e) { const t = e[1].length; if (this.incrementLine(1), this.consume(t + 1), this.input[0] != ' ' && this.input[0] != '\t' || this.error('INVALID_INDENTATION', 'Invalid indentation, you can use tabs or spaces but not both'), this.input[0] == '\n') return this.interpolationAllowed = !0, this.tok('newline'); if (t < this.indentStack[0]) for (;this.indentStack[0] > t;) this.indentStack[1] < t && this.error('INCONSISTENT_INDENTATION', `Inconsistent indentation. Expecting either ${this.indentStack[1]} or ${this.indentStack[0]} spaces/tabs.`), this.colno = this.indentStack[1] + 1, this.tokens.push(this.tok('outdent')), this.indentStack.shift(); else t && t != this.indentStack[0] ? (this.tokens.push(this.tok('indent', t)), this.colno = 1 + t, this.indentStack.unshift(t)) : (this.tokens.push(this.tok('newline')), this.colno = 1 + (this.indentStack[0] || 0)); return this.interpolationAllowed = !0, !0; } },
      pipelessText: function e(t) { for (;this.callLexerFunction('blank'););const n = this.scanIndentation(); if ((t = t || n && n[1].length) > this.indentStack[0]) { this.tokens.push(this.tok('start-pipeless-text')); let r; const i = []; let o = 0; do { let s = this.input.substr(o + 1).indexOf('\n'); s == -1 && (s = this.input.length - o - 1); const a = this.input.substr(o + 1, s); const u = this.indentRe.exec(`\n${a}`); const c = u && u[1].length; if (r = c >= t || !a.trim())o += a.length + 1, i.push(a.substr(t)); else if (c > this.indentStack[0]) return this.tokens.pop(), e.call(this, u[1].length); } while (this.input.length - o && r);for (this.consume(o); this.input.length === 0 && i[i.length - 1] === '';)i.pop(); return i.forEach((e, n) => { this.incrementLine(1), n !== 0 && this.tokens.push(this.tok('newline')), this.incrementColumn(t), this.addText('text', e); }), this.tokens.push(this.tok('end-pipeless-text')), !0; } },
      slash() { const e = this.scan(/^\//, 'slash'); if (e) return this.tokens.push(e), !0; },
      colon() { const e = this.scan(/^: +/, ':'); if (e) return this.tokens.push(e), !0; },
      fail() { this.error('UNEXPECTED_TEXT', `unexpected text "${this.input.substr(0, 5)}"`); },
      callLexerFunction(e) { for (var t = [], n = 1; n < arguments.length; n++)t.push(arguments[n]); for (var r = [this].concat(t), n = 0; n < this.plugins.length; n++) { const i = this.plugins[n]; if (i[e] && i[e](...r)) return !0; } return this[e].apply(this, t); },
      advance() { return this.callLexerFunction('blank') || this.callLexerFunction('eos') || this.callLexerFunction('endInterpolation') || this.callLexerFunction('yield') || this.callLexerFunction('doctype') || this.callLexerFunction('interpolation') || this.callLexerFunction('case') || this.callLexerFunction('when') || this.callLexerFunction('default') || this.callLexerFunction('extends') || this.callLexerFunction('append') || this.callLexerFunction('prepend') || this.callLexerFunction('block') || this.callLexerFunction('mixinBlock') || this.callLexerFunction('include') || this.callLexerFunction('mixin') || this.callLexerFunction('call') || this.callLexerFunction('conditional') || this.callLexerFunction('each') || this.callLexerFunction('while') || this.callLexerFunction('tag') || this.callLexerFunction('filter') || this.callLexerFunction('blockCode') || this.callLexerFunction('code') || this.callLexerFunction('id') || this.callLexerFunction('dot') || this.callLexerFunction('className') || this.callLexerFunction('attrs') || this.callLexerFunction('attributesBlock') || this.callLexerFunction('indent') || this.callLexerFunction('text') || this.callLexerFunction('textHtml') || this.callLexerFunction('comment') || this.callLexerFunction('slash') || this.callLexerFunction('colon') || this.fail(); },
      getTokens() { for (;!this.ended;) this.callLexerFunction('advance'); return this.tokens; },
    };
  }, {
    assert: 7, 'character-parser': 12, 'is-expression': 23, 'pug-error': 42,
  }],
  131: [function (e, t, n) {
    (function (e) {
      !(function (r) {
        function i(e) { throw new RangeError(B[e]); } function o(e, t) { for (var n = e.length, r = []; n--;)r[n] = t(e[n]); return r; } function s(e, t) { const n = e.split('@'); let r = ''; return n.length > 1 && (r = `${n[0]}@`, e = n[1]), r + o((e = e.replace(F, '.')).split('.'), t).join('.'); } function a(e) { for (var t, n, r = [], i = 0, o = e.length; i < o;)(t = e.charCodeAt(i++)) >= 55296 && t <= 56319 && i < o ? (64512 & (n = e.charCodeAt(i++))) == 56320 ? r.push(((1023 & t) << 10) + (1023 & n) + 65536) : (r.push(t), i--) : r.push(t); return r; } function u(e) { return o(e, (e) => { let t = ''; return e > 65535 && (t += N((e -= 65536) >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), t += N(e); }).join(''); } function c(e) { return e - 48 < 10 ? e - 22 : e - 65 < 26 ? e - 65 : e - 97 < 26 ? e - 97 : _; } function l(e, t) { return e + 22 + 75 * (e < 26) - ((t != 0) << 5); } function p(e, t, n) { let r = 0; for (e = n ? L(e / E) : e >> 1, e += L(e / t); e > D * w >> 1; r += _)e = L(e / D); return L(r + (D + 1) * e / (e + k)); } function h(e) { let t; let n; let r; let o; let s; let a; let l; let h; let f; let d; const m = []; const g = e.length; let v = 0; let y = C; let k = A; for ((n = e.lastIndexOf(S)) < 0 && (n = 0), r = 0; r < n; ++r)e.charCodeAt(r) >= 128 && i('not-basic'), m.push(e.charCodeAt(r)); for (o = n > 0 ? n + 1 : 0; o < g;) { for (s = v, a = 1, l = _; o >= g && i('invalid-input'), ((h = c(e.charCodeAt(o++))) >= _ || h > L((b - v) / a)) && i('overflow'), v += h * a, f = l <= k ? x : l >= k + w ? w : l - k, !(h < f); l += _)a > L(b / (d = _ - f)) && i('overflow'), a *= d; k = p(v - s, t = m.length + 1, s == 0), L(v / t) > b - y && i('overflow'), y += L(v / t), v %= t, m.splice(v++, 0, y); } return u(m); } function f(e) { let t; let n; let r; let o; let s; let u; let c; let h; let f; let d; let m; let g; let v; let y; let k; const E = []; for (g = (e = a(e)).length, t = C, n = 0, s = A, u = 0; u < g; ++u)(m = e[u]) < 128 && E.push(N(m)); for (r = o = E.length, o && E.push(S); r < g;) { for (c = b, u = 0; u < g; ++u)(m = e[u]) >= t && m < c && (c = m); for (c - t > L((b - n) / (v = r + 1)) && i('overflow'), n += (c - t) * v, t = c, u = 0; u < g; ++u) if ((m = e[u]) < t && ++n > b && i('overflow'), m == t) { for (h = n, f = _; d = f <= s ? x : f >= s + w ? w : f - s, !(h < d); f += _)k = h - d, y = _ - d, E.push(N(l(d + k % y, 0))), h = L(k / y); E.push(N(l(h, 0))), s = p(n, v, r == o), n = 0, ++r; }++n, ++t; } return E.join(''); } const d = typeof n === 'object' && n && !n.nodeType && n; const m = typeof t === 'object' && t && !t.nodeType && t; const g = typeof e === 'object' && e; g.global !== g && g.window !== g && g.self !== g || (r = g); let v; let y; var b = 2147483647; var _ = 36; var x = 1; var w = 26; var k = 38; var E = 700; var A = 72; var C = 128; var S = '-'; const T = /^xn--/; const O = /[^\x20-\x7E]/; var F = /[\x2E\u3002\uFF0E\uFF61]/g; var B = { overflow: 'Overflow: input needs wider integers to process', 'not-basic': 'Illegal input >= 0x80 (not a basic code point)', 'invalid-input': 'Invalid input' }; var D = _ - x; var L = Math.floor; var N = String.fromCharCode; if (v = {
          version: '1.4.1', ucs2: { decode: a, encode: u }, decode: h, encode: f, toASCII(e) { return s(e, e => (O.test(e) ? `xn--${f(e)}` : e)); }, toUnicode(e) { return s(e, e => (T.test(e) ? h(e.slice(4).toLowerCase()) : e)); },
        }, typeof define === 'function' && typeof define.amd === 'object' && define.amd)define('punycode', () => v); else if (d && m) if (t.exports == d)m.exports = v; else for (y in v)v.hasOwnProperty(y) && (d[y] = v[y]); else r.punycode = v;
      }(this));
    }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
  }, {}],
  132: [function (e, t, n) {
    function r(e, t) { return Object.prototype.hasOwnProperty.call(e, t); }t.exports = function (e, t, n, o) { t = t || '&', n = n || '='; const s = {}; if (typeof e !== 'string' || e.length === 0) return s; const a = /\+/g; e = e.split(t); let u = 1e3; o && typeof o.maxKeys === 'number' && (u = o.maxKeys); let c = e.length; u > 0 && c > u && (c = u); for (let l = 0; l < c; ++l) { var p; var h; var f; var d; const m = e[l].replace(a, '%20'); const g = m.indexOf(n); g >= 0 ? (p = m.substr(0, g), h = m.substr(g + 1)) : (p = m, h = ''), f = decodeURIComponent(p), d = decodeURIComponent(h), r(s, f) ? i(s[f]) ? s[f].push(d) : s[f] = [s[f], d] : s[f] = d; } return s; }; var i = Array.isArray || function (e) { return Object.prototype.toString.call(e) === '[object Array]'; };
  }, {}],
  133: [function (e, t, n) {
    function r(e, t) { if (e.map) return e.map(t); for (var n = [], r = 0; r < e.length; r++)n.push(t(e[r], r)); return n; } const i = function (e) { switch (typeof e) { case 'string': return e; case 'boolean': return e ? 'true' : 'false'; case 'number': return isFinite(e) ? e : ''; default: return ''; } }; t.exports = function (e, t, n, a) { return t = t || '&', n = n || '=', e === null && (e = void 0), typeof e === 'object' ? r(s(e), (s) => { const a = encodeURIComponent(i(s)) + n; return o(e[s]) ? r(e[s], e => a + encodeURIComponent(i(e))).join(t) : a + encodeURIComponent(i(e[s])); }).join(t) : a ? encodeURIComponent(i(a)) + n + encodeURIComponent(i(e)) : ''; }; var o = Array.isArray || function (e) { return Object.prototype.toString.call(e) === '[object Array]'; }; var s = Object.keys || function (e) { const t = []; for (const n in e)Object.prototype.hasOwnProperty.call(e, n) && t.push(n); return t; };
  }, {}],
  134: [function (e, t, n) {
    n.decode = n.parse = e('./decode'), n.encode = n.stringify = e('./encode');
  }, { './decode': 132, './encode': 133 }],
  135: [function (e, t, n) { function r() { this._array = [], this._set = s ? new Map() : Object.create(null); } const i = e('./util'); const o = Object.prototype.hasOwnProperty; var s = typeof Map !== 'undefined'; r.fromArray = function (e, t) { for (var n = new r(), i = 0, o = e.length; i < o; i++)n.add(e[i], t); return n; }, r.prototype.size = function () { return s ? this._set.size : Object.getOwnPropertyNames(this._set).length; }, r.prototype.add = function (e, t) { const n = s ? e : i.toSetString(e); const r = s ? this.has(e) : o.call(this._set, n); const a = this._array.length; r && !t || this._array.push(e), r || (s ? this._set.set(e, a) : this._set[n] = a); }, r.prototype.has = function (e) { if (s) return this._set.has(e); const t = i.toSetString(e); return o.call(this._set, t); }, r.prototype.indexOf = function (e) { if (s) { const t = this._set.get(e); if (t >= 0) return t; } else { const n = i.toSetString(e); if (o.call(this._set, n)) return this._set[n]; } throw new Error(`"${e}" is not in the set.`); }, r.prototype.at = function (e) { if (e >= 0 && e < this._array.length) return this._array[e]; throw new Error(`No element indexed by ${e}`); }, r.prototype.toArray = function () { return this._array.slice(); }, n.ArraySet = r; }, { './util': 144 }],
  136: [function (e, t, n) { function r(e) { return e < 0 ? 1 + (-e << 1) : 0 + (e << 1); } function i(e) { const t = e >> 1; return (1 & e) == 1 ? -t : t; } const o = e('./base64'); n.encode = function (e) { let t; let n = ''; let i = r(e); do { t = 31 & i, (i >>>= 5) > 0 && (t |= 32), n += o.encode(t); } while (i > 0);return n; }, n.decode = function (e, t, n) { let r; let s; const a = e.length; let u = 0; let c = 0; do { if (t >= a) throw new Error('Expected more digits in base 64 VLQ value.'); if ((s = o.decode(e.charCodeAt(t++))) === -1) throw new Error(`Invalid base64 digit: ${e.charAt(t - 1)}`); r = !!(32 & s), u += (s &= 31) << c, c += 5; } while (r);n.value = i(u), n.rest = t; }; }, { './base64': 137 }],
  137: [function (e, t, n) { const r = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(''); n.encode = function (e) { if (e >= 0 && e < r.length) return r[e]; throw new TypeError(`Must be between 0 and 63: ${e}`); }, n.decode = function (e) { return e >= 65 && e <= 90 ? e - 65 : e >= 97 && e <= 122 ? e - 97 + 26 : e >= 48 && e <= 57 ? e - 48 + 52 : e == 43 ? 62 : e == 47 ? 63 : -1; }; }, {}],
  138: [function (e, t, n) { function r(e, t, i, o, s, a) { const u = Math.floor((t - e) / 2) + e; const c = s(i, o[u], !0); return c === 0 ? u : c > 0 ? t - u > 1 ? r(u, t, i, o, s, a) : a == n.LEAST_UPPER_BOUND ? t < o.length ? t : -1 : u : u - e > 1 ? r(e, u, i, o, s, a) : a == n.LEAST_UPPER_BOUND ? u : e < 0 ? -1 : e; }n.GREATEST_LOWER_BOUND = 1, n.LEAST_UPPER_BOUND = 2, n.search = function (e, t, i, o) { if (t.length === 0) return -1; let s = r(-1, t.length, e, t, i, o || n.GREATEST_LOWER_BOUND); if (s < 0) return -1; for (;s - 1 >= 0 && i(t[s], t[s - 1], !0) === 0;)--s; return s; }; }, {}],
  139: [function (e, t, n) { function r(e, t) { const n = e.generatedLine; const r = t.generatedLine; const i = e.generatedColumn; const s = t.generatedColumn; return r > n || r == n && s >= i || o.compareByGeneratedPositionsInflated(e, t) <= 0; } function i() { this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 }; } var o = e('./util'); i.prototype.unsortedForEach = function (e, t) { this._array.forEach(e, t); }, i.prototype.add = function (e) { r(this._last, e) ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e)); }, i.prototype.toArray = function () { return this._sorted || (this._array.sort(o.compareByGeneratedPositionsInflated), this._sorted = !0), this._array; }, n.MappingList = i; }, { './util': 144 }],
  140: [function (e, t, n) { function r(e, t, n) { const r = e[t]; e[t] = e[n], e[n] = r; } function i(e, t) { return Math.round(e + Math.random() * (t - e)); } function o(e, t, n, s) { if (n < s) { let a = n - 1; r(e, i(n, s), s); for (var u = e[s], c = n; c < s; c++)t(e[c], u) <= 0 && r(e, a += 1, c); r(e, a + 1, c); const l = a + 1; o(e, t, n, l - 1), o(e, t, l + 1, s); } }n.quickSort = function (e, t) { o(e, t, 0, e.length - 1); }; }, {}],
  141: [function (e, t, n) {
    function r(e) { let t = e; return typeof e === 'string' && (t = JSON.parse(e.replace(/^\)\]\}'/, ''))), t.sections != null ? new s(t) : new i(t); } function i(e) { let t = e; typeof e === 'string' && (t = JSON.parse(e.replace(/^\)\]\}'/, ''))); const n = a.getArg(t, 'version'); let r = a.getArg(t, 'sources'); const i = a.getArg(t, 'names', []); const o = a.getArg(t, 'sourceRoot', null); const s = a.getArg(t, 'sourcesContent', null); const u = a.getArg(t, 'mappings'); const l = a.getArg(t, 'file', null); if (n != this._version) throw new Error(`Unsupported version: ${n}`); r = r.map(String).map(a.normalize).map(e => (o && a.isAbsolute(o) && a.isAbsolute(e) ? a.relative(o, e) : e)), this._names = c.fromArray(i.map(String), !0), this._sources = c.fromArray(r, !0), this.sourceRoot = o, this.sourcesContent = s, this._mappings = u, this.file = l; } function o() { this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null; } function s(e) { let t = e; typeof e === 'string' && (t = JSON.parse(e.replace(/^\)\]\}'/, ''))); const n = a.getArg(t, 'version'); const i = a.getArg(t, 'sections'); if (n != this._version) throw new Error(`Unsupported version: ${n}`); this._sources = new c(), this._names = new c(); let o = { line: -1, column: 0 }; this._sections = i.map((e) => { if (e.url) throw new Error('Support for url field in sections not implemented.'); const t = a.getArg(e, 'offset'); const n = a.getArg(t, 'line'); const i = a.getArg(t, 'column'); if (n < o.line || n === o.line && i < o.column) throw new Error('Section offsets must be ordered and non-overlapping.'); return o = t, { generatedOffset: { generatedLine: n + 1, generatedColumn: i + 1 }, consumer: new r(a.getArg(e, 'map')) }; }); } var a = e('./util'); const u = e('./binary-search'); var c = e('./array-set').ArraySet; const l = e('./base64-vlq'); const p = e('./quick-sort').quickSort; r.fromSourceMap = function (e) { return i.fromSourceMap(e); }, r.prototype._version = 3, r.prototype.__generatedMappings = null, Object.defineProperty(r.prototype, '_generatedMappings', { get() { return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings; } }), r.prototype.__originalMappings = null, Object.defineProperty(r.prototype, '_originalMappings', { get() { return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings; } }), r.prototype._charIsMappingSeparator = function (e, t) { const n = e.charAt(t); return n === ';' || n === ','; }, r.prototype._parseMappings = function (e, t) { throw new Error('Subclasses must implement _parseMappings'); }, r.GENERATED_ORDER = 1, r.ORIGINAL_ORDER = 2, r.GREATEST_LOWER_BOUND = 1, r.LEAST_UPPER_BOUND = 2, r.prototype.eachMapping = function (e, t, n) {
      let i; const o = t || null; switch (n || r.GENERATED_ORDER) { case r.GENERATED_ORDER: i = this._generatedMappings; break; case r.ORIGINAL_ORDER: i = this._originalMappings; break; default: throw new Error('Unknown order of iteration.'); } const s = this.sourceRoot; i.map(function (e) {
        let t = e.source === null ? null : this._sources.at(e.source); return t != null && s != null && (t = a.join(s, t)), {
          source: t, generatedLine: e.generatedLine, generatedColumn: e.generatedColumn, originalLine: e.originalLine, originalColumn: e.originalColumn, name: e.name === null ? null : this._names.at(e.name),
        };
      }, this).forEach(e, o);
    }, r.prototype.allGeneratedPositionsFor = function (e) { const t = a.getArg(e, 'line'); const n = { source: a.getArg(e, 'source'), originalLine: t, originalColumn: a.getArg(e, 'column', 0) }; if (this.sourceRoot != null && (n.source = a.relative(this.sourceRoot, n.source)), !this._sources.has(n.source)) return []; n.source = this._sources.indexOf(n.source); const r = []; let i = this._findMapping(n, this._originalMappings, 'originalLine', 'originalColumn', a.compareByOriginalPositions, u.LEAST_UPPER_BOUND); if (i >= 0) { let o = this._originalMappings[i]; if (void 0 === e.column) for (let s = o.originalLine; o && o.originalLine === s;)r.push({ line: a.getArg(o, 'generatedLine', null), column: a.getArg(o, 'generatedColumn', null), lastColumn: a.getArg(o, 'lastGeneratedColumn', null) }), o = this._originalMappings[++i]; else for (let c = o.originalColumn; o && o.originalLine === t && o.originalColumn == c;)r.push({ line: a.getArg(o, 'generatedLine', null), column: a.getArg(o, 'generatedColumn', null), lastColumn: a.getArg(o, 'lastGeneratedColumn', null) }), o = this._originalMappings[++i]; } return r; }, n.SourceMapConsumer = r, (i.prototype = Object.create(r.prototype)).consumer = r, i.fromSourceMap = function (e) { const t = Object.create(i.prototype); const n = t._names = c.fromArray(e._names.toArray(), !0); const r = t._sources = c.fromArray(e._sources.toArray(), !0); t.sourceRoot = e._sourceRoot, t.sourcesContent = e._generateSourcesContent(t._sources.toArray(), t.sourceRoot), t.file = e._file; for (let s = e._mappings.toArray().slice(), u = t.__generatedMappings = [], l = t.__originalMappings = [], h = 0, f = s.length; h < f; h++) { const d = s[h]; const m = new o(); m.generatedLine = d.generatedLine, m.generatedColumn = d.generatedColumn, d.source && (m.source = r.indexOf(d.source), m.originalLine = d.originalLine, m.originalColumn = d.originalColumn, d.name && (m.name = n.indexOf(d.name)), l.push(m)), u.push(m); } return p(t.__originalMappings, a.compareByOriginalPositions), t; }, i.prototype._version = 3, Object.defineProperty(i.prototype, 'sources', { get() { return this._sources.toArray().map(function (e) { return this.sourceRoot != null ? a.join(this.sourceRoot, e) : e; }, this); } }), i.prototype._parseMappings = function (e, t) { for (var n, r, i, s, u, c = 1, h = 0, f = 0, d = 0, m = 0, g = 0, v = e.length, y = 0, b = {}, _ = {}, x = [], w = []; y < v;) if (e.charAt(y) === ';')c++, y++, h = 0; else if (e.charAt(y) === ',')y++; else { for ((n = new o()).generatedLine = c, s = y; s < v && !this._charIsMappingSeparator(e, s); s++);if (r = e.slice(y, s), i = b[r])y += r.length; else { for (i = []; y < s;)l.decode(e, y, _), u = _.value, y = _.rest, i.push(u); if (i.length === 2) throw new Error('Found a source, but no line and column'); if (i.length === 3) throw new Error('Found a source and line, but no column'); b[r] = i; }n.generatedColumn = h + i[0], h = n.generatedColumn, i.length > 1 && (n.source = m + i[1], m += i[1], n.originalLine = f + i[2], f = n.originalLine, n.originalLine += 1, n.originalColumn = d + i[3], d = n.originalColumn, i.length > 4 && (n.name = g + i[4], g += i[4])), w.push(n), typeof n.originalLine === 'number' && x.push(n); }p(w, a.compareByGeneratedPositionsDeflated), this.__generatedMappings = w, p(x, a.compareByOriginalPositions), this.__originalMappings = x; }, i.prototype._findMapping = function (e, t, n, r, i, o) { if (e[n] <= 0) throw new TypeError(`Line must be greater than or equal to 1, got ${e[n]}`); if (e[r] < 0) throw new TypeError(`Column must be greater than or equal to 0, got ${e[r]}`); return u.search(e, t, i, o); }, i.prototype.computeColumnSpans = function () { for (let e = 0; e < this._generatedMappings.length; ++e) { const t = this._generatedMappings[e]; if (e + 1 < this._generatedMappings.length) { const n = this._generatedMappings[e + 1]; if (t.generatedLine === n.generatedLine) { t.lastGeneratedColumn = n.generatedColumn - 1; continue; } }t.lastGeneratedColumn = 1 / 0; } }, i.prototype.originalPositionFor = function (e) {
      const t = { generatedLine: a.getArg(e, 'line'), generatedColumn: a.getArg(e, 'column') }; const n = this._findMapping(t, this._generatedMappings, 'generatedLine', 'generatedColumn', a.compareByGeneratedPositionsDeflated, a.getArg(e, 'bias', r.GREATEST_LOWER_BOUND)); if (n >= 0) {
        const i = this._generatedMappings[n]; if (i.generatedLine === t.generatedLine) {
          let o = a.getArg(i, 'source', null); o !== null && (o = this._sources.at(o), this.sourceRoot != null && (o = a.join(this.sourceRoot, o))); let s = a.getArg(i, 'name', null); return s !== null && (s = this._names.at(s)), {
            source: o, line: a.getArg(i, 'originalLine', null), column: a.getArg(i, 'originalColumn', null), name: s,
          };
        }
      } return {
        source: null, line: null, column: null, name: null,
      };
    }, i.prototype.hasContentsOfAllSources = function () { return !!this.sourcesContent && (this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(e => e == null)); }, i.prototype.sourceContentFor = function (e, t) { if (!this.sourcesContent) return null; if (this.sourceRoot != null && (e = a.relative(this.sourceRoot, e)), this._sources.has(e)) return this.sourcesContent[this._sources.indexOf(e)]; let n; if (this.sourceRoot != null && (n = a.urlParse(this.sourceRoot))) { const r = e.replace(/^file:\/\//, ''); if (n.scheme == 'file' && this._sources.has(r)) return this.sourcesContent[this._sources.indexOf(r)]; if ((!n.path || n.path == '/') && this._sources.has(`/${e}`)) return this.sourcesContent[this._sources.indexOf(`/${e}`)]; } if (t) return null; throw new Error(`"${e}" is not in the SourceMap.`); }, i.prototype.generatedPositionFor = function (e) { let t = a.getArg(e, 'source'); if (this.sourceRoot != null && (t = a.relative(this.sourceRoot, t)), !this._sources.has(t)) return { line: null, column: null, lastColumn: null }; const n = { source: t = this._sources.indexOf(t), originalLine: a.getArg(e, 'line'), originalColumn: a.getArg(e, 'column') }; const i = this._findMapping(n, this._originalMappings, 'originalLine', 'originalColumn', a.compareByOriginalPositions, a.getArg(e, 'bias', r.GREATEST_LOWER_BOUND)); if (i >= 0) { const o = this._originalMappings[i]; if (o.source === n.source) return { line: a.getArg(o, 'generatedLine', null), column: a.getArg(o, 'generatedColumn', null), lastColumn: a.getArg(o, 'lastGeneratedColumn', null) }; } return { line: null, column: null, lastColumn: null }; }, n.BasicSourceMapConsumer = i, (s.prototype = Object.create(r.prototype)).constructor = r, s.prototype._version = 3, Object.defineProperty(s.prototype, 'sources', { get() { for (var e = [], t = 0; t < this._sections.length; t++) for (let n = 0; n < this._sections[t].consumer.sources.length; n++)e.push(this._sections[t].consumer.sources[n]); return e; } }), s.prototype.originalPositionFor = function (e) {
      const t = { generatedLine: a.getArg(e, 'line'), generatedColumn: a.getArg(e, 'column') }; const n = u.search(t, this._sections, (e, t) => { const n = e.generatedLine - t.generatedOffset.generatedLine; return n || e.generatedColumn - t.generatedOffset.generatedColumn; }); const r = this._sections[n]; return r ? r.consumer.originalPositionFor({ line: t.generatedLine - (r.generatedOffset.generatedLine - 1), column: t.generatedColumn - (r.generatedOffset.generatedLine === t.generatedLine ? r.generatedOffset.generatedColumn - 1 : 0), bias: e.bias }) : {
        source: null, line: null, column: null, name: null,
      };
    }, s.prototype.hasContentsOfAllSources = function () { return this._sections.every(e => e.consumer.hasContentsOfAllSources()); }, s.prototype.sourceContentFor = function (e, t) { for (let n = 0; n < this._sections.length; n++) { const r = this._sections[n].consumer.sourceContentFor(e, !0); if (r) return r; } if (t) return null; throw new Error(`"${e}" is not in the SourceMap.`); }, s.prototype.generatedPositionFor = function (e) { for (let t = 0; t < this._sections.length; t++) { const n = this._sections[t]; if (n.consumer.sources.indexOf(a.getArg(e, 'source')) !== -1) { const r = n.consumer.generatedPositionFor(e); if (r) return { line: r.line + (n.generatedOffset.generatedLine - 1), column: r.column + (n.generatedOffset.generatedLine === r.line ? n.generatedOffset.generatedColumn - 1 : 0) }; } } return { line: null, column: null }; }, s.prototype._parseMappings = function (e, t) {
      this.__generatedMappings = [], this.__originalMappings = []; for (let n = 0; n < this._sections.length; n++) {
        for (let r = this._sections[n], i = r.consumer._generatedMappings, o = 0; o < i.length; o++) {
          const s = i[o]; let u = r.consumer._sources.at(s.source); r.consumer.sourceRoot !== null && (u = a.join(r.consumer.sourceRoot, u)), this._sources.add(u), u = this._sources.indexOf(u); let c = r.consumer._names.at(s.name); this._names.add(c), c = this._names.indexOf(c); const l = {
            source: u, generatedLine: s.generatedLine + (r.generatedOffset.generatedLine - 1), generatedColumn: s.generatedColumn + (r.generatedOffset.generatedLine === s.generatedLine ? r.generatedOffset.generatedColumn - 1 : 0), originalLine: s.originalLine, originalColumn: s.originalColumn, name: c,
          }; this.__generatedMappings.push(l), typeof l.originalLine === 'number' && this.__originalMappings.push(l);
        }
      }p(this.__generatedMappings, a.compareByGeneratedPositionsDeflated), p(this.__originalMappings, a.compareByOriginalPositions);
    }, n.IndexedSourceMapConsumer = s;
  }, {
    './array-set': 135, './base64-vlq': 136, './binary-search': 138, './quick-sort': 140, './util': 144,
  }],
  142: [function (e, t, n) {
    function r(e) { e || (e = {}), this._file = o.getArg(e, 'file', null), this._sourceRoot = o.getArg(e, 'sourceRoot', null), this._skipValidation = o.getArg(e, 'skipValidation', !1), this._sources = new s(), this._names = new s(), this._mappings = new a(), this._sourcesContents = null; } const i = e('./base64-vlq'); var o = e('./util'); var s = e('./array-set').ArraySet; var a = e('./mapping-list').MappingList; r.prototype._version = 3, r.fromSourceMap = function (e) { const t = e.sourceRoot; const n = new r({ file: e.file, sourceRoot: t }); return e.eachMapping((e) => { const r = { generated: { line: e.generatedLine, column: e.generatedColumn } }; e.source != null && (r.source = e.source, t != null && (r.source = o.relative(t, r.source)), r.original = { line: e.originalLine, column: e.originalColumn }, e.name != null && (r.name = e.name)), n.addMapping(r); }), e.sources.forEach((t) => { const r = e.sourceContentFor(t); r != null && n.setSourceContent(t, r); }), n; }, r.prototype.addMapping = function (e) {
      const t = o.getArg(e, 'generated'); const n = o.getArg(e, 'original', null); let r = o.getArg(e, 'source', null); let i = o.getArg(e, 'name', null); this._skipValidation || this._validateMapping(t, n, r, i), r != null && (r = String(r), this._sources.has(r) || this._sources.add(r)), i != null && (i = String(i), this._names.has(i) || this._names.add(i)), this._mappings.add({
        generatedLine: t.line, generatedColumn: t.column, originalLine: n != null && n.line, originalColumn: n != null && n.column, source: r, name: i,
      });
    }, r.prototype.setSourceContent = function (e, t) { let n = e; this._sourceRoot != null && (n = o.relative(this._sourceRoot, n)), t != null ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[o.toSetString(n)] = t) : this._sourcesContents && (delete this._sourcesContents[o.toSetString(n)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null)); }, r.prototype.applySourceMap = function (e, t, n) {
      let r = t; if (t == null) { if (e.file == null) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.'); r = e.file; } const i = this._sourceRoot; i != null && (r = o.relative(i, r)); const a = new s();


      const u = new s(); this._mappings.unsortedForEach((t) => { if (t.source === r && t.originalLine != null) { const s = e.originalPositionFor({ line: t.originalLine, column: t.originalColumn }); s.source != null && (t.source = s.source, n != null && (t.source = o.join(n, t.source)), i != null && (t.source = o.relative(i, t.source)), t.originalLine = s.line, t.originalColumn = s.column, s.name != null && (t.name = s.name)); } const c = t.source; c == null || a.has(c) || a.add(c); const l = t.name; l == null || u.has(l) || u.add(l); }, this), this._sources = a, this._names = u, e.sources.forEach(function (t) { const r = e.sourceContentFor(t); r != null && (n != null && (t = o.join(n, t)), i != null && (t = o.relative(i, t)), this.setSourceContent(t, r)); }, this);
    }, r.prototype._validateMapping = function (e, t, n, r) {
      if (t && typeof t.line !== 'number' && typeof t.column !== 'number') throw new Error('original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.'); if ((!(e && 'line' in e && 'column' in e && e.line > 0 && e.column >= 0) || t || n || r) && !(e && 'line' in e && 'column' in e && t && 'line' in t && 'column' in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && n)) {
        throw new Error(`Invalid mapping: ${JSON.stringify({
          generated: e, source: n, original: t, name: r,
        })}`);
      }
    }, r.prototype._serializeMappings = function () { for (var e, t, n, r, s = 0, a = 1, u = 0, c = 0, l = 0, p = 0, h = '', f = this._mappings.toArray(), d = 0, m = f.length; d < m; d++) { if (t = f[d], e = '', t.generatedLine !== a) for (s = 0; t.generatedLine !== a;)e += ';', a++; else if (d > 0) { if (!o.compareByGeneratedPositionsInflated(t, f[d - 1])) continue; e += ','; }e += i.encode(t.generatedColumn - s), s = t.generatedColumn, t.source != null && (r = this._sources.indexOf(t.source), e += i.encode(r - p), p = r, e += i.encode(t.originalLine - 1 - c), c = t.originalLine - 1, e += i.encode(t.originalColumn - u), u = t.originalColumn, t.name != null && (n = this._names.indexOf(t.name), e += i.encode(n - l), l = n)), h += e; } return h; }, r.prototype._generateSourcesContent = function (e, t) { return e.map(function (e) { if (!this._sourcesContents) return null; t != null && (e = o.relative(t, e)); const n = o.toSetString(e); return Object.prototype.hasOwnProperty.call(this._sourcesContents, n) ? this._sourcesContents[n] : null; }, this); }, r.prototype.toJSON = function () {
      const e = {
        version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings(),
      }; return this._file != null && (e.file = this._file), this._sourceRoot != null && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e;
    }, r.prototype.toString = function () { return JSON.stringify(this.toJSON()); }, n.SourceMapGenerator = r;
  }, {
    './array-set': 135, './base64-vlq': 136, './mapping-list': 139, './util': 144,
  }],
  143: [function (e, t, n) {
    function r(e, t, n, r, i) { this.children = [], this.sourceContents = {}, this.line = e == null ? null : e, this.column = t == null ? null : t, this.source = n == null ? null : n, this.name = i == null ? null : i, this[a] = !0, r != null && this.add(r); } const i = e('./source-map-generator').SourceMapGenerator; const o = e('./util'); const s = /(\r?\n)/; var a = '$$$isSourceNode$$$'; r.fromStringWithSourceMap = function (e, t, n) {
      function i(e, t) { if (e === null || void 0 === e.source)a.add(t); else { const i = n ? o.join(n, e.source) : e.source; a.add(new r(e.originalLine, e.originalColumn, i, t, e.name)); } } var a = new r(); const u = e.split(s); let c = 0;


      const l = function () { function e() { return c < u.length ? u[c++] : void 0; } return e() + (e() || ''); };


      let p = 1; let h = 0;


      let f = null; return t.eachMapping((e) => { if (f !== null) { if (!(p < e.generatedLine)) { const t = (n = u[c]).substr(0, e.generatedColumn - h); return u[c] = n.substr(e.generatedColumn - h), h = e.generatedColumn, i(f, t), void (f = e); }i(f, l()), p++, h = 0; } for (;p < e.generatedLine;)a.add(l()), p++; if (h < e.generatedColumn) { var n = u[c]; a.add(n.substr(0, e.generatedColumn)), u[c] = n.substr(e.generatedColumn), h = e.generatedColumn; }f = e; }, this), c < u.length && (f && i(f, l()), a.add(u.splice(c).join(''))), t.sources.forEach((e) => { const r = t.sourceContentFor(e); r != null && (n != null && (e = o.join(n, e)), a.setSourceContent(e, r)); }), a;
    }, r.prototype.add = function (e) { if (Array.isArray(e))e.forEach(function (e) { this.add(e); }, this); else { if (!e[a] && typeof e !== 'string') throw new TypeError(`Expected a SourceNode, string, or an array of SourceNodes and strings. Got ${e}`); e && this.children.push(e); } return this; }, r.prototype.prepend = function (e) { if (Array.isArray(e)) for (let t = e.length - 1; t >= 0; t--) this.prepend(e[t]); else { if (!e[a] && typeof e !== 'string') throw new TypeError(`Expected a SourceNode, string, or an array of SourceNodes and strings. Got ${e}`); this.children.unshift(e); } return this; }, r.prototype.walk = function (e) {
      for (var t, n = 0, r = this.children.length; n < r; n++) {
        (t = this.children[n])[a] ? t.walk(e) : t !== '' && e(t, {
          source: this.source, line: this.line, column: this.column, name: this.name,
        });
      }
    }, r.prototype.join = function (e) { let t; let n; const r = this.children.length; if (r > 0) { for (t = [], n = 0; n < r - 1; n++)t.push(this.children[n]), t.push(e); t.push(this.children[n]), this.children = t; } return this; }, r.prototype.replaceRight = function (e, t) { const n = this.children[this.children.length - 1]; return n[a] ? n.replaceRight(e, t) : typeof n === 'string' ? this.children[this.children.length - 1] = n.replace(e, t) : this.children.push(''.replace(e, t)), this; }, r.prototype.setSourceContent = function (e, t) { this.sourceContents[o.toSetString(e)] = t; }, r.prototype.walkSourceContents = function (e) { for (var t = 0, n = this.children.length; t < n; t++) this.children[t][a] && this.children[t].walkSourceContents(e); for (var r = Object.keys(this.sourceContents), t = 0, n = r.length; t < n; t++)e(o.fromSetString(r[t]), this.sourceContents[r[t]]); }, r.prototype.toString = function () { let e = ''; return this.walk((t) => { e += t; }), e; }, r.prototype.toStringWithSourceMap = function (e) {
      const t = { code: '', line: 1, column: 0 }; const n = new i(e); let r = !1; let o = null; let s = null; let a = null; let u = null; return this.walk((e, i) => {
        t.code += e, i.source !== null && i.line !== null && i.column !== null ? (o === i.source && s === i.line && a === i.column && u === i.name || n.addMapping({
          source: i.source, original: { line: i.line, column: i.column }, generated: { line: t.line, column: t.column }, name: i.name,
        }), o = i.source, s = i.line, a = i.column, u = i.name, r = !0) : r && (n.addMapping({ generated: { line: t.line, column: t.column } }), o = null, r = !1); for (let c = 0, l = e.length; c < l; c++) {
          e.charCodeAt(c) === 10 ? (t.line++, t.column = 0, c + 1 === l ? (o = null, r = !1) : r && n.addMapping({
            source: i.source, original: { line: i.line, column: i.column }, generated: { line: t.line, column: t.column }, name: i.name,
          })) : t.column++;
        }
      }), this.walkSourceContents((e, t) => { n.setSourceContent(e, t); }), { code: t.code, map: n };
    }, n.SourceNode = r;
  }, { './source-map-generator': 142, './util': 144 }],
  144: [function (e, t, n) {
    function r(e) {
      const t = e.match(c); return t ? {
        scheme: t[1], auth: t[2], host: t[3], port: t[4], path: t[5],
      } : null;
    } function i(e) { let t = ''; return e.scheme && (t += `${e.scheme}:`), t += '//', e.auth && (t += `${e.auth}@`), e.host && (t += e.host), e.port && (t += `:${e.port}`), e.path && (t += e.path), t; } function o(e) { let t = e; const o = r(e); if (o) { if (!o.path) return e; t = o.path; } for (var s, a = n.isAbsolute(t), u = t.split(/\/+/), c = 0, l = u.length - 1; l >= 0; l--)(s = u[l]) === '.' ? u.splice(l, 1) : s === '..' ? c++ : c > 0 && (s === '' ? (u.splice(l + 1, c), c = 0) : (u.splice(l, 2), c--)); return (t = u.join('/')) === '' && (t = a ? '/' : '.'), o ? (o.path = t, i(o)) : t; } function s(e) { return e; } function a(e) { if (!e) return !1; const t = e.length; if (t < 9) return !1; if (e.charCodeAt(t - 1) !== 95 || e.charCodeAt(t - 2) !== 95 || e.charCodeAt(t - 3) !== 111 || e.charCodeAt(t - 4) !== 116 || e.charCodeAt(t - 5) !== 111 || e.charCodeAt(t - 6) !== 114 || e.charCodeAt(t - 7) !== 112 || e.charCodeAt(t - 8) !== 95 || e.charCodeAt(t - 9) !== 95) return !1; for (let n = t - 10; n >= 0; n--) if (e.charCodeAt(n) !== 36) return !1; return !0; } function u(e, t) { return e === t ? 0 : e > t ? 1 : -1; }n.getArg = function (e, t, n) { if (t in e) return e[t]; if (arguments.length === 3) return n; throw new Error(`"${t}" is a required argument.`); }; var c = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/; const l = /^data:.+\,.+$/; n.urlParse = r, n.urlGenerate = i, n.normalize = o, n.join = function (e, t) { e === '' && (e = '.'), t === '' && (t = '.'); const n = r(t); const s = r(e); if (s && (e = s.path || '/'), n && !n.scheme) return s && (n.scheme = s.scheme), i(n); if (n || t.match(l)) return t; if (s && !s.host && !s.path) return s.host = t, i(s); const a = t.charAt(0) === '/' ? t : o(`${e.replace(/\/+$/, '')}/${t}`); return s ? (s.path = a, i(s)) : a; }, n.isAbsolute = function (e) { return e.charAt(0) === '/' || !!e.match(c); }, n.relative = function (e, t) { e === '' && (e = '.'), e = e.replace(/\/$/, ''); for (var n = 0; t.indexOf(`${e}/`) !== 0;) { const r = e.lastIndexOf('/'); if (r < 0) return t; if ((e = e.slice(0, r)).match(/^([^\/]+:\/)?\/*$/)) return t; ++n; } return Array(n + 1).join('../') + t.substr(e.length + 1); }; const p = !('__proto__' in Object.create(null)); n.toSetString = p ? s : function (e) { return a(e) ? `$${e}` : e; }, n.fromSetString = p ? s : function (e) { return a(e) ? e.slice(1) : e; }, n.compareByOriginalPositions = function (e, t, n) { let r = e.source - t.source; return r !== 0 ? r : (r = e.originalLine - t.originalLine) != 0 ? r : (r = e.originalColumn - t.originalColumn) != 0 || n ? r : (r = e.generatedColumn - t.generatedColumn) != 0 ? r : (r = e.generatedLine - t.generatedLine) != 0 ? r : e.name - t.name; }, n.compareByGeneratedPositionsDeflated = function (e, t, n) { let r = e.generatedLine - t.generatedLine; return r !== 0 ? r : (r = e.generatedColumn - t.generatedColumn) != 0 || n ? r : (r = e.source - t.source) != 0 ? r : (r = e.originalLine - t.originalLine) != 0 ? r : (r = e.originalColumn - t.originalColumn) != 0 ? r : e.name - t.name; }, n.compareByGeneratedPositionsInflated = function (e, t) { let n = e.generatedLine - t.generatedLine; return n !== 0 ? n : (n = e.generatedColumn - t.generatedColumn) != 0 ? n : (n = u(e.source, t.source)) !== 0 ? n : (n = e.originalLine - t.originalLine) != 0 ? n : (n = e.originalColumn - t.originalColumn) != 0 ? n : u(e.name, t.name); };
  }, {}],
  145: [function (e, t, n) { n.SourceMapGenerator = e('./lib/source-map-generator').SourceMapGenerator, n.SourceMapConsumer = e('./lib/source-map-consumer').SourceMapConsumer, n.SourceNode = e('./lib/source-node').SourceNode; }, { './lib/source-map-consumer': 141, './lib/source-map-generator': 142, './lib/source-node': 143 }],
  146: [function (e, t, n) {
    function r(e) { if (!Array.isArray(e)) throw new TypeError('tokens must be passed to TokenStream as an array.'); this._tokens = e; }t.exports = r, r.prototype.lookahead = function (e) { if (this._tokens.length <= e) throw new Error('Cannot read past the end of a stream'); return this._tokens[e]; }, r.prototype.peek = function () { if (this._tokens.length === 0) throw new Error('Cannot read past the end of a stream'); return this._tokens[0]; }, r.prototype.advance = function () { if (this._tokens.length === 0) throw new Error('Cannot read past the end of a stream'); return this._tokens.shift(); }, r.prototype.defer = function (e) { this._tokens.unshift(e); };
  }, {}],
  147: [function (e, t, n) {
    (function (t) {
      function r(e) { for (var t = Object.create(null), n = 0; n < e.length; ++n)t[e[n]] = !0; return t; } function i(e) { return e.split(''); } function o(e, t) { return t.indexOf(e) >= 0; } function s(e, t) { for (let n = 0, r = t.length; n < r; ++n) if (e(t[n])) return t[n]; } function a(e, t) { if (t <= 0) return ''; if (t == 1) return e; let n = a(e, t >> 1); return n += n, 1 & t && (n += e), n; } function u(e) { Object.defineProperty(e.prototype, 'stack', { get() { const e = new Error(this.message); e.name = this.name; try { throw e; } catch (e) { return e.stack; } } }); } function c(e, t) { this.message = e, this.defs = t; } function l(e, t, n) { !0 === e && (e = {}); const r = e || {}; if (n) for (var i in r)E(r, i) && !E(t, i) && c.croak(`\`${i}\` is not a supported option`, t); for (var i in t)E(t, i) && (r[i] = e && E(e, i) ? e[i] : t[i]); return r; } function p(e, t) { let n = 0; for (const r in t)E(t, r) && (e[r] = t[r], n++); return n; } function h() {} function f() { return !1; } function d() { return !0; } function m() { return this; } function g() { return null; } function v(e, t) { e.indexOf(t) < 0 && e.push(t); } function y(e, t) { return e.replace(/\{(.+?)\}/g, (e, n) => t && t[n]); } function b(e, t) { for (let n = e.length; --n >= 0;)e[n] === t && e.splice(n, 1); } function _(e, t) { function n(e, n) { for (var r = [], i = 0, o = 0, s = 0; i < e.length && o < n.length;)t(e[i], n[o]) <= 0 ? r[s++] = e[i++] : r[s++] = n[o++]; return i < e.length && r.push(...e.slice(i)), o < n.length && r.push(...n.slice(o)), r; } function r(e) { if (e.length <= 1) return e; const t = Math.floor(e.length / 2); let i = e.slice(0, t); let o = e.slice(t); return i = r(i), o = r(o), n(i, o); } return e.length < 2 ? e.slice() : r(e); } function x(e) { function t(e) { return JSON.stringify(e).replace(/[\u2028\u2029]/g, (e) => { switch (e) { case '\u2028': return '\\u2028'; case '\u2029': return '\\u2029'; } return e; }); } function n(e) { if (e.length == 1) return r += `return str === ${t(e[0])};`; r += 'switch(str){'; for (let n = 0; n < e.length; ++n)r += `case ${t(e[n])}:`; r += 'return true}return false;'; }e instanceof Array || (e = e.split(' ')); var r = ''; const i = []; e:for (s = 0; s < e.length; ++s) { for (let o = 0; o < i.length; ++o) if (i[o][0].length == e[s].length) { i[o].push(e[s]); continue e; }i.push([e[s]]); } if (i.length > 3) { i.sort((e, t) => t.length - e.length), r += 'switch(str.length){'; for (var s = 0; s < i.length; ++s) { const a = i[s]; r += `case ${a[0].length}:`, n(a); }r += '}'; } else n(e); return new Function('str', r); } function w(e, t) { for (let n = e.length; --n >= 0;) if (!t(e[n])) return !1; return !0; } function k() { this._values = Object.create(null), this._size = 0; } function E(e, t) { return Object.prototype.hasOwnProperty.call(e, t); } function A(e) { for (var t, n = e.parent(-1), r = 0; t = e.parent(r); r++) { if (t instanceof oe && t.body === n) return !0; if (!(t instanceof Ye && t.car === n || t instanceof We && t.expression === n && !(t instanceof Ge) || t instanceof Ke && t.expression === n || t instanceof Je && t.expression === n || t instanceof nt && t.condition === n || t instanceof tt && t.left === n || t instanceof et && t.expression === n)) return !1; n = t; } } function C(e, t, r, i) { arguments.length < 4 && (i = ie); const o = t = t ? t.split(/\s+/) : []; i && i.PROPS && (t = t.concat(i.PROPS)); for (var s = `return function AST_${e}(props){ if (props) { `, a = t.length; --a >= 0;)s += `this.${t[a]} = props.${t[a]};`; const u = i && new i(); (u && u.initialize || r && r.initialize) && (s += 'this.initialize();'), s += '}}'; const c = new Function(s)(); if (u && (c.prototype = u, c.BASE = i), i && i.SUBCLASSES.push(c), c.prototype.CTOR = c, c.PROPS = t || null, c.SELF_PROPS = o, c.SUBCLASSES = [], e && (c.prototype.TYPE = c.TYPE = e), r) for (a in r)E(r, a) && (/^\$/.test(a) ? c[a.substr(1)] = r[a] : c.prototype[a] = r[a]); return c.DEFMETHOD = function (e, t) { this.prototype[e] = t; }, void 0 !== n && (n[`AST_${e}`] = c), c; } function S(e, t) { const n = e.body; if (n instanceof oe)n._walk(t); else for (let r = 0, i = n.length; r < i; r++)n[r]._walk(t); } function T(e) { this.visit = e, this.stack = [], this.directives = Object.create(null); } function O(e) { return e >= 97 && e <= 122 || e >= 65 && e <= 90 || e >= 170 && Xt.letter.test(String.fromCharCode(e)); } function F(e) { return e >= 48 && e <= 57; } function B(e) { return F(e) || O(e); } function D(e) { return Xt.digit.test(String.fromCharCode(e)); } function L(e) { return Xt.non_spacing_mark.test(e) || Xt.space_combining_mark.test(e); } function N(e) { return Xt.connector_punctuation.test(e); } function M(e) { return !It(e) && /^[a-z_$][a-z0-9_$]*$/i.test(e); } function R(e) { return e == 36 || e == 95 || O(e); } function P(e) { const t = e.charCodeAt(0); return R(t) || F(t) || t == 8204 || t == 8205 || L(e) || N(e) || D(t); } function I(e) { return /^[a-z_$][a-z0-9_$]*$/i.test(e); } function j(e) { if (zt.test(e)) return parseInt(e.substr(2), 16); if (Ut.test(e)) return parseInt(e.substr(1), 8); const t = parseFloat(e); return t == e ? t : void 0; } function V(e, t, n, r, i) { this.message = e, this.filename = t, this.line = n, this.col = r, this.pos = i; } function z(e, t, n, r, i) { throw new V(e, t, n, r, i); } function U(e, t, n) { return e.type == t && (n == null || e.value == n); } function $(e, t, n, r) {
        function i() { return S.text.charAt(S.pos); } function o(e, t) { let n = S.text.charAt(S.pos++); if (e && !n) throw Kt; return Ht(n) ? (S.newline_before = S.newline_before || !t, ++S.line, S.col = 0, t || n != '\r' || i() != '\n' || (++S.pos, n = '\n')) : ++S.col, n; } function s(e) { for (;e-- > 0;)o(); } function a(e) { return S.text.substr(S.pos, e.length) == e; } function u() { for (let e = S.text, t = S.pos, n = S.text.length; t < n; ++t) { const r = e[t]; if (Ht(r)) return t; } return -1; } function c(e, t) { const n = S.text.indexOf(e, S.pos); if (t && n == -1) throw Kt; return n; } function l() { S.tokline = S.line, S.tokcol = S.col, S.tokpos = S.pos; } function p(n, r, i) {
          S.regex_allowed = n == 'operator' && !Qt(r) || n == 'keyword' && jt(r) || n == 'punc' && Wt(r), n == 'punc' && r == '.' ? T = !0 : i || (T = !1); const o = {
            type: n, value: r, line: S.tokline, col: S.tokcol, pos: S.tokpos, endline: S.line, endcol: S.col, endpos: S.pos, nlb: S.newline_before, file: t,
          }; if (/^(?:num|string|regexp)$/i.test(n) && (o.raw = e.substring(o.pos, o.endpos)), !i) { o.comments_before = S.comments_before, S.comments_before = []; for (let s = 0, a = o.comments_before.length; s < a; s++)o.nlb = o.nlb || o.comments_before[s].nlb; } return S.newline_before = !1, new re(o);
        } function h() { for (;qt(i());)o(); } function f(e) { for (var t, n = '', r = 0; (t = i()) && e(t, r++);)n += o(); return n; } function d(e) { z(e, t, S.tokline, S.tokcol, S.tokpos); } function m(e) { let t = !1; let n = !1; let r = !1; let i = e == '.'; let o = f((o, s) => { const a = o.charCodeAt(0); switch (a) { case 120: case 88: return !r && (r = !0); case 101: case 69: return !!r || !t && (t = n = !0); case 45: return n || s == 0 && !e; case 43: return n; case n = !1, 46: return !(i || r || t) && (i = !0); } return B(a); }); e && (o = e + o), Ut.test(o) && C.has_directive('use strict') && d('Legacy octal literals are not allowed in strict mode'); const s = j(o); if (!isNaN(s)) return p('num', s); d(`Invalid syntax: ${o}`); } function g(e) { const t = o(!0, e); switch (t.charCodeAt(0)) { case 110: return '\n'; case 114: return '\r'; case 116: return '\t'; case 98: return '\b'; case 118: return '\v'; case 102: return '\f'; case 120: return String.fromCharCode(y(2)); case 117: return String.fromCharCode(y(4)); case 10: return ''; case 13: if (i() == '\n') return o(!0, e), ''; } return t >= '0' && t <= '7' ? v(t) : t; } function v(e) { let t = i(); return t >= '0' && t <= '7' && (e += o(!0))[0] <= '3' && (t = i()) >= '0' && t <= '7' && (e += o(!0)), e === '0' ? '\0' : (e.length > 0 && C.has_directive('use strict') && d('Legacy octal escape sequences are not allowed in strict mode'), String.fromCharCode(parseInt(e, 8))); } function y(e) { for (var t = 0; e > 0; --e) { const n = parseInt(o(!0), 16); isNaN(n) && d('Invalid hex-character pattern in string'), t = t << 4 | n; } return t; } function b(e) { let t; const n = S.regex_allowed; const r = u(); return r == -1 ? (t = S.text.substr(S.pos), S.pos = S.text.length) : (t = S.text.substring(S.pos, r), S.pos = r), S.col = S.tokcol + (S.pos - S.tokpos), S.comments_before.push(p(e, t, !0)), S.regex_allowed = n, C; } function _() { for (var e, t, n = !1, r = '', s = !1; (e = i()) != null;) if (n)e != 'u' && d('Expecting UnicodeEscapeSequence -- uXXXX'), P(e = g()) || d(`Unicode char: ${e.charCodeAt(0)} is not valid in identifier`), r += e, n = !1; else if (e == '\\')s = n = !0, o(); else { if (!P(e)) break; r += o(); } return Rt(r) && s && (t = r.charCodeAt(0).toString(16).toUpperCase(), r = `\\u${'0000'.substr(t.length)}${t}${r.slice(1)}`), r; } function x(e) { function t(e) { if (!i()) return e; const n = e + i(); return $t(n) ? (o(), t(n)) : e; } return p('operator', t(e || o())); } function w() { switch (o(), i()) { case '/': return o(), b('comment1'); case '*': return o(), D(); } return S.regex_allowed ? L('') : x('/'); } function k() { return o(), F(i().charCodeAt(0)) ? m('.') : p('punc', '.'); } function E() { const e = _(); return T ? p('name', e) : Pt(e) ? p('atom', e) : Rt(e) ? $t(e) ? p('operator', e) : p('keyword', e) : p('name', e); } function A(e, t) { return function (n) { try { return t(n); } catch (t) { if (t !== Kt) throw t; d(e); } }; } function C(e) { if (e != null) return L(e); for (r && S.pos == 0 && a('#!') && (l(), s(2), b('comment5')); ;) { if (h(), l(), n) { if (a('\x3c!--')) { s(4), b('comment3'); continue; } if (a('--\x3e') && S.newline_before) { s(3), b('comment4'); continue; } } var t = i(); if (!t) return p('eof'); const u = t.charCodeAt(0); switch (u) { case 34: case 39: return O(t); case 46: return k(); case 47: var c = w(); if (c === C) continue; return c; } if (F(u)) return m(); if (Gt(t)) return p('punc', o()); if (Vt(t)) return x(); if (u == 92 || R(u)) return E(); break; }d(`Unexpected character '${t}'`); } var S = {
          text: e, filename: t, pos: 0, tokpos: 0, line: 1, tokline: 0, col: 0, tokcol: 0, newline_before: !1, regex_allowed: !1, comments_before: [], directives: {}, directive_stack: [],
        }; var T = !1; var O = A('Unterminated string constant', (e) => { for (var t = o(), n = ''; ;) { let r = o(!0, !0); if (r == '\\')r = g(!0); else if (Ht(r))d('Unterminated string constant'); else if (r == t) break; n += r; } const i = p('string', n); return i.quote = e, i; }); var D = A('Unterminated multiline comment', () => { const e = S.regex_allowed; const t = c('*/', !0); const n = S.text.substring(S.pos, t).replace(/\r\n|\r|\u2028|\u2029/g, '\n'); return s(n.length + 2), S.comments_before.push(p('comment2', n, !0)), S.regex_allowed = e, C; }); var L = A('Unterminated regular expression', (e) => { for (var t, n = !1, r = !1; t = o(!0);) if (Ht(t))d('Unexpected line terminator'); else if (n)e += `\\${t}`, n = !1; else if (t == '[')r = !0, e += t; else if (t == ']' && r)r = !1, e += t; else { if (t == '/' && !r) break; t == '\\' ? n = !0 : e += t; } const i = _(); try { return p('regexp', new RegExp(e, i)); } catch (e) { d(e.message); } }); return C.context = function (e) { return e && (S = e), S; }, C.add_directive = function (e) { S.directive_stack[S.directive_stack.length - 1].push(e), void 0 === S.directives[e] ? S.directives[e] = 1 : S.directives[e]++; }, C.push_directives_stack = function () { S.directive_stack.push([]); }, C.pop_directives_stack = function () { for (let e = S.directive_stack[S.directive_stack.length - 1], t = 0; t < e.length; t++)S.directives[e[t]]--; S.directive_stack.pop(); }, C.has_directive = function (e) { return void 0 !== S.directives[e] && S.directives[e] > 0; }, C;
      } function q(e, t) {
        function n(e, t) { return U(V.token, e, t); } function r() { return V.peeked || (V.peeked = V.input()); } function i() { return V.prev = V.token, V.peeked ? (V.token = V.peeked, V.peeked = null) : V.token = V.input(), V.in_directives = V.in_directives && (V.token.type == 'string' || n('punc', ';')), V.token; } function o() { return V.prev; } function a(e, t, n, r) { const i = V.input.context(); z(e, i.filename, t != null ? t : i.tokline, n != null ? n : i.tokcol, r != null ? r : i.tokpos); } function u(e, t) { a(t, e.line, e.col); } function c(e) { e == null && (e = V.token), u(e, `Unexpected token: ${e.type} (${e.value})`); } function p(e, t) { if (n(e, t)) return i(); u(V.token, `Unexpected token ${V.token.type} Â«${V.token.value}Â», expected ${e} Â«${t}Â»`); } function h(e) { return p('punc', e); } function f() { return !t.strict && (V.token.nlb || n('eof') || n('punc', '}')); } function d(e) { n('punc', ';') ? i() : e || f() || c(); } function m() { h('('); const e = ie(!0); return h(')'), e; } function g(e) { return function () { const t = V.token; const n = e(); const r = o(); return n.start = t, n.end = r, n; }; } function v() { (n('operator', '/') || n('operator', '/=')) && (V.peeked = null, V.token = V.input(V.token.value.substr(1))); } function y() { const e = N(bt); s(t => t.name == e.name, V.labels) && a(`Label ${e.name} defined twice`), h(':'), V.labels.push(e); const t = q(); return V.labels.pop(), t instanceof de || e.references.forEach((t) => { t instanceof Le && (t = t.label.start, a(`Continue label \`${e.name}\` refers to non-IterationStatement.`, t.line, t.col, t.pos)); }), new fe({ body: t, label: e }); } function b(e) { return new ue({ body: (e = ie(!0), d(), e) }); } function _(e) { let t; let n = null; f() || (n = N(xt, !0)), n != null ? ((t = s(e => e.name == n.name, V.labels)) || a(`Undefined label ${n.name}`), n.thedef = t) : V.in_loop == 0 && a(`${e.TYPE} not inside a loop or switch`), d(); const r = new e({ label: n }); return t && t.references.push(r), r; } function x() { h('('); let e = null; return !n('punc', ';') && (e = n('keyword', 'var') ? (i(), W(!0)) : ie(!0, !0), n('operator', 'in')) ? (e instanceof $e && e.definitions.length > 1 && a('Only one variable declaration allowed in for..in loop'), i(), k(e)) : w(e); } function w(e) {
          h(';'); const t = n('punc', ';') ? null : ie(!0); h(';'); const r = n('punc', ')') ? null : ie(!0); return h(')'), new ye({
            init: e, condition: t, step: r, body: j(q),
          });
        } function k(e) {
          const t = e instanceof $e ? e.definitions[0].name : null; const n = ie(!0); return h(')'), new be({
            init: e, name: t, object: n, body: j(q),
          });
        } function E() { const e = m(); const t = q(); let r = null; return n('keyword', 'else') && (i(), r = q()), new Ne({ condition: e, body: t, alternative: r }); } function A() { h('{'); for (var e = []; !n('punc', '}');)n('eof') && c(), e.push(q()); return i(), e; } function C() { h('{'); for (var e, t = [], r = null, s = null; !n('punc', '}');)n('eof') && c(), n('keyword', 'case') ? (s && (s.end = o()), r = [], s = new Ie({ start: (e = V.token, i(), e), expression: ie(!0), body: r }), t.push(s), h(':')) : n('keyword', 'default') ? (s && (s.end = o()), r = [], s = new Pe({ start: (e = V.token, i(), h(':'), e), body: r }), t.push(s)) : (r || c(), r.push(q())); return s && (s.end = o()), i(), t; } function S() {
          const e = A(); let t = null; let r = null; if (n('keyword', 'catch')) {
            u = V.token; i(), h('('); const s = N(yt); h(')'), t = new Ve({
              start: u, argname: s, body: A(), end: o(),
            });
          } if (n('keyword', 'finally')) { var u = V.token; i(), r = new ze({ start: u, body: A(), end: o() }); } return t || r || a('Missing catch/finally blocks'), new je({ body: e, bcatch: t, bfinally: r });
        } function T(e, t) {
          for (var r = []; r.push(new He({
            start: V.token, name: N(t ? dt : ft), value: n('operator', '=') ? (i(), ie(!1, e)) : null, end: o(),
          })), n('punc', ',');)i(); return r;
        } function O() {
          let e; const t = V.token; switch (t.type) {
            case 'name': case 'keyword': e = L(_t); break; case 'num': e = new At({ start: t, end: t, value: t.value }); break; case 'string': e = new Et({
              start: t, end: t, value: t.value, quote: t.quote,
            }); break; case 'regexp': e = new Ct({ start: t, end: t, value: t.value }); break; case 'atom': switch (t.value) { case 'false': e = new Nt({ start: t, end: t }); break; case 'true': e = new Mt({ start: t, end: t }); break; case 'null': e = new Tt({ start: t, end: t }); } break; case 'operator': I(t.value) || a(`Invalid getter/setter name: ${t.value}`, t.line, t.col, t.pos), e = L(_t);
          } return i(), e;
        } function F(e, t, r) { for (var o = !0, s = []; !n('punc', e) && (o ? o = !1 : h(','), !t || !n('punc', e));)n('punc', ',') && r ? s.push(new Bt({ start: V.token, end: V.token })) : s.push(ie(!1)); return i(), s; } function B() { const e = V.token; switch (e.type) { case 'operator': Rt(e.value) || c(); case 'num': case 'string': case 'name': case 'keyword': case 'atom': return i(), e.value; default: c(); } } function D() { const e = V.token; return e.type != 'name' && c(), i(), e.value; } function L(e) { const t = V.token.value; return new (t == 'this' ? wt : e)({ name: String(t), start: V.token, end: V.token }); } function N(e, t) { if (!n('name')) return t || a('Name expected'), null; const r = L(e); return i(), r; } function M(e, t, n) { const r = t.value; return r != '++' && r != '--' || P(n) || a(`Invalid use of ${r} operator`, t.line, t.col, t.pos), new e({ operator: r, expression: n }); } function R(e) { return te(ee(!0), 0, e); } function P(e) { return !!t.cli || (e instanceof Xe || e instanceof _t); } function j(e) { ++V.in_loop; const t = e(); return --V.in_loop, t; }t = l(t, {
          bare_returns: !1, cli: !1, expression: !1, filename: null, html5_comments: !0, shebang: !0, strict: !1, toplevel: null,
        }); var V = {
          input: typeof e === 'string' ? $(e, t.filename, t.html5_comments, t.shebang) : e, token: null, prev: null, peeked: null, in_function: 0, in_directives: !0, in_loop: 0, labels: [],
        }; V.token = i(); var q = g(() => { switch (v(), V.token.type) { case 'string': if (V.in_directives) { const e = r(); V.token.raw.indexOf('\\') == -1 && (e.nlb || U(e, 'eof') || U(e, 'punc', ';') || U(e, 'punc', '}')) ? V.input.add_directive(V.token.value) : V.in_directives = !1; } var s = V.in_directives; var u = b(); return s ? new ae(u.body) : u; case 'num': case 'regexp': case 'operator': case 'atom': return b(); case 'name': return U(r(), 'punc', ':') ? y() : b(); case 'punc': switch (V.token.value) { case '{': return new le({ start: V.token, body: A(), end: o() }); case '[': case '(': return b(); case ';': return V.in_directives = !1, i(), new pe(); default: c(); } case 'keyword': switch (V.token.value) { case 'break': return i(), _(De); case 'continue': return i(), _(Le); case 'debugger': return i(), d(), new se(); case 'do': i(); var l = j(q); p('keyword', 'while'); var h = m(); return d(!0), new ge({ body: l, condition: h }); case 'while': return i(), new ve({ condition: m(), body: j(q) }); case 'for': return i(), x(); case 'function': return i(), H(Ce); case 'if': return i(), E(); case 'return': V.in_function != 0 || t.bare_returns || a("'return' outside of function"), i(); g = null; return n('punc', ';') ? i() : f() || (g = ie(!0), d()), new Oe({ value: g }); case 'switch': return i(), new Me({ expression: m(), body: j(C) }); case 'throw': i(), V.token.nlb && a("Illegal newline after 'throw'"); var g = ie(!0); return d(), new Fe({ value: g }); case 'try': return i(), S(); case 'var': i(); w = W(); return d(), w; case 'const': i(); var w = G(); return d(), w; case 'with': return V.input.has_directive('use strict') && a('Strict mode may not include a with statement'), i(), new _e({ expression: m(), body: q() }); } }c(); }); var H = function (e) { const t = e === Ce; const r = n('name') ? N(t ? gt : vt) : null; return t && !r && c(), h('('), new e({ name: r, argnames: (function (e, t) { for (;!n('punc', ')');)e ? e = !1 : h(','), t.push(N(mt)); return i(), t; }(!0, [])), body: (function (e, t) { ++V.in_function, V.in_directives = !0, V.input.push_directives_stack(), V.in_loop = 0, V.labels = []; const n = A(); return V.input.pop_directives_stack(), --V.in_function, V.in_loop = e, V.labels = t, n; }(V.in_loop, V.labels)) }); }; var W = function (e) { return new $e({ start: o(), definitions: T(e, !1), end: o() }); }; var G = function () { return new qe({ start: o(), definitions: T(!1, !0), end: o() }); }; const Y = function (e) {
          const t = V.token; p('operator', 'new'); let r; const s = X(!1); return n('punc', '(') ? (i(), r = F(')')) : r = [], Z(new Ge({
            start: t, expression: s, args: r, end: o(),
          }), e);
        }; var X = function (e) { if (n('operator', 'new')) return Y(e); const t = V.token; if (n('punc')) { switch (t.value) { case '(': i(); var r = ie(!0); return r.start = t, r.end = V.token, h(')'), Z(r, e); case '[': return Z(K(), e); case '{': return Z(Q(), e); }c(); } if (n('keyword', 'function')) { i(); const s = H(Ae); return s.start = t, s.end = o(), Z(s, e); } if (nn[V.token.type]) return Z(O(), e); c(); }; var K = g(() => h('['), new it({ elements: F(']', !t.strict, !0) })); const J = g(() => H(Ee)); var Q = g(() => {
          h('{'); for (var e = !0, r = []; !n('punc', '}') && (e ? e = !1 : h(','), t.strict || !n('punc', '}'));) {
            const s = V.token; const a = s.type; const u = B(); if (a == 'name' && !n('punc', ':')) {
              const c = new pt({ start: V.token, name: B(), end: o() }); if (u == 'get') {
                r.push(new ct({
                  start: s, key: c, value: J(), end: o(),
                })); continue;
              } if (u == 'set') {
                r.push(new ut({
                  start: s, key: c, value: J(), end: o(),
                })); continue;
              }
            }h(':'), r.push(new at({
              start: s, quote: s.quote, key: u, value: ie(!1), end: o(),
            }));
          } return i(), new ot({ properties: r });
        }); var Z = function (e, t) {
          const r = e.start; if (n('punc', '.')) {
            return i(), Z(new Ke({
              start: r, expression: e, property: D(), end: o(),
            }), t);
          } if (n('punc', '[')) {
            i(); const s = ie(!0); return h(']'), Z(new Je({
              start: r, expression: e, property: s, end: o(),
            }), t);
          } return t && n('punc', '(') ? (i(), Z(new We({
            start: r, expression: e, args: F(')'), end: o(),
          }), !0)) : e;
        }; var ee = function (e) { const t = V.token; if (n('operator') && Jt(t.value)) { i(), v(); const r = M(Ze, t, ee(e)); return r.start = t, r.end = o(), r; } for (var s = X(e); n('operator') && Qt(V.token.value) && !V.token.nlb;)(s = M(et, V.token, s)).start = t, s.end = V.token, i(); return s; }; var te = function (e, t, r) {
          let o = n('operator') ? V.token.value : null; o == 'in' && r && (o = null); const s = o != null ? en[o] : null; if (s != null && s > t) {
            i(); const a = te(ee(!0), s, r); return te(new tt({
              start: e.start, left: e, operator: o, right: a, end: a.end,
            }), t, r);
          } return e;
        }; const ne = function (e) {
          const t = V.token; const r = R(e); if (n('operator', '?')) {
            i(); const s = ie(!1); return h(':'), new nt({
              start: t, condition: r, consequent: s, alternative: ie(!1, e), end: o(),
            });
          } return r;
        }; var re = function (e) {
          const t = V.token; const r = ne(e); const s = V.token.value; if (n('operator') && Zt(s)) {
            if (P(r)) {
              return i(), new rt({
                start: t, left: r, operator: s, right: re(e), end: o(),
              });
            } a('Invalid assignment');
          } return r;
        }; var ie = function (e, t) {
          const o = V.token; const s = re(t); return e && n('punc', ',') ? (i(), new Ye({
            start: o, car: s, cdr: ie(!0, t), end: r(),
          })) : s;
        }; return t.expression ? ie(!0) : (function () { const e = V.token; const r = []; for (V.input.push_directives_stack(); !n('eof');)r.push(q()); V.input.pop_directives_stack(); const i = o(); let s = t.toplevel; return s ? (s.body = s.body.concat(r), s.end = i) : s = new we({ start: e, body: r, end: i }), s; }());
      } function H(e, t) { T.call(this), this.before = e, this.after = t; } function W(e, t, n) { this.name = n.name, this.orig = [n], this.scope = e, this.references = [], this.global = !1, this.mangled_name = null, this.undeclared = !1, this.index = t, this.id = W.next_id++; } function G(e) { return e.type == 'comment2' && /@preserve|@license|@cc_on/i.test(e.value); } function Y(e) {
        function t(e, t) { return e.replace(/[\u0000-\u001f\u007f-\uffff]/g, (e) => { let n = e.charCodeAt(0).toString(16); if (n.length <= 2 && !t) { for (;n.length < 2;)n = `0${n}`; return `\\x${n}`; } for (;n.length < 4;)n = `0${n}`; return `\\u${n}`; }); } function n(n, r) { function i() { return `'${n.replace(/\x27/g, "\\'")}'`; } function o() { return `"${n.replace(/\x22/g, '\\"')}"`; } let s = 0; let a = 0; switch (n = n.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g, (t, r) => { switch (t) { case '"': return ++s, '"'; case "'": return ++a, "'"; case '\\': return '\\\\'; case '\n': return '\\n'; case '\r': return '\\r'; case '\t': return '\\t'; case '\b': return '\\b'; case '\f': return '\\f'; case '\v': return e.screw_ie8 ? '\\v' : '\\x0B'; case '\u2028': return '\\u2028'; case '\u2029': return '\\u2029'; case '\ufeff': return '\\ufeff'; case '\0': return /[0-7]/.test(n.charAt(r + 1)) ? '\\x00' : '\\0'; } return t; }), e.ascii_only && (n = t(n)), e.quote_style) { case 1: return i(); case 2: return o(); case 3: return r == "'" ? i() : o(); default: return s > a ? i() : o(); } } function r(t, r) { let i = n(t, r); return e.inline_script && (i = (i = (i = i.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, '<\\/script$1')).replace(/\x3c!--/g, '\\x3c!--')).replace(/--\x3e/g, '--\\x3e')), i; } function i(n) { return n = n.toString(), e.ascii_only && (n = t(n, !0)), n; } function o(t) { return a(' ', e.indent_start + y - t * e.indent_level); } function s(t) { const n = (t = String(t)).charAt(0); const r = S.charAt(S.length - 1); if (A && (A = !1, (r == ':' && n == '}' || (!n || ';}'.indexOf(n) < 0) && r != ';') && (e.semicolons || O(n) ? (k += ';', b++, w++) : (T(), k += '\n', w++, _++, b = 0, /^\s+$/.test(t) && (A = !0)), e.beautify || (E = !1))), !e.beautify && e.preserve_line && R[R.length - 1]) for (let i = R[R.length - 1].start.line; _ < i;)T(), k += '\n', w++, _++, b = 0, E = !1; E && ((P(r) && (P(n) || n == '\\') || n == '/' && n == r || (n == '+' || n == '-') && n == S) && (k += ' ', b++, w++), E = !1), k += t, w += t.length; const o = t.split(/\r?\n/); const s = o.length - 1; _ += s, b += o[0].length, s > 0 && (T(), b = o[s].length), S = t; } function u() { A = !1, s(';'); } function c() { return y + e.indent_level; } function p() { return C && T(), k; } let m = f; if ((e = l(e, {
          ascii_only: !1, beautify: !1, bracketize: !1, comments: !1, indent_level: 4, indent_start: 0, inline_script: !0, keep_quoted_props: !1, max_line_len: !1, preamble: null, preserve_line: !1, quote_keys: !1, quote_style: 0, screw_ie8: !0, semicolons: !0, shebang: !0, source_map: null, space_colon: !0, unescape_regexps: !1, width: 80, wrap_iife: !1,
        }, !0)).comments) { let g = e.comments; if (typeof e.comments === 'string' && /^\/.*\/[a-zA-Z]*$/.test(e.comments)) { const v = e.comments.lastIndexOf('/'); g = new RegExp(e.comments.substr(1, v - 1), e.comments.substr(v + 1)); }m = g instanceof RegExp ? function (e) { return e.type != 'comment5' && g.test(e.value); } : typeof g === 'function' ? function (e) { return e.type != 'comment5' && g(this, e); } : g === 'some' ? G : d; } var y = 0; var b = 0; var _ = 1; var w = 0; var k = ''; var E = !1; var A = !1; var C = 0; var S = ''; var T = e.max_line_len ? function () { if (b > e.max_line_len) { if (C) { const t = k.slice(0, C); const n = k.slice(C); k = `${t}\n${n}`, _++, w++, b = n.length; }b > e.max_line_len && ie.warn('Output exceeds {max_line_len} characters', e); }C = 0; } : h; var O = x('( [ + * / - , .'); const F = e.beautify ? function () { s(' '); } : function () { E = !0; }; const B = e.beautify ? function (t) { e.beautify && s(o(t ? 0.5 : 0)); } : h; const D = e.beautify ? function (e, t) { !0 === e && (e = c()); const n = y; y = e; const r = t(); return y = n, r; } : function (e, t) { return t(); }; const L = e.beautify ? function () { s('\n'); } : e.max_line_len ? function () { T(), C = k.length; } : h; const N = e.beautify ? function () { s(';'); } : function () { A = !0; }; const M = e.source_map ? function (t, n) {
          try { t && e.source_map.add(t.file || '?', _, b, t.line, t.col, n || t.type != 'name' ? n : t.value); } catch (e) {
            ie.warn("Couldn't figure out mapping for {file}:{line},{col} â†’ {cline},{ccol} [{name}]", {
              file: t.file, line: t.line, col: t.col, cline: _, ccol: b, name: n || '',
            });
          }
        } : h; var R = []; return {
          get: p, toString: p, indent: B, indentation() { return y; }, current_width() { return b - y; }, should_break() { return e.width && this.current_width() >= e.width; }, newline: L, print: s, space: F, comma() { s(','), F(); }, colon() { s(':'), e.space_colon && F(); }, last() { return S; }, semicolon: N, force_semicolon: u, to_ascii: t, print_name(e) { s(i(e)); }, print_string(e, t, n) { const i = r(e, t); !0 === n && i.indexOf('\\') === -1 && (on.test(k) || u(), u()), s(i); }, encode_string: r, next_indent: c, with_indent: D, with_block(e) { let t; return s('{'), L(), D(c(), () => { t = e(); }), B(), s('}'), t; }, with_parens(e) { s('('); const t = e(); return s(')'), t; }, with_square(e) { s('['); const t = e(); return s(']'), t; }, add_mapping: M, option(t) { return e[t]; }, comment_filter: m, line() { return _; }, col() { return b; }, pos() { return w; }, push_node(e) { R.push(e); }, pop_node() { return R.pop(); }, parent(e) { return R[R.length - 2 - (e || 0)]; },
        };
      } function X(e, t) {
        if (!(this instanceof X)) return new X(e, t); H.call(this, this.before, this.after), this.options = l(e, {
          angular: !1, booleans: !t, cascade: !t, collapse_vars: !t, comparisons: !t, conditionals: !t, dead_code: !t, drop_console: !1, drop_debugger: !t, evaluate: !t, expression: !1, global_defs: {}, hoist_funs: !t, hoist_vars: !1, if_return: !t, join_vars: !t, keep_fargs: !0, keep_fnames: !1, keep_infinity: !1, loops: !t, negate_iife: !t, passes: 1, properties: !t, pure_getters: !t && 'strict', pure_funcs: null, reduce_vars: !t, screw_ie8: !0, sequences: !t, side_effects: !t, switches: !t, top_retain: null, toplevel: !(!e || !e.top_retain), unsafe: !1, unsafe_comps: !1, unsafe_math: !1, unsafe_proto: !1, unsafe_regexp: !1, unused: !t, warnings: !0,
        }, !0); const n = this.options.pure_funcs; this.pure_funcs = typeof n === 'function' ? n : n ? function (e) { return n.indexOf(e.expression.print_to_string()) < 0; } : d; let r = this.options.top_retain; r instanceof RegExp ? this.top_retain = function (e) { return r.test(e.name); } : typeof r === 'function' ? this.top_retain = r : r && (typeof r === 'string' && (r = r.split(/,/)), this.top_retain = function (e) { return r.indexOf(e.name) >= 0; }); const i = this.options.sequences; this.sequences_limit = i == 1 ? 200 : 0 | i, this.warnings_produced = {};
      } function K(e) {
        e = l(e, {
          file: null, root: null, orig: null, orig_line_diff: 0, dest_line_diff: 0,
        }); const t = new ee.SourceMapGenerator({ file: e.file, sourceRoot: e.root }); const n = e.orig && new ee.SourceMapConsumer(e.orig); return n && Array.isArray(e.orig.sources) && n._sources.toArray().forEach((e) => { const r = n.sourceContentFor(e, !0); r && t.setSourceContent(e, r); }), {
          add(r, i, o, s, a, u) {
            if (n) { const c = n.originalPositionFor({ line: s, column: a }); if (c.source === null) return; r = c.source, s = c.line, a = c.column, u = c.name || u; }t.addMapping({
              generated: { line: i + e.dest_line_diff, column: o }, original: { line: s + e.orig_line_diff, column: a }, source: r, name: u,
            });
          },
          get() { return t; },
          toString() { return JSON.stringify(t.toJSON()); },
        };
      } function J() { function e(e) { v(t, e); } var t = ['null', 'true', 'false', 'Infinity', '-Infinity', 'undefined']; return [Object, Array, Function, Number, String, Boolean, Error, Math, Date, RegExp].forEach((t) => { Object.getOwnPropertyNames(t).map(e), t.prototype && Object.getOwnPropertyNames(t.prototype).map(e); }), t; } function Q(e, t) {
        function n(e) { return !(g.indexOf(e) >= 0) && (!(u.indexOf(e) >= 0) && (t.only_cache ? c.props.has(e) : !/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(e))); } function r(e) { return !(f && e in y) && (!(h && !h.test(e)) && (!(u.indexOf(e) >= 0) && (c.props.has(e) || m.indexOf(e) >= 0))); } function i(e, t) { t ? y[e] = !0 : (n(e) && v(m, e), r(e) || v(g, e)); } function o(e) { if (!r(e)) return e; let t = c.props.get(e); if (!t) { if (d) { const i = `_$${e}$${p}_`; !n(i) || f && i in y || (t = i); } if (!t) do { t = rn(++c.cname); } while (!n(t) || f && t in y);c.props.set(e, t); } return t; } function s(e, t) { const n = {}; try { !(function e(r) { r.walk(new T(((r) => { if (r instanceof Ye) return e(r.cdr), !0; if (r instanceof Et) return i(r.value, t), !0; if (r instanceof nt) return e(r.consequent), e(r.alternative), !0; throw n; }))); }(e)); } catch (e) { if (e !== n) throw e; } } function a(e) { return e.transform(new H((e => (e instanceof Ye ? e.cdr = a(e.cdr) : e instanceof Et ? e.value = o(e.value) : e instanceof nt && (e.consequent = a(e.consequent), e.alternative = a(e.alternative))), e))); } var u = (t = l(t, {
          cache: null, debug: !1, ignore_quoted: !1, only_cache: !1, regex: null, reserved: null,
        })).reserved; u == null && (u = J()); var c = t.cache; c == null && (c = { cname: -1, props: new k() }); let p; var h = t.regex; var f = t.ignore_quoted; var d = !1 !== t.debug; d && (p = !0 === t.debug ? '' : t.debug); var m = []; var g = []; var y = {}; return e.walk(new T(((e) => { e instanceof at ? i(e.key, f && e.quote) : e instanceof st ? i(e.key.name) : e instanceof Ke ? i(e.property) : e instanceof Je && s(e.property, f); }))), e.transform(new H(((e) => { e instanceof at ? f && e.quote || (e.key = o(e.key)) : e instanceof st ? e.key.name = o(e.key.name) : e instanceof Ke ? e.property = o(e.property) : e instanceof Je && (f || (e.property = a(e.property))); })));
      } const Z = e('util'); var ee = e('source-map'); const te = n; c.prototype = Object.create(Error.prototype), c.prototype.constructor = c, c.prototype.name = 'DefaultsError', u(c), c.croak = function (e, t) { throw new c(e, t); }; const ne = (function () { function e(e, o, s) { function a() { let a = o(e[u], u); const p = a instanceof r; return p && (a = a.v), a instanceof t ? (a = a.v) instanceof n ? l.push(...s ? a.v.slice().reverse() : a.v) : l.push(a) : a !== i && (a instanceof n ? c.push(...s ? a.v.slice().reverse() : a.v) : c.push(a)), p; } let u; var c = []; var l = []; if (e instanceof Array) if (s) { for (u = e.length; --u >= 0 && !a(););c.reverse(), l.reverse(); } else for (u = 0; u < e.length && !a(); ++u);else for (u in e) if (E(e, u) && a()) break; return l.concat(c); } function t(e) { this.v = e; } function n(e) { this.v = e; } function r(e) { this.v = e; }e.at_top = function (e) { return new t(e); }, e.splice = function (e) { return new n(e); }, e.last = function (e) { return new r(e); }; var i = e.skip = {}; return e; }()); k.prototype = {
        set(e, t) { return this.has(e) || ++this._size, this._values[`$${e}`] = t, this; }, add(e, t) { return this.has(e) ? this.get(e).push(t) : this.set(e, [t]), this; }, get(e) { return this._values[`$${e}`]; }, del(e) { return this.has(e) && (--this._size, delete this._values[`$${e}`]), this; }, has(e) { return `$${e}` in this._values; }, each(e) { for (const t in this._values)e(this._values[t], t.substr(1)); }, size() { return this._size; }, map(e) { const t = []; for (const n in this._values)t.push(e(this._values[n], n.substr(1))); return t; }, toObject() { return this._values; },
      }, k.fromObject = function (e) { const t = new k(); return t._size = p(t._values, e), t; }; var re = C('Token', 'type value line col pos endline endcol endpos nlb comments_before file raw', {}, null); var ie = C('Node', 'start end', {
        _clone(e) { if (e) { const t = this.clone(); return t.transform(new H(((e) => { if (e !== t) return e.clone(!0); }))); } return new this.CTOR(this); }, clone(e) { return this._clone(e); }, $documentation: 'Base class of all AST nodes', $propdoc: { start: '[AST_Token] The first token of this node', end: '[AST_Token] The last token of this node' }, _walk(e) { return e._visit(this); }, walk(e) { return this._walk(e); },
      }, null); ie.warn_function = null, ie.warn = function (e, t) { ie.warn_function && ie.warn_function(y(e, t)); }; var oe = C('Statement', null, { $documentation: 'Base class of all statements' }); var se = C('Debugger', null, { $documentation: 'Represents a debugger statement' }, oe); var ae = C('Directive', 'value scope quote', { $documentation: 'Represents a directive, like "use strict";', $propdoc: { value: "[string] The value of this directive as a plain string (it's not an AST_String!)", scope: '[AST_Scope/S] The scope that this directive affects', quote: '[string] the original quote character' } }, oe); var ue = C('SimpleStatement', 'body', { $documentation: 'A statement consisting of an expression, i.e. a = 1 + 2', $propdoc: { body: '[AST_Node] an expression node (should not be instanceof AST_Statement)' }, _walk(e) { return e._visit(this, function () { this.body._walk(e); }); } }, oe); const ce = C('Block', 'body', { $documentation: 'A body of statements (usually bracketed)', $propdoc: { body: '[AST_Statement*] an array of statements' }, _walk(e) { return e._visit(this, function () { S(this, e); }); } }, oe); var le = C('BlockStatement', null, { $documentation: 'A block statement' }, ce); var pe = C('EmptyStatement', null, { $documentation: 'The empty statement (empty block or simply a semicolon)', _walk(e) { return e._visit(this); } }, oe); const he = C('StatementWithBody', 'body', { $documentation: 'Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`', $propdoc: { body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement" }, _walk(e) { return e._visit(this, function () { this.body._walk(e); }); } }, oe); var fe = C('LabeledStatement', 'label', {
        $documentation: 'Statement with a label', $propdoc: { label: '[AST_Label] a label definition' }, _walk(e) { return e._visit(this, function () { this.label._walk(e), this.body._walk(e); }); }, clone(e) { const t = this._clone(e); if (e) { const n = t.label; const r = this.label; t.walk(new T(((e) => { e instanceof Be && e.label && e.label.thedef === r && (e.label.thedef = n, n.references.push(e)); }))); } return t; },
      }, he); var de = C('IterationStatement', null, { $documentation: 'Internal class.  All loops inherit from it.' }, he); const me = C('DWLoop', 'condition', { $documentation: 'Base class for do/while statements', $propdoc: { condition: '[AST_Node] the loop condition.  Should not be instanceof AST_Statement' } }, de); var ge = C('Do', null, { $documentation: 'A `do` statement', _walk(e) { return e._visit(this, function () { this.body._walk(e), this.condition._walk(e); }); } }, me); var ve = C('While', null, { $documentation: 'A `while` statement', _walk(e) { return e._visit(this, function () { this.condition._walk(e), this.body._walk(e); }); } }, me); var ye = C('For', 'init condition step', { $documentation: 'A `for` statement', $propdoc: { init: '[AST_Node?] the `for` initialization code, or null if empty', condition: '[AST_Node?] the `for` termination clause, or null if empty', step: '[AST_Node?] the `for` update clause, or null if empty' }, _walk(e) { return e._visit(this, function () { this.init && this.init._walk(e), this.condition && this.condition._walk(e), this.step && this.step._walk(e), this.body._walk(e); }); } }, de); var be = C('ForIn', 'init name object', { $documentation: 'A `for ... in` statement', $propdoc: { init: '[AST_Node] the `for/in` initialization code', name: '[AST_SymbolRef?] the loop variable, only if `init` is AST_Var', object: "[AST_Node] the object that we're looping through" }, _walk(e) { return e._visit(this, function () { this.init._walk(e), this.object._walk(e), this.body._walk(e); }); } }, de); var _e = C('With', 'expression', { $documentation: 'A `with` statement', $propdoc: { expression: '[AST_Node] the `with` expression' }, _walk(e) { return e._visit(this, function () { this.expression._walk(e), this.body._walk(e); }); } }, he); const xe = C('Scope', 'directives variables functions uses_with uses_eval parent_scope enclosed cname', {
        $documentation: 'Base class for all statements introducing a lexical scope',
        $propdoc: {
          directives: '[string*/S] an array of directives declared in this scope', variables: '[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope', functions: '[Object/S] like `variables`, but only lists function declarations', uses_with: '[boolean/S] tells whether this scope uses the `with` statement', uses_eval: '[boolean/S] tells whether this scope contains a direct call to the global `eval`', parent_scope: '[AST_Scope?/S] link to the parent scope', enclosed: '[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes', cname: '[integer/S] current index for mangling variables (used internally by the mangler)',
        },
      }, ce); var we = C('Toplevel', 'globals', {
        $documentation: 'The toplevel scope', $propdoc: { globals: '[Object/S] a map of name -> SymbolDef for all undeclared names' }, wrap_enclose(e) { const t = this; const n = []; const r = []; e.forEach((e) => { const t = e.lastIndexOf(':'); n.push(e.substr(0, t)), r.push(e.substr(t + 1)); }); let i = `(function(${r.join(',')}){ '$ORIG'; })(${n.join(',')})`; return i = q(i), i = i.transform(new H(((e) => { if (e instanceof ae && e.value == '$ORIG') return ne.splice(t.body); }))); }, wrap_commonjs(e, t) { const n = this; const r = []; t && (n.figure_out_scope(), n.walk(new T(((e) => { e instanceof ht && e.definition().global && (s(t => t.name == e.name, r) || r.push(e)); })))); let i = `(function(exports, global){ '$ORIG'; '$EXPORTS'; global['${e}'] = exports; }({}, (function(){return this}())))`; return i = q(i), i = i.transform(new H(((e) => { if (e instanceof ae) switch (e.value) { case '$ORIG': return ne.splice(n.body); case '$EXPORTS': var t = []; return r.forEach((e) => { t.push(new ue({ body: new rt({ left: new Je({ expression: new _t({ name: 'exports' }), property: new Et({ value: e.name }) }), operator: '=', right: new _t(e) }) })); }), ne.splice(t); } }))); },
      }, xe); const ke = C('Lambda', 'name argnames uses_arguments', { $documentation: 'Base class for functions', $propdoc: { name: '[AST_SymbolDeclaration?] the name of this function', argnames: '[AST_SymbolFunarg*] array of function arguments', uses_arguments: '[boolean/S] tells whether this function accesses the arguments array' }, _walk(e) { return e._visit(this, function () { this.name && this.name._walk(e); for (let t = this.argnames, n = 0, r = t.length; n < r; n++)t[n]._walk(e); S(this, e); }); } }, xe); var Ee = C('Accessor', null, { $documentation: 'A setter/getter function.  The `name` property is always null.' }, ke); var Ae = C('Function', null, { $documentation: 'A function expression' }, ke); var Ce = C('Defun', null, { $documentation: 'A function definition' }, ke); const Se = C('Jump', null, { $documentation: "Base class for â€œjumpsâ€ (for now that's `return`, `throw`, `break` and `continue`)" }, oe); const Te = C('Exit', 'value', { $documentation: 'Base class for â€œexitsâ€ (`return` and `throw`)', $propdoc: { value: '[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return' }, _walk(e) { return e._visit(this, this.value && function () { this.value._walk(e); }); } }, Se); var Oe = C('Return', null, { $documentation: 'A `return` statement' }, Te); var Fe = C('Throw', null, { $documentation: 'A `throw` statement' }, Te); var Be = C('LoopControl', 'label', { $documentation: 'Base class for loop control statements (`break` and `continue`)', $propdoc: { label: '[AST_LabelRef?] the label, or null if none' }, _walk(e) { return e._visit(this, this.label && function () { this.label._walk(e); }); } }, Se); var De = C('Break', null, { $documentation: 'A `break` statement' }, Be); var Le = C('Continue', null, { $documentation: 'A `continue` statement' }, Be); var Ne = C('If', 'condition alternative', { $documentation: 'A `if` statement', $propdoc: { condition: '[AST_Node] the `if` condition', alternative: '[AST_Statement?] the `else` part, or null if not present' }, _walk(e) { return e._visit(this, function () { this.condition._walk(e), this.body._walk(e), this.alternative && this.alternative._walk(e); }); } }, he); var Me = C('Switch', 'expression', { $documentation: 'A `switch` statement', $propdoc: { expression: '[AST_Node] the `switch` â€œdiscriminantâ€' }, _walk(e) { return e._visit(this, function () { this.expression._walk(e), S(this, e); }); } }, ce); const Re = C('SwitchBranch', null, { $documentation: 'Base class for `switch` branches' }, ce); var Pe = C('Default', null, { $documentation: 'A `default` switch branch' }, Re); var Ie = C('Case', 'expression', { $documentation: 'A `case` switch branch', $propdoc: { expression: '[AST_Node] the `case` expression' }, _walk(e) { return e._visit(this, function () { this.expression._walk(e), S(this, e); }); } }, Re); var je = C('Try', 'bcatch bfinally', { $documentation: 'A `try` statement', $propdoc: { bcatch: '[AST_Catch?] the catch block, or null if not present', bfinally: '[AST_Finally?] the finally block, or null if not present' }, _walk(e) { return e._visit(this, function () { S(this, e), this.bcatch && this.bcatch._walk(e), this.bfinally && this.bfinally._walk(e); }); } }, ce); var Ve = C('Catch', 'argname', { $documentation: 'A `catch` node; only makes sense as part of a `try` statement', $propdoc: { argname: '[AST_SymbolCatch] symbol for the exception' }, _walk(e) { return e._visit(this, function () { this.argname._walk(e), S(this, e); }); } }, ce); var ze = C('Finally', null, { $documentation: 'A `finally` node; only makes sense as part of a `try` statement' }, ce); const Ue = C('Definitions', 'definitions', { $documentation: 'Base class for `var` or `const` nodes (variable declarations/initializations)', $propdoc: { definitions: '[AST_VarDef*] array of variable definitions' }, _walk(e) { return e._visit(this, function () { for (let t = this.definitions, n = 0, r = t.length; n < r; n++)t[n]._walk(e); }); } }, oe); var $e = C('Var', null, { $documentation: 'A `var` statement' }, Ue); var qe = C('Const', null, { $documentation: 'A `const` statement' }, Ue); var He = C('VarDef', 'name value', { $documentation: 'A variable declaration; only appears in a AST_Definitions node', $propdoc: { name: '[AST_SymbolVar|AST_SymbolConst] name of the variable', value: "[AST_Node?] initializer, or null of there's no initializer" }, _walk(e) { return e._visit(this, function () { this.name._walk(e), this.value && this.value._walk(e); }); } }); var We = C('Call', 'expression args', { $documentation: 'A function call expression', $propdoc: { expression: '[AST_Node] expression to invoke as function', args: '[AST_Node*] array of arguments' }, _walk(e) { return e._visit(this, function () { this.expression._walk(e); for (let t = this.args, n = 0, r = t.length; n < r; n++)t[n]._walk(e); }); } }); var Ge = C('New', null, { $documentation: 'An object instantiation.  Derives from a function call since it has exactly the same properties' }, We); var Ye = C('Seq', 'car cdr', {
        $documentation: 'A sequence expression (two comma-separated expressions)', $propdoc: { car: '[AST_Node] first element in sequence', cdr: '[AST_Node] second element in sequence' }, $cons(e, t) { const n = new Ye(e); return n.car = e, n.cdr = t, n; }, $from_array(e) { if (e.length == 0) return null; if (e.length == 1) return e[0].clone(); for (var t = null, n = e.length; --n >= 0;)t = Ye.cons(e[n], t); for (let r = t; r;) { if (r.cdr && !r.cdr.cdr) { r.cdr = r.cdr.car; break; }r = r.cdr; } return t; }, to_array() { for (var e = this, t = []; e;) { if (t.push(e.car), e.cdr && !(e.cdr instanceof Ye)) { t.push(e.cdr); break; }e = e.cdr; } return t; }, add(e) { for (let t = this; t;) { if (!(t.cdr instanceof Ye)) { const n = Ye.cons(t.cdr, e); return t.cdr = n; }t = t.cdr; } }, len() { return this.cdr instanceof Ye ? this.cdr.len() + 1 : 2; }, _walk(e) { return e._visit(this, function () { this.car._walk(e), this.cdr && this.cdr._walk(e); }); },
      }); var Xe = C('PropAccess', 'expression property', { $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`', $propdoc: { expression: '[AST_Node] the â€œcontainerâ€ expression', property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node" } }); var Ke = C('Dot', null, { $documentation: 'A dotted property access expression', _walk(e) { return e._visit(this, function () { this.expression._walk(e); }); } }, Xe); var Je = C('Sub', null, { $documentation: 'Index-style property access, i.e. `a["foo"]`', _walk(e) { return e._visit(this, function () { this.expression._walk(e), this.property._walk(e); }); } }, Xe); const Qe = C('Unary', 'operator expression', { $documentation: 'Base class for unary expressions', $propdoc: { operator: '[string] the operator', expression: '[AST_Node] expression that this unary operator applies to' }, _walk(e) { return e._visit(this, function () { this.expression._walk(e); }); } }); var Ze = C('UnaryPrefix', null, { $documentation: 'Unary prefix expression, i.e. `typeof i` or `++i`' }, Qe); var et = C('UnaryPostfix', null, { $documentation: 'Unary postfix expression, i.e. `i++`' }, Qe); var tt = C('Binary', 'left operator right', { $documentation: 'Binary expression, i.e. `a + b`', $propdoc: { left: '[AST_Node] left-hand side expression', operator: '[string] the operator', right: '[AST_Node] right-hand side expression' }, _walk(e) { return e._visit(this, function () { this.left._walk(e), this.right._walk(e); }); } }); var nt = C('Conditional', 'condition consequent alternative', { $documentation: 'Conditional expression using the ternary operator, i.e. `a ? b : c`', $propdoc: { condition: '[AST_Node]', consequent: '[AST_Node]', alternative: '[AST_Node]' }, _walk(e) { return e._visit(this, function () { this.condition._walk(e), this.consequent._walk(e), this.alternative._walk(e); }); } }); var rt = C('Assign', null, { $documentation: 'An assignment expression â€” `a = b + 5`' }, tt); var it = C('Array', 'elements', { $documentation: 'An array literal', $propdoc: { elements: '[AST_Node*] array of elements' }, _walk(e) { return e._visit(this, function () { for (let t = this.elements, n = 0, r = t.length; n < r; n++)t[n]._walk(e); }); } }); var ot = C('Object', 'properties', { $documentation: 'An object literal', $propdoc: { properties: '[AST_ObjectProperty*] array of properties' }, _walk(e) { return e._visit(this, function () { for (let t = this.properties, n = 0, r = t.length; n < r; n++)t[n]._walk(e); }); } }); var st = C('ObjectProperty', 'key value', { $documentation: 'Base class for literal object properties', $propdoc: { key: '[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an AST_SymbolAccessor.', value: '[AST_Node] property value.  For setters and getters this is an AST_Accessor.' }, _walk(e) { return e._visit(this, function () { this.value._walk(e); }); } }); var at = C('ObjectKeyVal', 'quote', { $documentation: 'A key: value object property', $propdoc: { quote: '[string] the original quote character' } }, st); var ut = C('ObjectSetter', null, { $documentation: 'An object setter property' }, st); var ct = C('ObjectGetter', null, { $documentation: 'An object getter property' }, st); const lt = C('Symbol', 'scope name thedef', { $propdoc: { name: '[string] name of this symbol', scope: '[AST_Scope/S] the current scope (not necessarily the definition scope)', thedef: '[SymbolDef/S] the definition of this symbol' }, $documentation: 'Base class for all symbols' }); var pt = C('SymbolAccessor', null, { $documentation: 'The name of a property accessor (setter/getter function)' }, lt); var ht = C('SymbolDeclaration', 'init', { $documentation: 'A declaration symbol (symbol in var/const, function name or argument, symbol in catch)' }, lt); var ft = C('SymbolVar', null, { $documentation: 'Symbol defining a variable' }, ht); var dt = C('SymbolConst', null, { $documentation: 'A constant declaration' }, ht); var mt = C('SymbolFunarg', null, { $documentation: 'Symbol naming a function argument' }, ft); var gt = C('SymbolDefun', null, { $documentation: 'Symbol defining a function' }, ht); var vt = C('SymbolLambda', null, { $documentation: 'Symbol naming a function expression' }, ht); var yt = C('SymbolCatch', null, { $documentation: 'Symbol naming the exception in catch' }, ht); var bt = C('Label', 'references', { $documentation: 'Symbol naming a label (declaration)', $propdoc: { references: '[AST_LoopControl*] a list of nodes referring to this label' }, initialize() { this.references = [], this.thedef = this; } }, lt); var _t = C('SymbolRef', null, { $documentation: 'Reference to some symbol (not definition/declaration)' }, lt); var xt = C('LabelRef', null, { $documentation: 'Reference to a label symbol' }, lt); var wt = C('This', null, { $documentation: 'The `this` symbol' }, lt); const kt = C('Constant', null, { $documentation: 'Base class for all constants', getValue() { return this.value; } }); var Et = C('String', 'value quote', { $documentation: 'A string literal', $propdoc: { value: '[string] the contents of this string', quote: '[string] the original quote character' } }, kt); var At = C('Number', 'value literal', { $documentation: 'A number literal', $propdoc: { value: '[number] the numeric value', literal: '[string] numeric value as string (optional)' } }, kt); var Ct = C('RegExp', 'value', { $documentation: 'A regexp literal', $propdoc: { value: '[RegExp] the actual regexp' } }, kt); const St = C('Atom', null, { $documentation: 'Base class for atoms' }, kt); var Tt = C('Null', null, { $documentation: 'The `null` atom', value: null }, St); const Ot = C('NaN', null, { $documentation: 'The impossible value', value: NaN }, St); const Ft = C('Undefined', null, { $documentation: 'The `undefined` value', value: void 0 }, St); var Bt = C('Hole', null, { $documentation: 'A hole in an array', value: void 0 }, St); const Dt = C('Infinity', null, { $documentation: 'The `Infinity` value', value: 1 / 0 }, St); const Lt = C('Boolean', null, { $documentation: 'Base class for booleans' }, St); var Nt = C('False', null, { $documentation: 'The `false` atom', value: !1 }, Lt); var Mt = C('True', null, { $documentation: 'The `true` atom', value: !0 }, Lt); T.prototype = {
        _visit(e, t) { this.push(e); const n = this.visit(e, t ? () => { t.call(e); } : h); return !n && t && t.call(e), this.pop(e), n; }, parent(e) { return this.stack[this.stack.length - 2 - (e || 0)]; }, push(e) { e instanceof ke ? this.directives = Object.create(this.directives) : e instanceof ae && !this.directives[e.value] && (this.directives[e.value] = e), this.stack.push(e); }, pop(e) { this.stack.pop(), e instanceof ke && (this.directives = Object.getPrototypeOf(this.directives)); }, self() { return this.stack[this.stack.length - 1]; }, find_parent(e) { for (let t = this.stack, n = t.length; --n >= 0;) { const r = t[n]; if (r instanceof e) return r; } }, has_directive(e) { const t = this.directives[e]; if (t) return t; const n = this.stack[this.stack.length - 1]; if (n instanceof xe) for (let r = 0; r < n.body.length; ++r) { const i = n.body[r]; if (!(i instanceof ae)) break; if (i.value == e) return i; } }, in_boolean_context() { for (let e = this.stack, t = e.length, n = e[--t]; t > 0;) { const r = e[--t]; if (r instanceof Ne && r.condition === n || r instanceof nt && r.condition === n || r instanceof me && r.condition === n || r instanceof ye && r.condition === n || r instanceof Ze && r.operator == '!' && r.expression === n) return !0; if (!(r instanceof tt) || r.operator != '&&' && r.operator != '||') return !1; n = r; } }, loopcontrol_target(e) { const t = this.stack; if (e.label) { for (n = t.length; --n >= 0;) if ((r = t[n]) instanceof fe && r.label.name == e.label.name) return r.body; } else for (var n = t.length; --n >= 0;) { var r = t[n]; if (r instanceof de || e instanceof De && r instanceof Me) return r; } },
      }; var Rt = 'break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with'; var Pt = 'false null true'; var It = `abstract boolean byte char class double enum export extends final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield ${Pt} ${Rt}`; var jt = 'return new delete throw else case'; Rt = x(Rt), It = x(It), jt = x(jt), Pt = x(Pt); var Vt = x(i('+-*&%=<>!?|~^')); var zt = /^0x[0-9a-f]+$/i; var Ut = /^0[0-7]+$/; var $t = x(['in', 'instanceof', 'typeof', 'new', 'void', 'delete', '++', '--', '+', '-', '!', '~', '&', '|', '^', '*', '/', '%', '>>', '<<', '>>>', '<', '>', '<=', '>=', '==', '===', '!=', '!==', '?', '=', '+=', '-=', '/=', '*=', '%=', '>>=', '<<=', '>>>=', '|=', '^=', '&=', '&&', '||']); var qt = x(i(' Â \n\r\t\f\vâ€‹â€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Š\u2028\u2029â€¯âŸã€€\ufeff')); var Ht = x(i('\n\r\u2028\u2029')); var Wt = x(i('[{(,;:')); var Gt = x(i('[]{}(),;:')); const Yt = x(i('gmsiy')); var Xt = {
        letter: new RegExp('[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'), digit: new RegExp('[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]'), non_spacing_mark: new RegExp('[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]'), space_combining_mark: new RegExp('[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]'), connector_punctuation: new RegExp('[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]'),
      }; V.prototype = Object.create(Error.prototype), V.prototype.constructor = V, V.prototype.name = 'SyntaxError', u(V); var Kt = {}; var Jt = x(['typeof', 'void', 'delete', '--', '++', '!', '~', '-', '+']); var Qt = x(['--', '++']); var Zt = x(['=', '+=', '-=', '/=', '*=', '%=', '>>=', '<<=', '>>>=', '|=', '^=', '&=']); var en = (function (e, t) { for (let n = 0; n < e.length; ++n) for (let r = e[n], i = 0; i < r.length; ++i)t[r[i]] = n + 1; return t; }([['||'], ['&&'], ['|'], ['^'], ['&'], ['==', '===', '!=', '!=='], ['<', '>', '<=', '>=', 'in', 'instanceof'], ['>>', '<<', '>>>'], ['+', '-'], ['*', '/', '%']], {})); const tn = r(['for', 'do', 'while', 'switch']); var nn = r(['atom', 'num', 'string', 'regexp', 'name']); H.prototype = new T(), (function (e) { function t(t, n) { t.DEFMETHOD('transform', function (t, r) { let i; let o; return t.push(this), t.before && (i = t.before(this, n, r)), i === e && (t.after ? (t.stack[t.stack.length - 1] = i = this, n(i, t), (o = t.after(i, r)) !== e && (i = o)) : n(i = this, t)), t.pop(this), i; }); } function n(e, t) { return ne(e, e => e.transform(t, !0)); }t(ie, h), t(fe, (e, t) => { e.label = e.label.transform(t), e.body = e.body.transform(t); }), t(ue, (e, t) => { e.body = e.body.transform(t); }), t(ce, (e, t) => { e.body = n(e.body, t); }), t(me, (e, t) => { e.condition = e.condition.transform(t), e.body = e.body.transform(t); }), t(ye, (e, t) => { e.init && (e.init = e.init.transform(t)), e.condition && (e.condition = e.condition.transform(t)), e.step && (e.step = e.step.transform(t)), e.body = e.body.transform(t); }), t(be, (e, t) => { e.init = e.init.transform(t), e.object = e.object.transform(t), e.body = e.body.transform(t); }), t(_e, (e, t) => { e.expression = e.expression.transform(t), e.body = e.body.transform(t); }), t(Te, (e, t) => { e.value && (e.value = e.value.transform(t)); }), t(Be, (e, t) => { e.label && (e.label = e.label.transform(t)); }), t(Ne, (e, t) => { e.condition = e.condition.transform(t), e.body = e.body.transform(t), e.alternative && (e.alternative = e.alternative.transform(t)); }), t(Me, (e, t) => { e.expression = e.expression.transform(t), e.body = n(e.body, t); }), t(Ie, (e, t) => { e.expression = e.expression.transform(t), e.body = n(e.body, t); }), t(je, (e, t) => { e.body = n(e.body, t), e.bcatch && (e.bcatch = e.bcatch.transform(t)), e.bfinally && (e.bfinally = e.bfinally.transform(t)); }), t(Ve, (e, t) => { e.argname = e.argname.transform(t), e.body = n(e.body, t); }), t(Ue, (e, t) => { e.definitions = n(e.definitions, t); }), t(He, (e, t) => { e.name = e.name.transform(t), e.value && (e.value = e.value.transform(t)); }), t(ke, (e, t) => { e.name && (e.name = e.name.transform(t)), e.argnames = n(e.argnames, t), e.body = n(e.body, t); }), t(We, (e, t) => { e.expression = e.expression.transform(t), e.args = n(e.args, t); }), t(Ye, (e, t) => { e.car = e.car.transform(t), e.cdr = e.cdr.transform(t); }), t(Ke, (e, t) => { e.expression = e.expression.transform(t); }), t(Je, (e, t) => { e.expression = e.expression.transform(t), e.property = e.property.transform(t); }), t(Qe, (e, t) => { e.expression = e.expression.transform(t); }), t(tt, (e, t) => { e.left = e.left.transform(t), e.right = e.right.transform(t); }), t(nt, (e, t) => { e.condition = e.condition.transform(t), e.consequent = e.consequent.transform(t), e.alternative = e.alternative.transform(t); }), t(it, (e, t) => { e.elements = n(e.elements, t); }), t(ot, (e, t) => { e.properties = n(e.properties, t); }), t(st, (e, t) => { e.value = e.value.transform(t); }); }()), W.next_id = 1, W.prototype = { unmangleable(e) { return e || (e = {}), this.global && !e.toplevel || this.undeclared || !e.eval && (this.scope.uses_eval || this.scope.uses_with) || e.keep_fnames && (this.orig[0] instanceof vt || this.orig[0] instanceof gt); }, mangle(e) { const t = e.cache && e.cache.props; if (this.global && t && t.has(this.name)) this.mangled_name = t.get(this.name); else if (!this.mangled_name && !this.unmangleable(e)) { let n = this.scope; const r = this.orig[0]; !e.screw_ie8 && r instanceof vt && (n = n.parent_scope); let i; this.defun && (i = this.defun.variables.get(this.name)) ? this.mangled_name = i.mangled_name || i.name : this.mangled_name = n.next_mangled(e, this), this.global && t && t.set(this.name, this.mangled_name); } } }, we.DEFMETHOD('figure_out_scope', function (e) { e = l(e, { cache: null, screw_ie8: !0 }); const t = this; let n = t.parent_scope = null; let r = new k(); let i = null; var o = new T(((t, o) => { if (t instanceof Ve) { s = n; return (n = new xe(t)).init_scope_vars(s), o(), n = s, !0; } if (t instanceof xe) { t.init_scope_vars(n); var s = n; const a = i; const u = r; return i = n = t, r = new k(), o(), n = s, i = a, r = u, !0; } if (t instanceof fe) { const c = t.label; if (r.has(c.name)) throw new Error(y('Label {name} defined twice', c)); return r.set(c.name, c), o(), r.del(c.name), !0; } if (t instanceof _e) for (let l = n; l; l = l.parent_scope)l.uses_with = !0; else if (t instanceof lt && (t.scope = n), t instanceof bt && (t.thedef = t, t.references = []), t instanceof vt)i.def_function(t); else if (t instanceof gt)(t.scope = i.parent_scope).def_function(t); else if (t instanceof ft || t instanceof dt) { if (i.def_variable(t), i !== n) { t.mark_enclosed(e); const p = n.find_variable(t); t.thedef !== p && (t.thedef = p, t.reference(e)); } } else if (t instanceof yt)n.def_variable(t).defun = i; else if (t instanceof xt) { const h = r.get(t.name); if (!h) throw new Error(y('Undefined label {name} [{line},{col}]', { name: t.name, line: t.start.line, col: t.start.col })); t.thedef = h; } })); t.walk(o); let s = null; var o = (t.globals = new k(), new T(((n, r) => { if (n instanceof ke) { const i = s; return s = n, r(), s = i, !0; } if (n instanceof Be && n.label) return n.label.thedef.references.push(n), !0; if (n instanceof _t) { const a = n.name; if (a == 'eval' && o.parent() instanceof We) for (let u = n.scope; u && !u.uses_eval; u = u.parent_scope)u.uses_eval = !0; let c = n.scope.find_variable(a); return n.scope instanceof ke && a == 'arguments' && (n.scope.uses_arguments = !0), c || (c = t.def_global(n)), n.thedef = c, n.reference(e), !0; } }))); t.walk(o), e.screw_ie8 || t.walk(new T(((n, r) => { if (n instanceof yt) { const i = n.name; const o = n.thedef.references; const s = n.thedef.defun; const a = s.find_variable(i) || t.globals.get(i) || s.def_variable(n); return o.forEach((t) => { t.thedef = a, t.reference(e); }), n.thedef = a, !0; } }))), e.cache && (this.cname = e.cache.cname); }), we.DEFMETHOD('def_global', function (e) { const t = this.globals; const n = e.name; if (t.has(n)) return t.get(n); const r = new W(this, t.size(), e); return r.undeclared = !0, r.global = !0, t.set(n, r), r; }), xe.DEFMETHOD('init_scope_vars', function (e) { this.variables = new k(), this.functions = new k(), this.uses_with = !1, this.uses_eval = !1, this.parent_scope = e, this.enclosed = [], this.cname = -1; }), ke.DEFMETHOD('init_scope_vars', function () { xe.prototype.init_scope_vars.apply(this, arguments), this.uses_arguments = !1, this.def_variable(new ft({ name: 'arguments', start: this.start, end: this.end })); }), lt.DEFMETHOD('mark_enclosed', function (e) { for (var t = this.definition(), n = this.scope; n && (v(n.enclosed, t), e.keep_fnames && n.functions.each((e) => { v(t.scope.enclosed, e); }), n !== t.scope);)n = n.parent_scope; }), lt.DEFMETHOD('reference', function (e) { this.definition().references.push(this), this.mark_enclosed(e); }), xe.DEFMETHOD('find_variable', function (e) { return e instanceof lt && (e = e.name), this.variables.get(e) || this.parent_scope && this.parent_scope.find_variable(e); }), xe.DEFMETHOD('def_function', function (e) { this.functions.set(e.name, this.def_variable(e)); }), xe.DEFMETHOD('def_variable', function (e) { let t; return this.variables.has(e.name) ? (t = this.variables.get(e.name)).orig.push(e) : (t = new W(this, this.variables.size(), e), this.variables.set(e.name, t), t.global = !this.parent_scope), e.thedef = t; }), xe.DEFMETHOD('next_mangled', function (e) { const t = this.enclosed; e:for (;;) { const n = rn(++this.cname); if (M(n) && !(e.except.indexOf(n) >= 0)) { for (let r = t.length; --r >= 0;) { const i = t[r]; if (n == (i.mangled_name || i.unmangleable(e) && i.name)) continue e; } return n; } } }), Ae.DEFMETHOD('next_mangled', function (e, t) { for (let n = t.orig[0] instanceof mt && this.name && this.name.definition(), r = n ? n.mangled_name || n.name : null; ;) { const i = ke.prototype.next_mangled.call(this, e, t); if (!r || r != i) return i; } }), lt.DEFMETHOD('unmangleable', function (e) { return this.definition().unmangleable(e); }), bt.DEFMETHOD('unmangleable', () => !1), lt.DEFMETHOD('unreferenced', function () { return this.definition().references.length == 0 && !(this.scope.uses_eval || this.scope.uses_with); }), lt.DEFMETHOD('undeclared', function () { return this.definition().undeclared; }), xt.DEFMETHOD('undeclared', () => !1), bt.DEFMETHOD('undeclared', () => !1), lt.DEFMETHOD('definition', function () { return this.thedef; }), lt.DEFMETHOD('global', function () { return this.definition().global; }), we.DEFMETHOD('_default_mangler_options', e => l(e, {
        eval: !1, except: [], keep_fnames: !1, screw_ie8: !0, sort: !1, toplevel: !1,
      })), we.DEFMETHOD('mangle_names', function (e) { (e = this._default_mangler_options(e)).except.push('arguments'); let t = -1; const n = []; e.cache && this.globals.each((t) => { e.except.indexOf(t.name) < 0 && n.push(t); }); var r = new T(((i, o) => { if (i instanceof fe) { const s = t; return o(), t = s, !0; } if (i instanceof xe) { r.parent(); const a = []; return i.variables.each((t) => { e.except.indexOf(t.name) < 0 && a.push(t); }), void n.push(...a); } if (i instanceof bt) { let u; do { u = rn(++t); } while (!M(u));return i.mangled_name = u, !0; }e.screw_ie8 && i instanceof yt && n.push(i.definition()); })); this.walk(r), n.forEach((t) => { t.mangle(e); }), e.cache && (e.cache.cname = this.cname); }), we.DEFMETHOD('compute_char_frequency', function (e) { e = this._default_mangler_options(e); const t = new T(((t) => { t instanceof kt ? rn.consider(t.print_to_string()) : t instanceof Oe ? rn.consider('return') : t instanceof Fe ? rn.consider('throw') : t instanceof Le ? rn.consider('continue') : t instanceof De ? rn.consider('break') : t instanceof se ? rn.consider('debugger') : t instanceof ae ? rn.consider(t.value) : t instanceof ve ? rn.consider('while') : t instanceof ge ? rn.consider('do while') : t instanceof Ne ? (rn.consider('if'), t.alternative && rn.consider('else')) : t instanceof $e ? rn.consider('var') : t instanceof qe ? rn.consider('const') : t instanceof ke ? rn.consider('function') : t instanceof ye ? rn.consider('for') : t instanceof be ? rn.consider('for in') : t instanceof Me ? rn.consider('switch') : t instanceof Ie ? rn.consider('case') : t instanceof Pe ? rn.consider('default') : t instanceof _e ? rn.consider('with') : t instanceof ut ? rn.consider(`set${t.key}`) : t instanceof ct ? rn.consider(`get${t.key}`) : t instanceof at ? rn.consider(t.key) : t instanceof Ge ? rn.consider('new') : t instanceof wt ? rn.consider('this') : t instanceof je ? rn.consider('try') : t instanceof Ve ? rn.consider('catch') : t instanceof ze ? rn.consider('finally') : t instanceof lt && t.unmangleable(e) ? rn.consider(t.name) : t instanceof Qe || t instanceof tt ? rn.consider(t.operator) : t instanceof Ke && rn.consider(t.property); })); this.walk(t), rn.sort(); }); var rn = (function () { function e() { r = Object.create(null), (n = i.split('').map(e => e.charCodeAt(0))).forEach((e) => { r[e] = 0; }); } function t(e) { let t = ''; let r = 54; e++; do { e--, t += String.fromCharCode(n[e % r]), e = Math.floor(e / r), r = 64; } while (e > 0);return t; } let n; let r; var i = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789'; return t.consider = function (e) { for (let t = e.length; --t >= 0;) { const n = e.charCodeAt(t); n in r && ++r[n]; } }, t.sort = function () { n = _(n, (e, t) => (F(e) && !F(t) ? 1 : F(t) && !F(e) ? -1 : r[t] - r[e])); }, t.reset = e, e(), t.get = function () { return n; }, t.freq = function () { return r; }, t; }()); we.DEFMETHOD('scope_warnings', function (e) {
        e = l(e, {
          assign_to_global: !0, eval: !0, func_arguments: !0, nested_defuns: !0, undeclared: !1, unreferenced: !0,
        }); var t = new T(((n) => {
          if (e.undeclared && n instanceof _t && n.undeclared() && ie.warn('Undeclared symbol: {name} [{file}:{line},{col}]', {
            name: n.name, file: n.start.file, line: n.start.line, col: n.start.col,
          }), e.assign_to_global) {
            let r = null; n instanceof rt && n.left instanceof _t ? r = n.left : n instanceof be && n.init instanceof _t && (r = n.init), r && (r.undeclared() || r.global() && r.scope !== r.definition().scope) && ie.warn('{msg}: {name} [{file}:{line},{col}]', {
              msg: r.undeclared() ? 'Accidental global?' : 'Assignment to global', name: r.name, file: r.start.file, line: r.start.line, col: r.start.col,
            });
          }e.eval && n instanceof _t && n.undeclared() && n.name == 'eval' && ie.warn('Eval is used [{file}:{line},{col}]', n.start), e.unreferenced && (n instanceof ht || n instanceof bt) && !(n instanceof yt) && n.unreferenced() && ie.warn('{type} {name} is declared but not referenced [{file}:{line},{col}]', {
            type: n instanceof bt ? 'Label' : 'Symbol', name: n.name, file: n.start.file, line: n.start.line, col: n.start.col,
          }), e.func_arguments && n instanceof ke && n.uses_arguments && ie.warn('arguments used in function {name} [{file}:{line},{col}]', {
            name: n.name ? n.name.name : 'anonymous', file: n.start.file, line: n.start.line, col: n.start.col,
          }), e.nested_defuns && n instanceof Ce && !(t.parent() instanceof xe) && ie.warn('Function {name} declared in nested statement "{type}" [{file}:{line},{col}]', {
            name: n.name.name, type: t.parent().TYPE, file: n.start.file, line: n.start.line, col: n.start.col,
          });
        })); this.walk(t);
      }); var on = /^$|[;{][\s\n]*$/; !(function () { function e(e, t) { e.DEFMETHOD('_codegen', t); } function t(e, n) { Array.isArray(e) ? e.forEach((e) => { t(e, n); }) : e.DEFMETHOD('needs_parens', n); } function n(e, t, n, r) { const i = e.length - 1; v = r, e.forEach((e, r) => { !0 !== v || e instanceof ae || e instanceof pe || e instanceof ue && e.body instanceof Et || (v = !1), e instanceof pe || (n.indent(), e.print(n), r == i && t || (n.newline(), t && n.newline())), !0 === v && e instanceof ue && e.body instanceof Et && (v = !1); }), v = !1; } function r(e, t, r) { e.length > 0 ? t.with_block(() => { n(e, !1, t, r); }) : t.print('{}'); } function i(e, t) { let n = e.body; if (t.option('bracketize') || !t.option('screw_ie8') && n instanceof ge) return f(n, t); if (!n) return t.force_semicolon(); for (;;) if (n instanceof Ne) { if (!n.alternative) return void f(e.body, t); n = n.alternative; } else { if (!(n instanceof he)) break; n = n.body; }u(e.body, t); } function o(e, t, n) { if (n) try { e.walk(new T(((e) => { if (e instanceof tt && e.operator == 'in') throw t; }))), e.print(t); } catch (n) { if (n !== t) throw n; e.print(t, !0); } else e.print(t); } function s(e, t, n) { n.option('quote_keys') ? n.print_string(`${e}`) : (typeof e === 'number' || !n.option('beautify') && `${+e}` == e) && parseFloat(e) >= 0 ? n.print(p(e)) : (It(e) ? n.option('screw_ie8') : I(e)) ? t && n.option('keep_quoted_props') ? n.print_string(e, t) : n.print_name(e) : n.print_string(e, t); } function a(e) { return [92, 47, 46, 43, 42, 63, 40, 41, 91, 93, 123, 125, 36, 94, 58, 124, 33, 10, 13, 0, 65279, 8232, 8233].indexOf(e) < 0; } function u(e, t) { t.option('bracketize') ? f(e, t) : !e || e instanceof pe ? t.force_semicolon() : e.print(t); } function c(e, t) { return e.args.length > 0 || t.option('beautify'); } function l(e) { for (var t = e[0], n = t.length, r = 1; r < e.length; ++r)e[r].length < n && (n = (t = e[r]).length); return t; } function p(e) { let t; const n = e.toString(10); const r = [n.replace(/^0\./, '.').replace('e+', 'e')]; return Math.floor(e) === e ? (e >= 0 ? r.push(`0x${e.toString(16).toLowerCase()}`, `0${e.toString(8)}`) : r.push(`-0x${(-e).toString(16).toLowerCase()}`, `-0${(-e).toString(8)}`), (t = /^(.*?)(0+)$/.exec(e)) && r.push(`${t[1]}e${t[2].length}`)) : (t = /^0?\.(0+)(.*)$/.exec(e)) && r.push(`${t[2]}e-${t[1].length + t[2].length}`, n.substr(n.indexOf('.'))), l(r); } function f(e, t) { !e || e instanceof pe ? t.print('{}') : e instanceof le ? e.print(t) : t.with_block(() => { t.indent(), e.print(t), t.newline(); }); } function d(e, t) { e.DEFMETHOD('add_source_map', function (e) { t(this, e); }); } function m(e, t) { t.add_mapping(e.start); } let g = !1; var v = !1; ie.DEFMETHOD('print', function (e, t) { function n() { r.add_comments(e), r.add_source_map(e), i(r, e); } var r = this; var i = r._codegen; const o = g; r instanceof ae && r.value == 'use asm' && e.parent() instanceof xe && (g = !0), e.push_node(r), t || r.needs_parens(e) ? e.with_parens(n) : n(), e.pop_node(), r instanceof xe && (g = o); }), ie.DEFMETHOD('print_to_string', function (e) { const t = Y(e); return e || (t._readonly = !0), this.print(t), t.get(); }), ie.DEFMETHOD('add_comments', function (e) { if (!e._readonly) { const t = this; const n = t.start; if (n && !n._comments_dumped) { n._comments_dumped = !0; let r = n.comments_before || []; if (t instanceof Te && t.value && t.value.walk(new T(((e) => { if (e.start && e.start.comments_before && (r = r.concat(e.start.comments_before), e.start.comments_before = []), e instanceof Ae || e instanceof it || e instanceof ot) return !0; }))), e.pos() == 0) { r.length > 0 && e.option('shebang') && r[0].type == 'comment5' && (e.print(`#!${r.shift().value}\n`), e.indent()); const i = e.option('preamble'); i && e.print(i.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, '\n')); }r = r.filter(e.comment_filter, t), !e.option('beautify') && r.length > 0 && /comment[134]/.test(r[0].type) && e.col() !== 0 && r[0].nlb && e.print('\n'), r.forEach((t) => { /comment[134]/.test(t.type) ? (e.print(`//${t.value}\n`), e.indent()) : t.type == 'comment2' && (e.print(`/*${t.value}*/`), n.nlb ? (e.print('\n'), e.indent()) : e.space()); }); } } }), t(ie, () => !1), t(Ae, function (e) { if (A(e)) return !0; if (e.option('wrap_iife')) { const t = e.parent(); return t instanceof We && t.expression === this; } return !1; }), t(ot, e => A(e)), t(Qe, function (e) { const t = e.parent(); return t instanceof Xe && t.expression === this || t instanceof We && t.expression === this; }), t(Ye, (e) => { const t = e.parent(); return t instanceof We || t instanceof Qe || t instanceof tt || t instanceof He || t instanceof Xe || t instanceof it || t instanceof st || t instanceof nt; }), t(tt, function (e) { const t = e.parent(); if (t instanceof We && t.expression === this) return !0; if (t instanceof Qe) return !0; if (t instanceof Xe && t.expression === this) return !0; if (t instanceof tt) { const n = t.operator; const r = en[n]; const i = this.operator; const o = en[i]; if (r > o || r == o && this === t.right) return !0; } }), t(Xe, function (e) { const t = e.parent(); if (t instanceof Ge && t.expression === this) try { this.walk(new T(((e) => { if (e instanceof We) throw t; }))); } catch (e) { if (e !== t) throw e; return !0; } }), t(We, function (e) { let t; const n = e.parent(); return n instanceof Ge && n.expression === this || this.expression instanceof Ae && n instanceof Xe && n.expression === this && (t = e.parent(1)) instanceof rt && t.left === n; }), t(Ge, function (e) { const t = e.parent(); if (!c(this, e) && (t instanceof Xe || t instanceof We && t.expression === this)) return !0; }), t(At, function (e) { const t = e.parent(); if (t instanceof Xe && t.expression === this) { const n = this.getValue(); if (n < 0 || /^0/.test(p(n))) return !0; } }), t([rt, nt], function (e) { const t = e.parent(); return t instanceof Qe || (t instanceof tt && !(t instanceof rt) || (t instanceof We && t.expression === this || (t instanceof nt && t.condition === this || (t instanceof Xe && t.expression === this || void 0)))); }), e(ae, (e, t) => { t.print_string(e.value, e.quote), t.semicolon(); }), e(se, (e, t) => { t.print('debugger'), t.semicolon(); }), he.DEFMETHOD('_do_print_body', function (e) { u(this.body, e); }), e(oe, (e, t) => { e.body.print(t), t.semicolon(); }), e(we, (e, t) => { n(e.body, !0, t, !0), t.print(''); }), e(fe, (e, t) => { e.label.print(t), t.colon(), e.body.print(t); }), e(ue, (e, t) => { e.body.print(t), t.semicolon(); }), e(le, (e, t) => { r(e.body, t); }), e(pe, (e, t) => { t.semicolon(); }), e(ge, (e, t) => { t.print('do'), t.space(), f(e.body, t), t.space(), t.print('while'), t.space(), t.with_parens(() => { e.condition.print(t); }), t.semicolon(); }), e(ve, (e, t) => { t.print('while'), t.space(), t.with_parens(() => { e.condition.print(t); }), t.space(), e._do_print_body(t); }), e(ye, (e, t) => { t.print('for'), t.space(), t.with_parens(() => { e.init ? (e.init instanceof Ue ? e.init.print(t) : o(e.init, t, !0), t.print(';'), t.space()) : t.print(';'), e.condition ? (e.condition.print(t), t.print(';'), t.space()) : t.print(';'), e.step && e.step.print(t); }), t.space(), e._do_print_body(t); }), e(be, (e, t) => { t.print('for'), t.space(), t.with_parens(() => { e.init.print(t), t.space(), t.print('in'), t.space(), e.object.print(t); }), t.space(), e._do_print_body(t); }), e(_e, (e, t) => { t.print('with'), t.space(), t.with_parens(() => { e.expression.print(t); }), t.space(), e._do_print_body(t); }), ke.DEFMETHOD('_do_print', function (e, t) { const n = this; t || e.print('function'), n.name && (e.space(), n.name.print(e)), e.with_parens(() => { n.argnames.forEach((t, n) => { n && e.comma(), t.print(e); }); }), e.space(), r(n.body, e, !0); }), e(ke, (e, t) => { e._do_print(t); }), Te.DEFMETHOD('_do_print', function (e, t) { e.print(t), this.value && (e.space(), this.value.print(e)), e.semicolon(); }), e(Oe, (e, t) => { e._do_print(t, 'return'); }), e(Fe, (e, t) => { e._do_print(t, 'throw'); }), Be.DEFMETHOD('_do_print', function (e, t) { e.print(t), this.label && (e.space(), this.label.print(e)), e.semicolon(); }), e(De, (e, t) => { e._do_print(t, 'break'); }), e(Le, (e, t) => { e._do_print(t, 'continue'); }), e(Ne, (e, t) => { t.print('if'), t.space(), t.with_parens(() => { e.condition.print(t); }), t.space(), e.alternative ? (i(e, t), t.space(), t.print('else'), t.space(), e.alternative instanceof Ne ? e.alternative.print(t) : u(e.alternative, t)) : e._do_print_body(t); }), e(Me, (e, t) => { t.print('switch'), t.space(), t.with_parens(() => { e.expression.print(t); }), t.space(); const n = e.body.length - 1; n < 0 ? t.print('{}') : t.with_block(() => { e.body.forEach((e, r) => { t.indent(!0), e.print(t), r < n && e.body.length > 0 && t.newline(); }); }); }), Re.DEFMETHOD('_do_print_body', function (e) { e.newline(), this.body.forEach((t) => { e.indent(), t.print(e), e.newline(); }); }), e(Pe, (e, t) => { t.print('default:'), e._do_print_body(t); }), e(Ie, (e, t) => { t.print('case'), t.space(), e.expression.print(t), t.print(':'), e._do_print_body(t); }), e(je, (e, t) => { t.print('try'), t.space(), r(e.body, t), e.bcatch && (t.space(), e.bcatch.print(t)), e.bfinally && (t.space(), e.bfinally.print(t)); }), e(Ve, (e, t) => { t.print('catch'), t.space(), t.with_parens(() => { e.argname.print(t); }), t.space(), r(e.body, t); }), e(ze, (e, t) => { t.print('finally'), t.space(), r(e.body, t); }), Ue.DEFMETHOD('_do_print', function (e, t) { e.print(t), e.space(), this.definitions.forEach((t, n) => { n && e.comma(), t.print(e); }); const n = e.parent(); (n instanceof ye || n instanceof be) && n.init === this || e.semicolon(); }), e($e, (e, t) => { e._do_print(t, 'var'); }), e(qe, (e, t) => { e._do_print(t, 'const'); }), e(He, (e, t) => { if (e.name.print(t), e.value) { t.space(), t.print('='), t.space(); const n = t.parent(1); const r = n instanceof ye || n instanceof be; o(e.value, t, r); } }), e(We, (e, t) => { e.expression.print(t), e instanceof Ge && !c(e, t) || t.with_parens(() => { e.args.forEach((e, n) => { n && t.comma(), e.print(t); }); }); }), e(Ge, (e, t) => { t.print('new'), t.space(), We.prototype._codegen(e, t); }), Ye.DEFMETHOD('_do_print', function (e) { this.car.print(e), this.cdr && (e.comma(), e.should_break() && (e.newline(), e.indent()), this.cdr.print(e)); }), e(Ye, (e, t) => { e._do_print(t); }), e(Ke, (e, t) => { const n = e.expression; n.print(t), n instanceof At && n.getValue() >= 0 && (/[xa-f.)]/i.test(t.last()) || t.print('.')), t.print('.'), t.add_mapping(e.end), t.print_name(e.property); }), e(Je, (e, t) => { e.expression.print(t), t.print('['), e.property.print(t), t.print(']'); }), e(Ze, (e, t) => { const n = e.operator; t.print(n), (/^[a-z]/i.test(n) || /[+-]$/.test(n) && e.expression instanceof Ze && /^[+-]/.test(e.expression.operator)) && t.space(), e.expression.print(t); }), e(et, (e, t) => { e.expression.print(t), t.print(e.operator); }), e(tt, (e, t) => { const n = e.operator; e.left.print(t), n[0] == '>' && e.left instanceof et && e.left.operator == '--' ? t.print(' ') : t.space(), t.print(n), (n == '<' || n == '<<') && e.right instanceof Ze && e.right.operator == '!' && e.right.expression instanceof Ze && e.right.expression.operator == '--' ? t.print(' ') : t.space(), e.right.print(t); }), e(nt, (e, t) => { e.condition.print(t), t.space(), t.print('?'), t.space(), e.consequent.print(t), t.space(), t.colon(), e.alternative.print(t); }), e(it, (e, t) => { t.with_square(() => { const n = e.elements; const r = n.length; r > 0 && t.space(), n.forEach((e, n) => { n && t.comma(), e.print(t), n === r - 1 && e instanceof Bt && t.comma(); }), r > 0 && t.space(); }); }), e(ot, (e, t) => { e.properties.length > 0 ? t.with_block(() => { e.properties.forEach((e, n) => { n && (t.print(','), t.newline()), t.indent(), e.print(t); }), t.newline(); }) : t.print('{}'); }), e(at, (e, t) => { s(e.key, e.quote, t), t.colon(), e.value.print(t); }), st.DEFMETHOD('_print_getter_setter', function (e, t) { t.print(e), t.space(), s(this.key.name, this.quote, t), this.value._do_print(t, !0); }), e(ut, (e, t) => { e._print_getter_setter('set', t); }), e(ct, (e, t) => { e._print_getter_setter('get', t); }), e(lt, (e, t) => { const n = e.definition(); t.print_name(n ? n.mangled_name || n.name : e.name); }), e(Bt, h), e(wt, (e, t) => { t.print('this'); }), e(kt, (e, t) => { t.print(e.getValue()); }), e(Et, (e, t) => { t.print_string(e.getValue(), e.quote, v); }), e(At, (e, t) => { g && e.start && e.start.raw != null ? t.print(e.start.raw) : t.print(p(e.getValue())); }), e(Ct, (e, t) => { let n = e.getValue().toString(); t.option('ascii_only') ? n = t.to_ascii(n) : t.option('unescape_regexps') && (n = n.split('\\\\').map(e => e.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g, (e) => { const t = parseInt(e.substr(2), 16); return a(t) ? String.fromCharCode(t) : e; })).join('\\\\')), t.print(n); const r = t.parent(); r instanceof tt && /^in/.test(r.operator) && r.left === e && t.print(' '); }), d(ie, h), d(ae, m), d(se, m), d(lt, m), d(Se, m), d(he, m), d(fe, h), d(ke, m), d(Me, m), d(Re, m), d(le, m), d(we, h), d(Ge, m), d(je, m), d(Ve, m), d(ze, m), d(Ue, m), d(kt, m), d(ut, (e, t) => { t.add_mapping(e.start, e.key.name); }), d(ct, (e, t) => { t.add_mapping(e.start, e.key.name); }), d(st, (e, t) => { t.add_mapping(e.start, e.key); }); }()), X.prototype = new H(), p(X.prototype, {
        option(e) { return this.options[e]; }, compress(e) { this.option('expression') && (e = e.process_expression(!0)); for (let t = +this.options.passes || 1, n = 0; n < t && n < 3; ++n)(n > 0 || this.option('reduce_vars')) && e.reset_opt_flags(this, !0), e = e.transform(this); return this.option('expression') && (e = e.process_expression(!1)), e; }, info() { this.options.warnings == 'verbose' && ie.warn(...arguments); }, warn(e, t) { if (this.options.warnings) { const n = y(e, t); n in this.warnings_produced || (this.warnings_produced[n] = !0, ie.warn(...arguments)); } }, clear_warnings() { this.warnings_produced = {}; }, before(e, t, n) { if (e._squeezed) return e; let r = !1; e instanceof xe && (e = e.hoist_declarations(this), r = !0), t(e, this), t(e, this); const i = e.optimize(this); return r && i instanceof xe && (i.drop_unused(this), t(i, this)), i === e && (i._squeezed = !0), i; },
      }), (function () {
        function e(e, t) { e.DEFMETHOD('optimize', function (e) { const n = this; if (n._optimized) return n; if (e.has_directive('use asm')) return n; const r = t(n, e); return r._optimized = !0, r; }); } function t(e) { if (!(e instanceof _t)) return !1; for (let t = e.definition().orig, n = t.length; --n >= 0;) if (t[n] instanceof dt) return !0; } function n(e, t) { for (var n, r = 0; (n = e.parent(r++)) && !(n instanceof xe);) if (n instanceof Ve) { n = n.argname.definition().scope; break; } return n.find_variable(t); } function r(e, t, n) { return n || (n = {}), t && (n.start || (n.start = t.start), n.end || (n.end = t.end)), new e(n); } function i(e, t) { switch (typeof e) { case 'string': return r(Et, t, { value: e }); case 'number': return isNaN(e) ? r(Ot, t) : isFinite(e) ? 1 / e < 0 ? r(Ze, t, { operator: '-', expression: r(At, t, { value: -e }) }) : r(At, t, { value: e }) : e < 0 ? r(Ze, t, { operator: '-', expression: r(Dt, t) }) : r(Dt, t); case 'boolean': return r(e ? Mt : Nt, t); case 'undefined': return r(Ft, t); default: if (e === null) return r(Tt, t, { value: null }); if (e instanceof RegExp) return r(Ct, t, { value: e }); throw new Error(y("Can't handle constant of type: {type}", { type: typeof e })); } } function a(e, t, n) { return e instanceof Ze && e.operator == 'delete' || e instanceof We && e.expression === t && (n instanceof Xe || n instanceof _t && n.name == 'eval') ? r(Ye, t, { car: r(At, t, { value: 0 }), cdr: n }) : n; } function u(e) { if (e === null) return []; if (e instanceof le) return e.body; if (e instanceof pe) return []; if (e instanceof oe) return [e]; throw new Error("Can't convert thing to statement array"); } function c(e) { return e === null || (e instanceof pe || e instanceof le && e.body.length == 0); } function l(e) { return e instanceof Me ? e : (e instanceof ye || e instanceof be || e instanceof me) && e.body instanceof le ? e.body : e; } function p(e) { return e instanceof We && !(e instanceof Ge) && (e.expression instanceof Ae || p(e.expression)); } function v(e, t) { function n(e, t) { function i(e, t) { return e instanceof _t && B(e, t); } function o(n, o, l) { if (i(n, o)) return n; const p = a(o, n, x.value); return x.value = null, m.splice(_, 1), m.length === 0 && (e[f] = r(pe, s), u = !0), h.reset_opt_flags(t), t.info(`Collapsing ${l ? 'constant' : 'variable'} ${w} [{file}:{line},{col}]`, n.start), c = !0, p; } for (var s = t.self(), u = !1, l = t.option('toplevel'), p = e.length; --p >= 0;) { var h = e[p]; if (!(h instanceof Ue)) { if ([h, h.body, h.alternative, h.bcatch, h.bfinally].forEach((e) => { e && e.body && n(e.body, t); }), p <= 0) break; var f = p - 1; const d = e[f]; if (d instanceof Ue) { var m = d.definitions; if (m != null) for (var g = {}, v = !1, y = !1, b = {}, _ = m.length; --_ >= 0;) { var x = m[_]; if (x.value == null) break; var w = x.name.name; if (!w || !w.length) break; if (w in g) break; g[w] = !0; const k = s.find_variable && s.find_variable(w); if (k && k.references && k.references.length === 1 && w != 'arguments' && (l || !k.global)) { var E = k.references[0]; if (E.scope.uses_eval || E.scope.uses_with) break; if (x.value.is_constant()) { var A = new H(((e) => { const t = A.parent(); return t instanceof de && (t.condition === e || t.init === e) ? e : e === E ? o(e, t, !0) : void 0; })); h.transform(A); } else if (!(v |= y)) { var C = x.value.has_side_effects(t); if (E.scope === s) { var S = new T(((e) => { e instanceof _t && i(e, S.parent()) && (b[e.name] = y = !0); })); x.value.walk(S); var O = !1; var F = new H(((e) => { if (O) return e; const t = F.parent(); return e instanceof ke || e instanceof je || e instanceof _e || e instanceof Ie || e instanceof de || t instanceof Ne && e !== t.condition || t instanceof nt && e !== t.condition || e instanceof _t && C && !(function (e, t) { if (e.orig.length === 1 && e.orig[0] instanceof gt) return !0; if (e.scope !== t) return !1; for (let n = e.references, r = 0, i = n.length; r < i; r++) if (n[r].scope !== t) return !1; return !0; }(e.definition(), s)) || t instanceof tt && (t.operator == '&&' || t.operator == '||') && e === t.right || t instanceof Me && e !== t.expression ? (v = O = !0, e) : void 0; }), (e => (O ? e : e === E ? (O = !0, o(e, F.parent(), !1)) : (v |= e.has_side_effects(t)) ? (O = !0, e) : y && e instanceof _t && e.name in b ? (v = !0, O = !0, e) : void 0))); h.transform(F); } else v |= C; } } else v = !0; } } } } if (u) for (let D = e.length; --D >= 0;)e.length > 1 && e[D] instanceof pe && e.splice(D, 1); return e; } function i(e) { const t = []; return e.reduce((e, n) => (n instanceof le ? (c = !0, e.push(...i(n.body))) : n instanceof pe ? c = !0 : n instanceof ae ? t.indexOf(n.value) < 0 ? (e.push(n), t.push(n.value)) : c = !0 : e.push(n)), e, []); } function o(e) { for (var t = 0, n = 0; n < e.length; ++n) { const r = e[n]; r instanceof Ye ? t += r.len() : t++; } return t; } function s(e, t) { function n(e) { i.pop(); let n = o.body; return n instanceof Ye ? n.add(e) : n = Ye.cons(n, e), n.transform(t); } var i = []; var o = null; return e.forEach((e) => { if (o) if (e instanceof ye) { const s = {}; try { o.body.walk(new T(((e) => { if (e instanceof tt && e.operator == 'in') throw s; }))), !e.init || e.init instanceof Ue ? e.init || (e.init = o.body.drop_side_effect_free(t), i.pop()) : e.init = n(e.init); } catch (e) { if (e !== s) throw e; } } else e instanceof Ne ? e.condition = n(e.condition) : e instanceof _e ? e.expression = n(e.expression) : e instanceof Te && e.value ? e.value = n(e.value) : e instanceof Te ? e.value = n(r(Ft, e).transform(t)) : e instanceof Me && (e.expression = n(e.expression)); i.push(e), o = e instanceof ue ? e : null; }), i; } let c; let p = 10; do { c = !1, t.option('angular') && (e = (function (e) { function n(e) { return /@ngInject/.test(e.value); } function i(e) { return e.argnames.map(e => r(Et, e, { value: e.name })); } function o(e, t) { return r(it, e, { elements: t }); } function s(e, t) { return r(ue, e, { body: r(rt, e, { operator: '=', left: r(Ke, t, { expression: r(_t, t, t), property: '$inject' }), right: o(e, i(e)) }) }); } function a(e) { e && e.args && (e.args.forEach((e, t, r) => { const s = e.start.comments_before; e instanceof ke && s.length && n(s[0]) && (r[t] = o(e, i(e).concat(e))); }), e.expression && e.expression.expression && a(e.expression.expression)); } return e.reduce((e, r) => { if (e.push(r), r.body && r.body.args)a(r.body); else { const i = r.start; const o = i.comments_before; o && o.length > 0 && n(o.pop()) && (r instanceof Ce ? e.push(s(r, r.name)) : r instanceof Ue ? r.definitions.forEach((t) => { t.value && t.value instanceof ke && e.push(s(t.value, t.name)); }) : t.warn('Unknown statement marked with @ngInject [{file}:{line},{col}]', i)); } return e; }, []); }(e))), e = i(e), t.option('dead_code') && (e = (function (e, t) { let n = !1; const r = e.length; const i = t.self(); return e = e.reduce((e, r) => { if (n)O(t, r, e); else { if (r instanceof Be) { const o = t.loopcontrol_target(r); r instanceof De && !(o instanceof de) && l(o) === i || r instanceof Le && l(o) === i ? r.label && b(r.label.thedef.references, r) : e.push(r); } else e.push(r); M(r) && (n = !0); } return e; }, []), c = e.length != r, e; }(e, t))), t.option('if_return') && (e = (function (e, t) { const n = t.self(); const i = (function (e) { for (let t = 0, n = e.length; --n >= 0;) { const r = e[n]; if (r instanceof Ne && r.body instanceof Oe && ++t > 1) return !0; } return !1; }(e)); const o = n instanceof ke; let s = []; e:for (let a = e.length; --a >= 0;) { let p = e[a]; switch (!0) { case o && p instanceof Oe && !p.value && s.length == 0: c = !0; continue e; case p instanceof Ne: if (p.body instanceof Oe) { if ((o && s.length == 0 || s[0] instanceof Oe && !s[0].value) && !p.body.value && !p.alternative) { c = !0; const h = r(ue, p.condition, { body: p.condition }); s.unshift(h); continue e; } if (s[0] instanceof Oe && p.body.value && s[0].value && !p.alternative) { c = !0, (p = p.clone()).alternative = s[0], s[0] = p.transform(t); continue e; } if (i && (s.length == 0 || s[0] instanceof Oe) && p.body.value && !p.alternative && o) { c = !0, (p = p.clone()).alternative = s[0] || r(Oe, p, { value: null }), s[0] = p.transform(t); continue e; } if (!p.body.value && o) { c = !0, (p = p.clone()).condition = p.condition.negate(t); const f = C(g = u(p.alternative).concat(s)); p.body = r(le, p, { body: g }), p.alternative = null, s = f.concat([p.transform(t)]); continue e; } if (t.option('sequences') && a > 0 && e[a - 1] instanceof Ne && e[a - 1].body instanceof Oe && s.length == 1 && o && s[0] instanceof ue && !p.alternative) { c = !0, s.push(r(Oe, s[0], { value: null }).transform(t)), s.unshift(p); continue e; } } var d = M(p.body); var m = d instanceof Be ? t.loopcontrol_target(d) : null; if (d && (d instanceof Oe && !d.value && o || d instanceof Le && n === l(m) || d instanceof De && m instanceof le && n === m)) { d.label && b(d.label.thedef.references, d), c = !0; var g = u(p.body).slice(0, -1); (p = p.clone()).condition = p.condition.negate(t), p.body = r(le, p, { body: u(p.alternative).concat(s) }), p.alternative = r(le, p, { body: g }), s = [p.transform(t)]; continue e; } if (m = (d = M(p.alternative)) instanceof Be ? t.loopcontrol_target(d) : null, d && (d instanceof Oe && !d.value && o || d instanceof Le && n === l(m) || d instanceof De && m instanceof le && n === m)) { d.label && b(d.label.thedef.references, d), c = !0, (p = p.clone()).body = r(le, p.body, { body: u(p.body).concat(s) }), p.alternative = r(le, p.alternative, { body: u(p.alternative).slice(0, -1) }), s = [p.transform(t)]; continue e; }s.unshift(p); break; default: s.unshift(p); } } return s; }(e, t))), t.sequences_limit > 0 && (e = (function (e, t) { function n() { (i = Ye.from_array(i)) && a.push(r(ue, i, { body: i })), i = []; } if (e.length < 2) return e; var i = []; var a = []; return e.forEach((e) => { if (e instanceof ue) { o(i) >= t.sequences_limit && n(); let r = e.body; i.length > 0 && (r = r.drop_side_effect_free(t)), r && i.push(r); } else n(), a.push(e); }), n(), a = s(a, t), c = a.length != e.length, a; }(e, t))), t.option('join_vars') && (e = (function (e, t) { let n = null; return e.reduce((e, t) => (t instanceof Ue && n && n.TYPE == t.TYPE ? (n.definitions = n.definitions.concat(t.definitions), c = !0) : t instanceof ye && n instanceof $e && (!t.init || t.init.TYPE == n.TYPE) ? (c = !0, e.pop(), t.init ? t.init.definitions = n.definitions.concat(t.init.definitions) : t.init = n, e.push(t), n = t) : (n = t, e.push(t))), e, []); }(e))), t.option('collapse_vars') && (e = n(e, t)); } while (c && p-- > 0);return e; } function C(e) { for (var t = [], n = e.length - 1; n >= 0; --n) { const r = e[n]; r instanceof Ce && (e.splice(n, 1), t.unshift(r)); } return t; } function O(e, t, n) { t instanceof Ce || e.warn('Dropping unreachable code [{file}:{line},{col}]', t.start), t.walk(new T((t => (t instanceof Ue ? (e.warn('Declarations in unreachable code! [{file}:{line},{col}]', t.start), t.remove_initializers(), n.push(t), !0) : t instanceof Ce ? (n.push(t), !0) : t instanceof xe || void 0)))); } function F(e, t) { return e.is_undefined || e instanceof Ft || e instanceof Ze && e.operator == 'void' && !e.expression.has_side_effects(t); } function B(e, t) { return t instanceof Qe && z(t.operator) ? t.expression : t instanceof rt && t.left === e ? e : void 0; } function D(e, t) { return e.print_to_string().length > t.print_to_string().length ? t : e; } function L(e, t) { return D(r(ue, e, { body: e }), r(ue, t, { body: t })).body; } function N(e, t, n) { return (A(e) ? L : D)(t, n); } function M(e) { return e && e.aborts(); } function R(e, t) { function n(n) { n = u(n), e.body instanceof le ? (e.body = e.body.clone(), e.body.body = n.concat(e.body.body.slice(1)), e.body = e.body.transform(t)) : e.body = r(le, e.body, { body: n }).transform(t), R(e, t); } const i = e.body instanceof le ? e.body.body[0] : e.body; i instanceof Ne && (i.body instanceof De && t.loopcontrol_target(i.body) === t.self() ? (e.condition ? e.condition = r(tt, e.condition, { left: e.condition, operator: '&&', right: i.condition.negate(t) }) : e.condition = i.condition.negate(t), n(i.alternative)) : i.alternative instanceof De && t.loopcontrol_target(i.alternative) === t.self() && (e.condition ? e.condition = r(tt, e.condition, { left: e.condition, operator: '&&', right: i.condition }) : e.condition = i.condition, n(i.body))); } function P(e, t) { return e instanceof _t || e.TYPE === t.TYPE; } function j(e, t) { return t.option('booleans') && t.in_boolean_context() ? N(t, e, r(Ye, e, { car: e, cdr: r(Mt, e) }).optimize(t)) : e; }e(ie, (e, t) => e), ie.DEFMETHOD('equivalent_to', function (e) { return this.TYPE == e.TYPE && this.print_to_string() == e.print_to_string(); }), ie.DEFMETHOD('process_expression', function (e, t) { const n = this; var i = new H(((o) => { if (e && o instanceof ue) return r(Oe, o, { value: o.body }); if (!e && o instanceof Oe) { if (t) { const s = o.value && o.value.drop_side_effect_free(t, !0); return s ? r(ue, o, { body: s }) : r(pe, o); } return r(ue, o, { body: o.value || r(Ze, o, { operator: 'void', expression: r(At, o, { value: 0 }) }) }); } if (o instanceof ke && o !== n) return o; if (o instanceof ce) { const a = o.body.length - 1; a >= 0 && (o.body[a] = o.body[a].transform(i)); } return o instanceof Ne && (o.body = o.body.transform(i), o.alternative && (o.alternative = o.alternative.transform(i))), o instanceof _e && (o.body = o.body.transform(i)), o; })); return n.transform(i); }), ie.DEFMETHOD('reset_opt_flags', function (e, t) { function n(e, t) { p[e.id] = t; } function i(e) { if (p[e.id]) { if (e.fixed == null) { const t = e.orig[0]; if (t instanceof mt || t.name == 'arguments') return !1; e.fixed = r(Ft, t); } return !0; } } function o() { p = Object.create(p); } function s() { p = Object.getPrototypeOf(p); } function a(e) { e.escaped = !1, e.scope.uses_eval ? e.fixed = !1 : l || !e.global || e.orig[0] instanceof dt ? e.fixed = void 0 : e.fixed = !1, e.references = [], e.should_replace = void 0; } function u(e, t, n) { const r = f.parent(t); return !!(B(e, r) || !n && r instanceof We && r.expression === e) || (r instanceof Xe && r.expression === e ? !n && u(r, t + 1) : void 0); } const c = t && e.option('reduce_vars'); var l = e.option('toplevel'); var p = Object.create(null); const h = new T(((e) => { if (e instanceof lt) { const t = e.definition(); e instanceof _t && t.references.push(e), t.fixed = !1; } })); var f = new T(((e, t) => { if (e._squeezed = !1, e._optimized = !1, c) { if (e instanceof we && e.globals.each(a), e instanceof xe && e.variables.each(a), e instanceof _t) if ((m = e.definition()).references.push(e), void 0 === m.fixed || !i(m) || u(e, 0, e.fixed_value() instanceof ke))m.fixed = !1; else { const d = f.parent(); (d instanceof rt && d.operator == '=' && e === d.right || d instanceof We && e !== d.expression || d instanceof Oe && e === d.value && e.scope !== m.scope || d instanceof He && e === d.value) && (m.escaped = !0); } if (e instanceof yt && (e.definition().fixed = !1), e instanceof He) { if ((m = e.name.definition()).fixed == null) return e.value ? (m.fixed = function () { return e.value; }, n(m, !1), t()) : m.fixed = null, n(m, !0), !0; e.value && (m.fixed = !1); } if (e instanceof Ce) { var m = e.name.definition(); !l && m.global || i(m) ? m.fixed = !1 : (m.fixed = e, n(m, !0)); v = p; return p = Object.create(null), t(), p = v, !0; } if (e instanceof Ae) { o(); let g; return !e.name && (g = f.parent()) instanceof We && g.expression === e && e.argnames.forEach((t, i) => { const o = t.definition(); e.uses_arguments || void 0 !== o.fixed ? o.fixed = !1 : (o.fixed = function () { return g.args[i] || r(Ft, g); }, n(o, !0)); }), t(), s(), !0; } if (e instanceof Ee) { var v = p; return p = Object.create(null), t(), p = v, !0; } if (e instanceof tt && (e.operator == '&&' || e.operator == '||')) return e.left.walk(f), o(), e.right.walk(f), s(), !0; if (e instanceof nt) return e.condition.walk(f), o(), e.consequent.walk(f), s(), o(), e.alternative.walk(f), s(), !0; if (e instanceof Ne || e instanceof me) return e.condition.walk(f), o(), e.body.walk(f), s(), e.alternative && (o(), e.alternative.walk(f), s()), !0; if (e instanceof fe) return o(), e.body.walk(f), s(), !0; if (e instanceof ye) return e.init && e.init.walk(f), o(), e.condition && e.condition.walk(f), e.body.walk(f), e.step && e.step.walk(f), s(), !0; if (e instanceof be) return e.init.walk(h), e.object.walk(f), o(), e.body.walk(f), s(), !0; if (e instanceof je) return o(), S(e, f), s(), e.bcatch && (o(), e.bcatch.walk(f), s()), e.bfinally && e.bfinally.walk(f), !0; if (e instanceof Re) return o(), t(), s(), !0; } })); this.walk(f); }), _t.DEFMETHOD('fixed_value', function () { const e = this.definition().fixed; return !e || e instanceof ie ? e : e(); }), (function (e) { function t(e) { return /strict/.test(e); }ie.DEFMETHOD('may_throw_on_access', function (e) { const t = e.option('pure_getters'); return !t || this._throw_on_access(t); }), e(ie, t), e(Tt, d), e(Ft, d), e(kt, f), e(it, f), e(ot, function (e) { if (!t(e)) return !1; for (let n = this.properties.length; --n >= 0;) if (this.properties[n].value instanceof Ee) return !0; return !1; }), e(Ae, f), e(et, f), e(Ze, function () { return this.operator == 'void'; }), e(tt, function (e) { switch (this.operator) { case '&&': return this.left._throw_on_access(e); case '||': return this.left._throw_on_access(e) && this.right._throw_on_access(e); default: return !1; } }), e(rt, function (e) { return this.operator == '=' && this.right._throw_on_access(e); }), e(nt, function (e) { return this.consequent._throw_on_access(e) || this.alternative._throw_on_access(e); }), e(Ye, function (e) { return this.cdr._throw_on_access(e); }), e(_t, function (e) { if (this.is_undefined) return !0; if (!t(e)) return !1; const n = this.fixed_value(); return !n || n._throw_on_access(e); }); }((e, t) => { e.DEFMETHOD('_throw_on_access', t); })), (function (e) { const t = ['!', 'delete']; const n = ['in', 'instanceof', '==', '!=', '===', '!==', '<', '<=', '>=', '>']; e(ie, f), e(Ze, function () { return o(this.operator, t); }), e(tt, function () { return o(this.operator, n) || (this.operator == '&&' || this.operator == '||') && this.left.is_boolean() && this.right.is_boolean(); }), e(nt, function () { return this.consequent.is_boolean() && this.alternative.is_boolean(); }), e(rt, function () { return this.operator == '=' && this.right.is_boolean(); }), e(Ye, function () { return this.cdr.is_boolean(); }), e(Mt, d), e(Nt, d); }((e, t) => { e.DEFMETHOD('is_boolean', t); })), (function (e) { e(ie, f), e(At, d); const t = x('+ - ~ ++ --'); e(Qe, function () { return t(this.operator); }); const n = x('- * / % & | ^ << >> >>>'); e(tt, function (e) { return n(this.operator) || this.operator == '+' && this.left.is_number(e) && this.right.is_number(e); }), e(rt, function (e) { return n(this.operator.slice(0, -1)) || this.operator == '=' && this.right.is_number(e); }), e(Ye, function (e) { return this.cdr.is_number(e); }), e(nt, function (e) { return this.consequent.is_number(e) && this.alternative.is_number(e); }); }((e, t) => { e.DEFMETHOD('is_number', t); })), (function (e) { e(ie, f), e(Et, d), e(Ze, function () { return this.operator == 'typeof'; }), e(tt, function (e) { return this.operator == '+' && (this.left.is_string(e) || this.right.is_string(e)); }), e(rt, function (e) { return (this.operator == '=' || this.operator == '+=') && this.right.is_string(e); }), e(Ye, function (e) { return this.cdr.is_string(e); }), e(nt, function (e) { return this.consequent.is_string(e) && this.alternative.is_string(e); }); }((e, t) => { e.DEFMETHOD('is_string', t); })); var z = x('delete ++ --'); !(function (e) { function t(e, n) { if (e instanceof ie) return r(e.CTOR, n, e); if (Array.isArray(e)) return r(it, n, { elements: e.map(e => t(e, n)) }); if (e && typeof e === 'object') { const o = []; for (const s in e)o.push(r(at, n, { key: s, value: t(e[s], n) })); return r(ot, n, { properties: o }); } return i(e, n); }ie.DEFMETHOD('resolve_defines', function (e) { if (e.option('global_defs')) { const t = this._find_defs(e, ''); if (t) { let n; let r = this; let i = 0; do { n = r, r = e.parent(i++); } while (r instanceof Xe && r.expression === n);if (!B(n, r)) return t; e.warn(`global_defs ${this.print_to_string()} redefined [{file}:{line},{col}]`, this.start); } } }), e(ie, h), e(Ke, function (e, t) { return this.expression._find_defs(e, `.${this.property}${t}`); }), e(_t, function (e, n) { if (this.global()) { let r; const i = e.option('global_defs'); if (i && E(i, r = this.name + n)) { const o = t(i[r], this); const s = e.find_parent(we); return o.walk(new T(((e) => { e instanceof _t && (e.scope = s, e.thedef = s.def_global(e)); }))), o; } } }); }((e, t) => { e.DEFMETHOD('_find_defs', t); })), (function (e) { function t(e, t) { if (!t) throw new Error('Compressor must be passed'); return e._eval(t); }ie.DEFMETHOD('evaluate', function (t) { if (!t.option('evaluate')) return this; try { const n = this._eval(t); return !n || n instanceof RegExp || typeof n !== 'object' ? n : this; } catch (t) { if (t !== e) throw t; return this; } }); const n = x('! ~ - + void'); ie.DEFMETHOD('is_constant', function () { return this instanceof kt ? !(this instanceof Ct) : this instanceof Ze && this.expression instanceof kt && n(this.operator); }), ie.DEFMETHOD('constant_value', function (e) { if (this instanceof kt && !(this instanceof Ct)) return this.value; if (this instanceof Ze && this.expression instanceof kt) switch (this.operator) { case '!': return !this.expression.value; case '~': return ~this.expression.value; case '-': return -this.expression.value; case '+': return +this.expression.value; default: throw new Error(y('Cannot evaluate unary expression {value}', { value: this.print_to_string() })); } const t = this.evaluate(e); if (t !== this) return t; throw new Error(y('Cannot evaluate constant [{file}:{line},{col}]', this.start)); }), e(oe, function () { throw new Error(y('Cannot evaluate a statement [{file}:{line},{col}]', this.start)); }), e(ke, () => { throw e; }), e(ie, () => { throw e; }), e(kt, function () { return this.getValue(); }), e(it, function (n) { if (n.option('unsafe')) return this.elements.map(e => t(e, n)); throw e; }), e(ot, function (n) { if (n.option('unsafe')) { for (var r = {}, i = 0, o = this.properties.length; i < o; i++) { const s = this.properties[i]; let a = s.key; if (a instanceof lt ? a = a.name : a instanceof ie && (a = t(a, n)), typeof Object.prototype[a] === 'function') throw e; r[a] = t(s.value, n); } return r; } throw e; }), e(Ze, function (n) { let r = this.expression; switch (this.operator) { case '!': return !t(r, n); case 'typeof': if (r instanceof Ae) return 'function'; if ((r = t(r, n)) instanceof RegExp) throw e; return typeof r; case 'void': return void t(r, n); case '~': return ~t(r, n); case '-': return -t(r, n); case '+': return +t(r, n); } throw e; }), e(tt, function (n) { let r; const i = this.left; const o = this.right; switch (this.operator) { case '&&': r = t(i, n) && t(o, n); break; case '||': r = t(i, n) || t(o, n); break; case '|': r = t(i, n) | t(o, n); break; case '&': r = t(i, n) & t(o, n); break; case '^': r = t(i, n) ^ t(o, n); break; case '+': r = t(i, n) + t(o, n); break; case '*': r = t(i, n) * t(o, n); break; case '/': r = t(i, n) / t(o, n); break; case '%': r = t(i, n) % t(o, n); break; case '-': r = t(i, n) - t(o, n); break; case '<<': r = t(i, n) << t(o, n); break; case '>>': r = t(i, n) >> t(o, n); break; case '>>>': r = t(i, n) >>> t(o, n); break; case '==': r = t(i, n) == t(o, n); break; case '===': r = t(i, n) === t(o, n); break; case '!=': r = t(i, n) != t(o, n); break; case '!==': r = t(i, n) !== t(o, n); break; case '<': r = t(i, n) < t(o, n); break; case '<=': r = t(i, n) <= t(o, n); break; case '>': r = t(i, n) > t(o, n); break; case '>=': r = t(i, n) >= t(o, n); break; default: throw e; } if (isNaN(r) && n.find_parent(_e)) throw e; return r; }), e(nt, function (e) { return t(this.condition, e) ? t(this.consequent, e) : t(this.alternative, e); }), e(_t, function (n) { if (!n.option('reduce_vars') || this._evaluating) throw e; this._evaluating = !0; try { const r = this.fixed_value(); if (!r) throw e; const i = t(r, n); if (E(r, '_eval') || (r._eval = function () { return i; }), i && typeof i === 'object' && this.definition().escaped) throw e; return i; } finally { this._evaluating = !1; } }), e(Xe, function (n) { if (n.option('unsafe')) { let r = this.property; r instanceof ie && (r = t(r, n)); const i = t(this.expression, n); if (i && E(i, r)) return i[r]; } throw e; }); }((e, t) => { e.DEFMETHOD('_eval', t); })), (function (e) { function t(e) { return r(Ze, e, { operator: '!', expression: e }); } function n(e, n, i) { const o = t(e); if (i) { const s = r(ue, n, { body: n }); return D(o, s) === s ? n : o; } return D(o, n); }e(ie, function () { return t(this); }), e(oe, () => { throw new Error('Cannot negate a statement'); }), e(Ae, function () { return t(this); }), e(Ze, function () { return this.operator == '!' ? this.expression : t(this); }), e(Ye, function (e) { const t = this.clone(); return t.cdr = t.cdr.negate(e), t; }), e(nt, function (e, t) { const r = this.clone(); return r.consequent = r.consequent.negate(e), r.alternative = r.alternative.negate(e), n(this, r, t); }), e(tt, function (e, r) { const i = this.clone(); const o = this.operator; if (e.option('unsafe_comps')) switch (o) { case '<=': return i.operator = '>', i; case '<': return i.operator = '>=', i; case '>=': return i.operator = '<', i; case '>': return i.operator = '<=', i; } switch (o) { case '==': return i.operator = '!=', i; case '!=': return i.operator = '==', i; case '===': return i.operator = '!==', i; case '!==': return i.operator = '===', i; case '&&': return i.operator = '||', i.left = i.left.negate(e, r), i.right = i.right.negate(e), n(this, i, r); case '||': return i.operator = '&&', i.left = i.left.negate(e, r), i.right = i.right.negate(e), n(this, i, r); } return t(this); }); }((e, t) => { e.DEFMETHOD('negate', function (e, n) { return t.call(this, e, n); }); })), We.DEFMETHOD('has_pure_annotation', function (e) { if (!e.option('side_effects')) return !1; if (void 0 !== this.pure) return this.pure; let t; let n; let r = !1; return this.start && (t = this.start.comments_before) && t.length && /[@#]__PURE__/.test((n = t[t.length - 1]).value) && (r = n), this.pure = r; }), (function (e) { function t(e, t) { for (let n = e.length; --n >= 0;) if (e[n].has_side_effects(t)) return !0; return !1; }e(ie, d), e(pe, f), e(kt, f), e(wt, f), e(We, function (e) { if (!this.has_pure_annotation(e) && e.pure_funcs(this)) return !0; for (let t = this.args.length; --t >= 0;) if (this.args[t].has_side_effects(e)) return !0; return !1; }), e(ce, function (e) { return t(this.body, e); }), e(Me, function (e) { return this.expression.has_side_effects(e) || t(this.body, e); }), e(Ie, function (e) { return this.expression.has_side_effects(e) || t(this.body, e); }), e(je, function (e) { return t(this.body, e) || this.bcatch && this.bcatch.has_side_effects(e) || this.bfinally && this.bfinally.has_side_effects(e); }), e(Ne, function (e) { return this.condition.has_side_effects(e) || this.body && this.body.has_side_effects(e) || this.alternative && this.alternative.has_side_effects(e); }), e(fe, function (e) { return this.body.has_side_effects(e); }), e(ue, function (e) { return this.body.has_side_effects(e); }), e(Ce, d), e(Ae, f), e(tt, function (e) { return this.left.has_side_effects(e) || this.right.has_side_effects(e); }), e(rt, d), e(nt, function (e) { return this.condition.has_side_effects(e) || this.consequent.has_side_effects(e) || this.alternative.has_side_effects(e); }), e(Qe, function (e) { return z(this.operator) || this.expression.has_side_effects(e); }), e(_t, function (e) { return this.undeclared(); }), e(ot, function (e) { return t(this.properties, e); }), e(st, function (e) { return this.value.has_side_effects(e); }), e(it, function (e) { return t(this.elements, e); }), e(Ke, function (e) { return this.expression.may_throw_on_access(e) || this.expression.has_side_effects(e); }), e(Je, function (e) { return this.expression.may_throw_on_access(e) || this.expression.has_side_effects(e) || this.property.has_side_effects(e); }), e(Ye, function (e) { return this.car.has_side_effects(e) || this.cdr.has_side_effects(e); }); }((e, t) => { e.DEFMETHOD('has_side_effects', t); })), (function (e) { function t() { const e = this.body.length; return e > 0 && M(this.body[e - 1]); }e(oe, g), e(Se, m), e(le, t), e(Re, t), e(Ne, function () { return this.alternative && M(this.body) && M(this.alternative) && this; }); }((e, t) => { e.DEFMETHOD('aborts', t); })), e(ae, (e, t) => (t.has_directive(e.value) !== e ? r(pe, e) : e)), e(se, (e, t) => (t.option('drop_debugger') ? r(pe, e) : e)), e(fe, (e, t) => (e.body instanceof De && t.loopcontrol_target(e.body) === e.body ? r(pe, e) : e.label.references.length == 0 ? e.body : e)), e(ce, (e, t) => e.body = v(e.body, t), e), e(le, (e, t) => { switch (e.body = v(e.body, t), e.body.length) { case 1: return e.body[0]; case 0: return r(pe, e); } return e; }), xe.DEFMETHOD('drop_unused', function (e) {
          const n = this; if (e.has_directive('use asm')) return n; const i = e.option('toplevel'); if (e.option('unused') && (!(n instanceof we) || i) && !n.uses_eval && !n.uses_with) {
            const o = !/keep_assign/.test(e.option('unused')); let s = /funcs/.test(i); let u = /vars/.test(i); n instanceof we && i != 1 || (s = u = !0); const l = []; const p = Object.create(null); n instanceof we && e.top_retain && n.variables.each((t) => { !e.top_retain(t) || t.id in p || (p[t.id] = !0, l.push(t)); }); const h = new k();


            let f = this;


            var d = new T(((r, i) => { if (r !== n) { if (r instanceof Ce) return s || f !== n || (a = r.name.definition()).id in p || (p[a.id] = !0, l.push(a)), h.add(r.name.name, r), !0; if (r instanceof Ue && f === n) return r.definitions.forEach((t) => { if (!u) { const n = t.name.definition(); n.id in p || (p[n.id] = !0, l.push(n)); }t.value && (h.add(t.name.name, t.value), t.value.has_side_effects(e) && t.value.walk(d)); }), !0; if (o && r instanceof rt && r.operator == '=' && r.left instanceof _t && !t(r.left) && f === n) return r.right.walk(d), !0; if (r instanceof _t) { var a = r.definition(); return a.id in p || (p[a.id] = !0, l.push(a)), !0; } if (r instanceof xe) { const c = f; return f = r, i(), f = c, !0; } } })); n.walk(d); for (let m = 0; m < l.length; ++m)l[m].orig.forEach((e) => { const t = h.get(e.name); t && t.forEach((e) => { const t = new T(((e) => { if (e instanceof _t) { const t = e.definition(); t.id in p || (p[t.id] = !0, l.push(t)); } })); e.walk(t); }); }); var g = new H(function (t, i, l) {
              if (t instanceof Ae && t.name && !e.option('keep_fnames') && ((b = t.name.definition()).id in p && !(b.orig.length > 1) || (t.name = null)), t instanceof ke && !(t instanceof Ee)) {
                for (var h = !e.option('keep_fargs'), f = t.argnames, d = f.length; --d >= 0;) {
                  const m = f[d]; m.definition().id in p ? h = !1 : (m.__unused = !0, h && (f.pop(), e[m.unreferenced() ? 'warn' : 'info']('Dropping unused function argument {name} [{file}:{line},{col}]', {
                    name: m.name, file: m.start.file, line: m.start.line, col: m.start.col,
                  })));
                }
              } if (s && t instanceof Ce && t !== n) {
                return t.name.definition().id in p ? t : (e[t.name.unreferenced() ? 'warn' : 'info']('Dropping unused function {name} [{file}:{line},{col}]', {
                  name: t.name.name, file: t.name.start.file, line: t.name.start.line, col: t.name.start.col,
                }), r(pe, t));
              } if (u && t instanceof Ue && !(g.parent() instanceof be && g.parent().init === t)) {
                b = _(b = t.definitions.filter((t) => {
                  t.value && (t.value = t.value.transform(g)); const n = t.name.definition(); if (n.id in p) return !0; if (n.orig[0] instanceof yt) return t.value = t.value && t.value.drop_side_effect_free(e), !0; const r = {
                    name: t.name.name, file: t.name.start.file, line: t.name.start.line, col: t.name.start.col,
                  }; return t.value && (t._unused_side_effects = t.value.drop_side_effect_free(e)) ? (e.warn('Side effects in initialization of unused variable {name} [{file}:{line},{col}]', r), !0) : (e[t.name.unreferenced() ? 'warn' : 'info']('Dropping unused variable {name} [{file}:{line},{col}]', r), !1);
                }), (e, t) => (!e.value && t.value ? -1 : !t.value && e.value ? 1 : 0)); for (var v = [], d = 0; d < b.length;) { const y = b[d]; y._unused_side_effects ? (v.push(y._unused_side_effects), b.splice(d, 1)) : (v.length > 0 && (v.push(y.value), y.value = Ye.from_array(v), v = []), ++d); } return v = v.length > 0 ? r(le, t, { body: [r(ue, t, { body: Ye.from_array(v) })] }) : null, b.length != 0 || v ? b.length == 0 ? l ? ne.splice(v.body) : v : (t.definitions = b, v ? (v.body.unshift(t), l ? ne.splice(v.body) : v) : t) : r(pe, t);
              } if (u && o && t instanceof rt && t.operator == '=' && t.left instanceof _t) { var b = t.left.definition(); if (!(b.id in p) && n.variables.get(b.name) === b) return a(g.parent(), t, t.right.transform(g)); } if (t instanceof ye) { if (i(t, this), t.init instanceof le) { x = t.init; return t.init = x.body.pop(), x.body.push(t), l ? ne.splice(x.body) : x; } return c(t.init) && (t.init = null), t; } if (t instanceof fe && t.body instanceof ye) { if (i(t, this), t.body instanceof le) { var x = t.body; return t.body = x.body.pop(), x.body.push(t), l ? ne.splice(x.body) : x; } return t; } return t instanceof xe && t !== n ? t : void 0;
            }); n.transform(g);
          }
        }), xe.DEFMETHOD('hoist_declarations', function (e) { let t = this; if (e.has_directive('use asm')) return t; const n = e.option('hoist_funs'); let i = e.option('hoist_vars'); if (n || i) { const o = []; const a = []; const u = new k(); let c = 0; let l = 0; t.walk(new T((e => e instanceof xe && e !== t || (e instanceof $e ? (++l, !0) : void 0)))), i = i && l > 1; var p = new H(((s) => { if (s !== t) { if (s instanceof ae) return o.push(s), r(pe, s); if (s instanceof Ce && n) return a.push(s), r(pe, s); if (s instanceof $e && i) { s.definitions.forEach((e) => { u.set(e.name.name, e), ++c; }); const l = s.to_assignments(e); const h = p.parent(); if (h instanceof be && h.init === s) { if (l == null) { const f = s.definitions[0].name; return r(_t, f, f); } return l; } return h instanceof ye && h.init === s ? l : l ? r(ue, s, { body: l }) : r(pe, s); } if (s instanceof xe) return s; } })); if (t = t.transform(p), c > 0) { let h = []; if (u.each((e, n) => { t instanceof ke && s(t => t.name == e.name.name, t.argnames) ? u.del(n) : ((e = e.clone()).value = null, h.push(e), u.set(n, e)); }), h.length > 0) { for (;t.body.length > 0;) { if (t.body[0] instanceof ue) { var f; var d; const m = t.body[0].body; if (m instanceof rt && m.operator == '=' && (f = m.left) instanceof lt && u.has(f.name)) { if ((g = u.get(f.name)).value) break; g.value = m.right, b(h, g), h.push(g), t.body.splice(0, 1); continue; } if (m instanceof Ye && (d = m.car) instanceof rt && d.operator == '=' && (f = d.left) instanceof lt && u.has(f.name)) { var g = u.get(f.name); if (g.value) break; g.value = d.right, b(h, g), h.push(g), t.body[0].body = m.cdr; continue; } } if (t.body[0] instanceof pe)t.body.splice(0, 1); else { if (!(t.body[0] instanceof le)) break; const v = [0, 1].concat(t.body[0].body); t.body.splice.apply(t.body, v); } }h = r($e, t, { definitions: h }), a.push(h); } }t.body = o.concat(a, t.body); } return t; }), (function (e) { function t(e, t, n) { for (var r = [], i = !1, o = 0, s = e.length; o < s; o++) { const a = e[o].drop_side_effect_free(t, n); i |= a !== e[o], a && (r.push(a), n = !1); } return i ? r.length ? r : null : e; }e(ie, m), e(kt, g), e(wt, g), e(We, function (e, n) { if (!this.has_pure_annotation(e) && e.pure_funcs(this)) { if (this.expression instanceof Ae && (!this.expression.name || !this.expression.name.definition().references.length)) { const r = this.clone(); return r.expression = r.expression.process_expression(!1, e), r; } return this; } this.pure && (e.warn('Dropping __PURE__ call [{file}:{line},{col}]', this.start), this.pure.value = this.pure.value.replace(/[@#]__PURE__/g, ' ')); const i = t(this.args, e, n); return i && Ye.from_array(i); }), e(Ee, g), e(Ae, g), e(tt, function (e, t) { const n = this.right.drop_side_effect_free(e); if (!n) return this.left.drop_side_effect_free(e, t); switch (this.operator) { case '&&': case '||': if (n === this.right) return this; var i = this.clone(); return i.right = n, i; default: var o = this.left.drop_side_effect_free(e, t); return o ? r(Ye, this, { car: o, cdr: n }) : this.right.drop_side_effect_free(e, t); } }), e(rt, m), e(nt, function (e) { const t = this.consequent.drop_side_effect_free(e); const n = this.alternative.drop_side_effect_free(e); if (t === this.consequent && n === this.alternative) return this; if (!t) return n ? r(tt, this, { operator: '||', left: this.condition, right: n }) : this.condition.drop_side_effect_free(e); if (!n) return r(tt, this, { operator: '&&', left: this.condition, right: t }); const i = this.clone(); return i.consequent = t, i.alternative = n, i; }), e(Qe, function (e, t) { if (z(this.operator)) return this; if (this.operator == 'typeof' && this.expression instanceof _t) return null; const n = this.expression.drop_side_effect_free(e, t); return t && this instanceof Ze && p(n) ? n === this.expression && this.operator.length === 1 ? this : r(Ze, this, { operator: this.operator.length === 1 ? this.operator : '!', expression: n }) : n; }), e(_t, function () { return this.undeclared() ? this : null; }), e(ot, function (e, n) { const r = t(this.properties, e, n); return r && Ye.from_array(r); }), e(st, function (e, t) { return this.value.drop_side_effect_free(e, t); }), e(it, function (e, n) { const r = t(this.elements, e, n); return r && Ye.from_array(r); }), e(Ke, function (e, t) { return this.expression.may_throw_on_access(e) ? this : this.expression.drop_side_effect_free(e, t); }), e(Je, function (e, t) { if (this.expression.may_throw_on_access(e)) return this; const n = this.expression.drop_side_effect_free(e, t); if (!n) return this.property.drop_side_effect_free(e, t); const i = this.property.drop_side_effect_free(e); return i ? r(Ye, this, { car: n, cdr: i }) : n; }), e(Ye, function (e) { const t = this.cdr.drop_side_effect_free(e); return t === this.cdr ? this : t ? r(Ye, this, { car: this.car, cdr: t }) : this.car; }); }((e, t) => { e.DEFMETHOD('drop_side_effect_free', t); })), e(ue, (e, t) => { if (t.option('side_effects')) { const n = e.body; const i = n.drop_side_effect_free(t, !0); if (!i) return t.warn('Dropping side-effect-free statement [{file}:{line},{col}]', e.start), r(pe, e); if (i !== n) return r(ue, e, { body: i }); } return e; }), e(me, (e, t) => { if (!t.option('loops')) return e; const n = e.condition.evaluate(t); if (n !== e.condition) { if (n) return r(ye, e, { body: e.body }); if (t.option('dead_code') && e instanceof ve) { const i = []; return O(t, e.body, i), r(le, e, { body: i }).optimize(t); } if (e instanceof ge) { let o = !1; var s = new T((t => !!(t instanceof xe || o) || (t instanceof Be && s.loopcontrol_target(t) === e ? o = !0 : void 0))); const a = t.parent(); if ((a instanceof fe ? a : e).walk(s), !o) return e.body; } } return e instanceof ve ? r(ye, e, e).optimize(t) : e; }), e(ye, (e, t) => { if (!t.option('loops')) return e; if (e.condition) { let n = e.condition.evaluate(t); if (t.option('dead_code') && !n) { const o = []; return e.init instanceof oe ? o.push(e.init) : e.init && o.push(r(ue, e.init, { body: e.init })), O(t, e.body, o), r(le, e, { body: o }).optimize(t); }n !== e.condition && (n = i(n, e.condition).transform(t), e.condition = D(n, e.condition)); } return R(e, t), e; }), e(Ne, (e, t) => { if (c(e.alternative) && (e.alternative = null), !t.option('conditionals')) return e; let n = e.condition.evaluate(t); if (n !== e.condition) { if (n) { if (t.warn('Condition always true [{file}:{line},{col}]', e.condition.start), t.option('dead_code')) { o = []; return e.alternative && O(t, e.alternative, o), o.push(e.body), r(le, e, { body: o }).optimize(t); } } else if (t.warn('Condition always false [{file}:{line},{col}]', e.condition.start), t.option('dead_code')) { var o = []; return O(t, e.body, o), e.alternative && o.push(e.alternative), r(le, e, { body: o }).optimize(t); }n = i(n, e.condition).transform(t), e.condition = D(n, e.condition); } const s = e.condition.negate(t); const a = e.condition.print_to_string().length; const u = s.print_to_string().length; let l = u < a; if (e.alternative && l) { l = !1, e.condition = s; const p = e.body; e.body = e.alternative || r(pe, e), e.alternative = p; } if (c(e.body) && c(e.alternative)) return r(ue, e.condition, { body: e.condition.clone() }).optimize(t); if (e.body instanceof ue && e.alternative instanceof ue) return r(ue, e, { body: r(nt, e, { condition: e.condition, consequent: e.body.body, alternative: e.alternative.body }) }).optimize(t); if (c(e.alternative) && e.body instanceof ue) return a === u && !l && e.condition instanceof tt && e.condition.operator == '||' && (l = !0), l ? r(ue, e, { body: r(tt, e, { operator: '||', left: s, right: e.body.body }) }).optimize(t) : r(ue, e, { body: r(tt, e, { operator: '&&', left: e.condition, right: e.body.body }) }).optimize(t); if (e.body instanceof pe && e.alternative instanceof ue) return r(ue, e, { body: r(tt, e, { operator: '||', left: e.condition, right: e.alternative.body }) }).optimize(t); if (e.body instanceof Te && e.alternative instanceof Te && e.body.TYPE == e.alternative.TYPE) return r(e.body.CTOR, e, { value: r(nt, e, { condition: e.condition, consequent: e.body.value || r(Ft, e.body), alternative: e.alternative.value || r(Ft, e.alternative) }).transform(t) }).optimize(t); if (e.body instanceof Ne && !e.body.alternative && !e.alternative && (e = r(Ne, e, { condition: r(tt, e.condition, { operator: '&&', left: e.condition, right: e.body.condition }), body: e.body.body, alternative: null })), M(e.body) && e.alternative) { const h = e.alternative; return e.alternative = null, r(le, e, { body: [e, h] }).optimize(t); } if (M(e.alternative)) { const f = e.body; return e.body = e.alternative, e.condition = l ? s : e.condition.negate(t), e.alternative = null, r(le, e, { body: [e, f] }).optimize(t); } return e; }), e(Me, (e, t) => { function n(e, n) { n && !M(n) ? n.body = n.body.concat(e.body) : O(t, e, l); } if (!t.option('switches')) return e; let o; const s = e.expression.evaluate(t); if (s !== e.expression) { const a = i(s, e.expression).transform(t); e.expression = D(a, e.expression); } if (!t.option('dead_code')) return e; for (var u, c, l = [], p = [], h = 0, f = e.body.length; h < f && !c; h++) { if ((o = e.body[h]) instanceof Pe)u ? n(o, p[p.length - 1]) : u = o; else if (s !== e.expression) { const d = o.expression.evaluate(t); if (d === s) { if (c = o, u) { const m = p.indexOf(u); p.splice(m, 1), n(u, p[m - 1]), u = null; } } else if (d !== o.expression) { n(o, p[p.length - 1]); continue; } } if (M(o)) { const g = p[p.length - 1]; M(g) && g.body.length == o.body.length && r(le, g, g).equivalent_to(r(le, o, o)) && (g.body = []); }p.push(o); } for (;h < f;)n(e.body[h++], p[p.length - 1]); for (p.length > 0 && (p[0].body = l.concat(p[0].body)), e.body = p; o = p[p.length - 1];) { const v = o.body[o.body.length - 1]; if (v instanceof De && t.loopcontrol_target(v) === e && o.body.pop(), o.body.length || o instanceof Ie && (u || o.expression.has_side_effects(t))) break; p.pop() === u && (u = null); } if (p.length == 0) return r(le, e, { body: l.concat(r(ue, e.expression, { body: e.expression })) }).optimize(t); if (p.length == 1 && (p[0] === c || p[0] === u)) { let y = !1; var b = new T(((t) => { if (y || t instanceof ke || t instanceof ue) return !0; t instanceof De && b.loopcontrol_target(t) === e && (y = !0); })); if (e.walk(b), !y) return (p = p[0].body.slice()).unshift(r(ue, e.expression, { body: e.expression })), r(le, e, { body: p }).optimize(t); } return e; }), e(je, (e, t) => { if (e.body = v(e.body, t), e.bcatch && e.bfinally && w(e.bfinally.body, c) && (e.bfinally = null), w(e.body, c)) { let n = []; return e.bcatch && O(t, e.bcatch, n), e.bfinally && (n = n.concat(e.bfinally.body)), r(le, e, { body: n }).optimize(t); } return e; }), Ue.DEFMETHOD('remove_initializers', function () { this.definitions.forEach((e) => { e.value = null; }); }), Ue.DEFMETHOD('to_assignments', function (e) { const t = e.option('reduce_vars'); const n = this.definitions.reduce((e, n) => { if (n.value) { const i = r(_t, n.name, n.name); e.push(r(rt, n, { operator: '=', left: i, right: n.value })), t && (i.definition().fixed = !1); } return e; }, []); return n.length == 0 ? null : Ye.from_array(n); }), e(Ue, (e, t) => (e.definitions.length == 0 ? r(pe, e) : e)), e(We, (e, t) => { let n = e.expression; if (t.option('reduce_vars') && n instanceof _t) { const o = n.definition(); let s = n.fixed_value(); s instanceof Ce && (o.fixed = s = r(Ae, s, s).clone(!0)), s instanceof Ae && (n = s, !t.option('unused') || o.references.length != 1 || o.scope.uses_arguments && o.orig[0] instanceof mt || o.scope.uses_eval || t.find_parent(xe) !== o.scope || (e.expression = n)); } if (t.option('unused') && n instanceof Ae && !n.uses_arguments && !n.uses_eval) { for (var a = 0, u = 0, l = 0, h = e.args.length; l < h; l++) { const f = l >= n.argnames.length; if (f || n.argnames[l].__unused) { if (E = e.args[l].drop_side_effect_free(t))e.args[a++] = E; else if (!f) { e.args[a++] = r(At, e.args[l], { value: 0 }); continue; } } else e.args[a++] = e.args[l]; u = a; }e.args.length = u; } if (t.option('unsafe')) if (n instanceof _t && n.undeclared()) switch (n.name) { case 'Array': if (e.args.length != 1) return r(it, e, { elements: e.args }).optimize(t); break; case 'Object': if (e.args.length == 0) return r(ot, e, { properties: [] }); break; case 'String': if (e.args.length == 0) return r(Et, e, { value: '' }); if (e.args.length <= 1) return r(tt, e, { left: e.args[0], operator: '+', right: r(Et, e, { value: '' }) }).optimize(t); break; case 'Number': if (e.args.length == 0) return r(At, e, { value: 0 }); if (e.args.length == 1) return r(Ze, e, { expression: e.args[0], operator: '+' }).optimize(t); case 'Boolean': if (e.args.length == 0) return r(Nt, e); if (e.args.length == 1) return r(Ze, e, { expression: r(Ze, e, { expression: e.args[0], operator: '!' }), operator: '!' }).optimize(t); break; case 'Function': if (e.args.length == 0) return r(Ae, e, { argnames: [], body: [] }); if (w(e.args, e => e instanceof Et)) try { let d = q(y = `(function(${e.args.slice(0, -1).map(e => e.value).join(',')}){${e.args[e.args.length - 1].value}})()`); d.figure_out_scope({ screw_ie8: t.option('screw_ie8') }); const m = new X(t.options); (d = d.transform(m)).figure_out_scope({ screw_ie8: t.option('screw_ie8') }), d.mangle_names(); let g; try { d.walk(new T(((e) => { if (e instanceof ke) throw g = e, d; }))); } catch (e) { if (e !== d) throw e; } if (!g) return e; var v = g.argnames.map((t, n) => r(Et, e.args[n], { value: t.print_to_string() })); var y = Y(); return le.prototype._codegen.call(g, g, y), y = y.toString().replace(/^\{|\}$/g, ''), v.push(r(Et, e.args[e.args.length - 1], { value: y })), e.args = v, e; } catch (n) { if (!(n instanceof V)) throw console.log(n), n; t.warn('Error parsing code passed to new Function [{file}:{line},{col}]', e.args[e.args.length - 1].start), t.warn(n.toString()); } } else { if (n instanceof Ke && n.property == 'toString' && e.args.length == 0) return r(tt, e, { left: r(Et, e, { value: '' }), operator: '+', right: n.expression }).optimize(t); if (n instanceof Ke && n.expression instanceof it && n.property == 'join') { let b; if (!(e.args.length > 0 && (b = e.args[0].evaluate(t)) === e.args[0])) { const _ = []; const x = []; if (n.expression.elements.forEach((n) => { const i = n.evaluate(t); i !== n ? x.push(i) : (x.length > 0 && (_.push(r(Et, e, { value: x.join(b) })), x.length = 0), _.push(n)); }), x.length > 0 && _.push(r(Et, e, { value: x.join(b) })), _.length == 0) return r(Et, e, { value: '' }); if (_.length == 1) return _[0].is_string(t) ? _[0] : r(tt, _[0], { operator: '+', left: r(Et, e, { value: '' }), right: _[0] }); if (b == '') { let k; return k = _[0].is_string(t) || _[1].is_string(t) ? _.shift() : r(Et, e, { value: '' }), _.reduce((e, t) => r(tt, t, { operator: '+', left: e, right: t }), k).optimize(t); } var E = e.clone(); return E.expression = E.expression.clone(), E.expression.expression = E.expression.expression.clone(), E.expression.expression.elements = _, N(t, e, E); } } else if (n instanceof Ke && n.expression.is_string(t) && n.property == 'charAt') { const A = e.args[0]; const C = A ? A.evaluate(t) : 0; if (C !== A) return r(Je, n, { expression: n.expression, property: i(0 | C, A || n) }).optimize(t); } } if (n instanceof Ae) { if (n.body[0] instanceof Oe) { const S = n.body[0].value; if (!S || S.is_constant()) { v = e.args.concat(S || r(Ft, e)); return Ye.from_array(v).transform(t); } } if (t.option('side_effects') && w(n.body, c)) { v = e.args.concat(r(Ft, e)); return Ye.from_array(v).transform(t); } } if (t.option('drop_console') && n instanceof Xe) { for (var O = n.expression; O.expression;)O = O.expression; if (O instanceof _t && O.name == 'console' && O.undeclared()) return r(Ft, e).optimize(t); } return t.option('negate_iife') && t.parent() instanceof ue && p(e) ? e.negate(t, !0) : e; }), e(Ge, (e, t) => { if (t.option('unsafe')) { const n = e.expression; if (n instanceof _t && n.undeclared()) switch (n.name) { case 'Object': case 'RegExp': case 'Function': case 'Error': case 'Array': return r(We, e, e).transform(t); } } return e; }), e(Ye, (e, n) => { if (!n.option('side_effects')) return e; if (e.car = e.car.drop_side_effect_free(n, A(n)), !e.car) return a(n.parent(), e, e.cdr); if (n.option('cascade')) { let i; if (e.car instanceof rt && !e.car.left.has_side_effects(n) ? i = e.car.left : e.car instanceof Qe && (e.car.operator == '++' || e.car.operator == '--') && (i = e.car.expression), i && !(i instanceof _t && (i.definition().orig[0] instanceof vt || t(i)))) for (var o, s, u = e.cdr; ;) { if (u.equivalent_to(i)) { const c = e.car instanceof et ? r(Ze, e.car, { operator: e.car.operator, expression: i }) : e.car; return o ? (o[s] = c, e.cdr) : c; } if (u instanceof tt && !(u instanceof rt)) if (u.left.is_constant()) { if (u.operator == '||' || u.operator == '&&') break; s = 'right'; } else s = 'left'; else { if (!(u instanceof We || u instanceof Qe && !z(u.operator))) break; s = 'expression'; }o = u, u = u[s]; } } return F(e.cdr, n) ? r(Ze, e, { operator: 'void', expression: e.car }) : e; }), Qe.DEFMETHOD('lift_sequences', function (e) { if (e.option('sequences') && this.expression instanceof Ye) { let t = this.expression; const n = t.to_array(); const r = this.clone(); return r.expression = n.pop(), n.push(r), t = Ye.from_array(n).transform(e); } return this; }), e(et, (e, t) => e.lift_sequences(t)), e(Ze, (e, t) => { let n = e.expression; if (e.operator == 'delete' && !(n instanceof _t || n instanceof Xe || n instanceof Ot || n instanceof Dt || n instanceof Ft)) return n instanceof Ye ? ((n = n.to_array()).push(r(Mt, e)), Ye.from_array(n).optimize(t)) : r(Ye, e, { car: n, cdr: r(Mt, e) }).optimize(t); const o = e.lift_sequences(t); if (o !== e) return o; if (t.option('side_effects') && e.operator == 'void') return (n = n.drop_side_effect_free(t)) ? (e.expression = n, e) : r(Ft, e).optimize(t); if (t.option('booleans') && t.in_boolean_context()) switch (e.operator) { case '!': if (n instanceof Ze && n.operator == '!') return n.expression; n instanceof tt && (e = N(t, e, n.negate(t, A(t)))); break; case 'typeof': return t.warn('Boolean expression always true [{file}:{line},{col}]', e.start), (n instanceof _t ? r(Mt, e) : r(Ye, e, { car: n, cdr: r(Mt, e) })).optimize(t); } if (e.operator == '-' && n instanceof Dt && (n = n.transform(t)), n instanceof tt && (e.operator == '+' || e.operator == '-') && (n.operator == '*' || n.operator == '/' || n.operator == '%')) return r(tt, e, { operator: n.operator, left: r(Ze, n.left, { operator: e.operator, expression: n.left }), right: n.right }); if (e.operator != '-' || !(n instanceof At || n instanceof Dt)) { let s = e.evaluate(t); if (s !== e) return s = i(s, e).optimize(t), N(t, s, e); } return e; }), tt.DEFMETHOD('lift_sequences', function (e) { if (e.option('sequences')) { if (this.left instanceof Ye) { const t = (o = this.left).to_array(); return (s = this.clone()).left = t.pop(), t.push(s), Ye.from_array(t).optimize(e); } if (this.right instanceof Ye && !this.left.has_side_effects(e)) { for (var n, r = this.operator == '=' && this.left instanceof _t, i = this.right.clone(), o = i; (r || !o.car.has_side_effects(e)) && (n = o, o.cdr instanceof Ye);)o = o.cdr = o.cdr.clone(); if (n) { var s = this.clone(); return s.right = n.cdr, n.cdr = s, i.optimize(e); } } } return this; }); const U = x('== === != !== * & | ^'); e(tt, (e, t) => {
          function n() { return e.left.is_constant() || e.right.is_constant() || !e.left.has_side_effects(t) && !e.right.has_side_effects(t); } function o(t) { if (n()) { t && (e.operator = t); const r = e.left; e.left = e.right, e.right = r; } } if (U(e.operator) && e.right.is_constant() && !e.left.is_constant() && (e.left instanceof tt && en[e.left.operator] >= en[e.operator] || o()), e = e.lift_sequences(t), t.option('comparisons')) switch (e.operator) { case '===': case '!==': (e.left.is_string(t) && e.right.is_string(t) || e.left.is_number(t) && e.right.is_number(t) || e.left.is_boolean() && e.right.is_boolean()) && (e.operator = e.operator.substr(0, 2)); case '==': case '!=': if (e.left instanceof Et && e.left.value == 'undefined' && e.right instanceof Ze && e.right.operator == 'typeof') { const s = e.right.expression; (s instanceof _t ? s.undeclared() : s instanceof Xe && !t.option('screw_ie8')) || (e.right = s, e.left = r(Ft, e.left).optimize(t), e.operator.length == 2 && (e.operator += '=')); } } if (t.option('booleans') && e.operator == '+' && t.in_boolean_context()) { var u = e.left.evaluate(t); var c = e.right.evaluate(t); if (u && typeof u === 'string') return t.warn('+ in boolean context always true [{file}:{line},{col}]', e.start), r(Ye, e, { car: e.right, cdr: r(Mt, e) }).optimize(t); if (c && typeof c === 'string') return t.warn('+ in boolean context always true [{file}:{line},{col}]', e.start), r(Ye, e, { car: e.left, cdr: r(Mt, e) }).optimize(t); } if (t.option('comparisons') && e.is_boolean()) { if (!(t.parent() instanceof tt) || t.parent() instanceof rt) { const l = r(Ze, e, { operator: '!', expression: e.negate(t, A(t)) }); e = N(t, e, l); } if (t.option('unsafe_comps')) switch (e.operator) { case '<': o('>'); break; case '<=': o('>='); } } if (e.operator == '+') { if (e.right instanceof Et && e.right.getValue() == '' && e.left.is_string(t)) return e.left; if (e.left instanceof Et && e.left.getValue() == '' && e.right.is_string(t)) return e.right; if (e.left instanceof tt && e.left.operator == '+' && e.left.left instanceof Et && e.left.left.getValue() == '' && e.right.is_string(t)) return e.left = e.left.right, e.transform(t); } if (t.option('evaluate')) {
            switch (e.operator) { case '&&': if (!(u = e.left.evaluate(t))) return t.warn('Condition left of && always false [{file}:{line},{col}]', e.start), a(t.parent(), e, e.left).optimize(t); if (u !== e.left) return t.warn('Condition left of && always true [{file}:{line},{col}]', e.start), a(t.parent(), e, e.right).optimize(t); if (t.option('booleans') && t.in_boolean_context()) { if (!(c = e.right.evaluate(t))) return t.warn('Boolean && always false [{file}:{line},{col}]', e.start), r(Ye, e, { car: e.left, cdr: r(Nt, e) }).optimize(t); if (c !== e.right) return t.warn('Dropping side-effect-free && in boolean context [{file}:{line},{col}]', e.start), e.left.optimize(t); } break; case '||': if (!(u = e.left.evaluate(t))) return t.warn('Condition left of || always false [{file}:{line},{col}]', e.start), a(t.parent(), e, e.right).optimize(t); if (u !== e.left) return t.warn('Condition left of || always true [{file}:{line},{col}]', e.start), a(t.parent(), e, e.left).optimize(t); if (t.option('booleans') && t.in_boolean_context()) { if (!(c = e.right.evaluate(t))) return t.warn('Dropping side-effect-free || in boolean context [{file}:{line},{col}]', e.start), e.left.optimize(t); if (c !== e.right) return t.warn('Boolean || always true [{file}:{line},{col}]', e.start), r(Ye, e, { car: e.left, cdr: r(Mt, e) }).optimize(t); } } let p = !0; switch (e.operator) {
              case '+': if (e.left instanceof kt && e.right instanceof tt && e.right.operator == '+' && e.right.left instanceof kt && e.right.is_string(t) && (e = r(tt, e, { operator: '+', left: r(Et, e.left, { value: `${e.left.getValue()}${e.right.left.getValue()}`, start: e.left.start, end: e.right.left.end }), right: e.right.right })), e.right instanceof kt && e.left instanceof tt && e.left.operator == '+' && e.left.right instanceof kt && e.left.is_string(t) && (e = r(tt, e, { operator: '+', left: e.left.left, right: r(Et, e.right, { value: `${e.left.right.getValue()}${e.right.getValue()}`, start: e.left.right.start, end: e.right.end }) })), e.left instanceof tt && e.left.operator == '+' && e.left.is_string(t) && e.left.right instanceof kt && e.right instanceof tt && e.right.operator == '+' && e.right.left instanceof kt && e.right.is_string(t) && (e = r(tt, e, { operator: '+', left: r(tt, e.left, { operator: '+', left: e.left.left, right: r(Et, e.left.right, { value: `${e.left.right.getValue()}${e.right.left.getValue()}`, start: e.left.right.start, end: e.right.left.end }) }), right: e.right.right })), e.right instanceof Ze && e.right.operator == '-' && e.left.is_number(t)) { e = r(tt, e, { operator: '-', left: e.left, right: e.right.expression }); break; } if (e.left instanceof Ze && e.left.operator == '-' && n() && e.right.is_number(t)) { e = r(tt, e, { operator: '-', left: e.right, right: e.left.expression }); break; } case '*': p = t.option('unsafe_math'); case '&': case '|': case '^': if (e.left.is_number(t) && e.right.is_number(t) && n() && !(e.left instanceof tt && e.left.operator != e.operator && en[e.left.operator] >= en[e.operator])) { const h = r(tt, e, { operator: e.operator, left: e.right, right: e.left }); e = e.right instanceof kt && !(e.left instanceof kt) ? N(t, h, e) : N(t, e, h); }p && e.is_number(t) && (e.right instanceof tt && e.right.operator == e.operator && (e = r(tt, e, {
                operator: e.operator,
                left: r(tt, e.left, {
                  operator: e.operator, left: e.left, right: e.right.left, start: e.left.start, end: e.right.left.end,
                }),
                right: e.right.right,
              })), e.right instanceof kt && e.left instanceof tt && e.left.operator == e.operator && (e.left.left instanceof kt ? e = r(tt, e, {
                operator: e.operator,
                left: r(tt, e.left, {
                  operator: e.operator, left: e.left.left, right: e.right, start: e.left.left.start, end: e.right.end,
                }),
                right: e.left.right,
              }) : e.left.right instanceof kt && (e = r(tt, e, {
                operator: e.operator,
                left: r(tt, e.left, {
                  operator: e.operator, left: e.left.right, right: e.right, start: e.left.right.start, end: e.right.end,
                }),
                right: e.left.left,
              }))), e.left instanceof tt && e.left.operator == e.operator && e.left.right instanceof kt && e.right instanceof tt && e.right.operator == e.operator && e.right.left instanceof kt && (e = r(tt, e, {
                operator: e.operator,
                left: r(tt, e.left, {
                  operator: e.operator,
                  left: r(tt, e.left.left, {
                    operator: e.operator, left: e.left.right, right: e.right.left, start: e.left.right.start, end: e.right.left.end,
                  }),
                  right: e.left.left,
                }),
                right: e.right.right,
              })));
            }
          } if (e.right instanceof tt && e.right.operator == e.operator && (e.operator == '&&' || e.operator == '||' || e.operator == '+' && (e.right.left.is_string(t) || e.left.is_string(t) && e.right.right.is_string(t)))) return e.left = r(tt, e.left, { operator: e.operator, left: e.left, right: e.right.left }), e.right = e.right.right, e.transform(t); let f = e.evaluate(t); return f !== e ? (f = i(f, e).optimize(t), N(t, f, e)) : e;
        }), e(_t, (e, t) => { const n = e.resolve_defines(t); if (n) return n.optimize(t); if (t.option('screw_ie8') && e.undeclared() && (!e.scope.uses_with || !t.find_parent(_e))) switch (e.name) { case 'undefined': return r(Ft, e).optimize(t); case 'NaN': return r(Ot, e).optimize(t); case 'Infinity': return r(Dt, e).optimize(t); } if (t.option('evaluate') && t.option('reduce_vars') && B(e, t.parent()) !== e) { const o = e.definition(); const s = e.fixed_value(); if (s) { if (void 0 === o.should_replace) { let a = s.evaluate(t); if (a === s || !t.option('unsafe_regexp') && a instanceof RegExp)o.should_replace = !1; else { let u; let c = (a = i(a, s)).optimize(t).print_to_string().length; !(function (e) { let t; return e.walk(new T(((e) => { if (e instanceof _t && (t = !0), t) return !0; }))), t; }(s)) ? (c = Math.min(c, s.print_to_string().length), u = function () { const e = D(a.optimize(t), s); return e === a || e === s ? e.clone(!0) : e; }) : u = function () { const e = a.optimize(t); return e === a ? e.clone(!0) : e; }; const l = o.name.length; let p = 0; !t.option('unused') || o.global && !t.option('toplevel') || (p = (l + 2 + c) / o.references.length), o.should_replace = c <= l + p && u; } } if (o.should_replace) return o.should_replace(); } } return e; }), e(Ft, (e, t) => { if (t.option('unsafe')) { const i = n(t, 'undefined'); if (i) { const o = r(_t, e, { name: 'undefined', scope: i.scope, thedef: i }); return o.is_undefined = !0, o; } } const s = B(t.self(), t.parent()); return s && P(s, e) ? e : r(Ze, e, { operator: 'void', expression: r(At, e, { value: 0 }) }); }), e(Dt, (e, t) => { const i = B(t.self(), t.parent()); return i && P(i, e) ? e : !t.option('keep_infinity') || i && !P(i, e) || n(t, 'Infinity') ? r(tt, e, { operator: '/', left: r(At, e, { value: 1 }), right: r(At, e, { value: 0 }) }) : e; }), e(Ot, (e, t) => { const i = B(t.self(), t.parent()); return i && !P(i, e) || n(t, 'NaN') ? r(tt, e, { operator: '/', left: r(At, e, { value: 0 }), right: r(At, e, { value: 0 }) }) : e; }); const $ = ['+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&']; const W = ['*', '|', '^', '&']; e(rt, (e, t) => (e = e.lift_sequences(t)).operator == '=' && e.left instanceof _t && e.right instanceof tt && (e.right.left instanceof _t && e.right.left.name == e.left.name && o(e.right.operator, $) ? (e.operator = `${e.right.operator}=`, e.right = e.right.right) : e.right.right instanceof _t && e.right.right.name == e.left.name && o(e.right.operator, W) && !e.right.left.has_side_effects(t) && (e.operator = `${e.right.operator}=`, e.right = e.right.left)), e), e(nt, (e, t) => { function n(e) { return e.is_boolean() ? e : r(Ze, e, { operator: '!', expression: e.negate(t) }); } function i(e) { return e instanceof Mt || e instanceof Ze && e.operator == '!' && e.expression instanceof kt && !e.expression.value; } function o(e) { return e instanceof Nt || e instanceof Ze && e.operator == '!' && e.expression instanceof kt && !!e.expression.value; } if (!t.option('conditionals')) return e; if (e.condition instanceof Ye) { const s = e.condition.car; return e.condition = e.condition.cdr, Ye.cons(s, e); } const u = e.condition.evaluate(t); if (u !== e.condition) return u ? (t.warn('Condition always true [{file}:{line},{col}]', e.start), a(t.parent(), e, e.consequent)) : (t.warn('Condition always false [{file}:{line},{col}]', e.start), a(t.parent(), e, e.alternative)); const c = u.negate(t, A(t)); N(t, u, c) === c && (e = r(nt, e, { condition: c, consequent: e.alternative, alternative: e.consequent })); const l = e.condition; const p = e.consequent; const h = e.alternative; return l instanceof _t && p instanceof _t && l.definition() === p.definition() ? r(tt, e, { operator: '||', left: l, right: h }) : p instanceof rt && h instanceof rt && p.operator == h.operator && p.left.equivalent_to(h.left) && (!e.condition.has_side_effects(t) || p.operator == '=' && !p.left.has_side_effects(t)) ? r(rt, e, { operator: p.operator, left: p.left, right: r(nt, e, { condition: e.condition, consequent: p.right, alternative: h.right }) }) : p instanceof We && h.TYPE === p.TYPE && p.args.length == 1 && h.args.length == 1 && p.expression.equivalent_to(h.expression) && !p.expression.has_side_effects(t) ? (p.args[0] = r(nt, e, { condition: e.condition, consequent: p.args[0], alternative: h.args[0] }), p) : p instanceof nt && p.alternative.equivalent_to(h) ? r(nt, e, { condition: r(tt, e, { left: e.condition, operator: '&&', right: p.condition }), consequent: p.consequent, alternative: h }) : p.equivalent_to(h) ? r(Ye, e, { car: e.condition, cdr: p }).optimize(t) : i(e.consequent) ? o(e.alternative) ? n(e.condition) : r(tt, e, { operator: '||', left: n(e.condition), right: e.alternative }) : o(e.consequent) ? i(e.alternative) ? n(e.condition.negate(t)) : r(tt, e, { operator: '&&', left: n(e.condition.negate(t)), right: e.alternative }) : i(e.alternative) ? r(tt, e, { operator: '||', left: n(e.condition.negate(t)), right: e.consequent }) : o(e.alternative) ? r(tt, e, { operator: '&&', left: n(e.condition), right: e.consequent }) : e; }), e(Lt, (e, t) => {
          if (t.option('booleans')) {
            const n = t.parent(); return n instanceof tt && (n.operator == '==' || n.operator == '!=') ? (t.warn('Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]', {
              operator: n.operator, value: e.value, file: n.start.file, line: n.start.line, col: n.start.col,
            }), r(At, e, { value: +e.value })) : r(Ze, e, { operator: '!', expression: r(At, e, { value: 1 - e.value }) });
          } return e;
        }), e(Je, (e, t) => { let n = e.property; if (n instanceof Et && t.option('properties')) { if (n = n.getValue(), It(n) ? t.option('screw_ie8') : I(n)) return r(Ke, e, { expression: e.expression, property: n }).optimize(t); const o = parseFloat(n); isNaN(o) || o.toString() != n || (e.property = r(At, e.property, { value: o })); } let s = e.evaluate(t); return s !== e ? (s = i(s, e).optimize(t), N(t, s, e)) : e; }), e(Ke, (e, t) => { const n = e.resolve_defines(t); if (n) return n.optimize(t); const o = e.property; if (It(o) && !t.option('screw_ie8')) return r(Je, e, { expression: e.expression, property: r(Et, e, { value: o }) }).optimize(t); if (t.option('unsafe_proto') && e.expression instanceof Ke && e.expression.property == 'prototype') { const s = e.expression.expression; if (s instanceof _t && s.undeclared()) switch (s.name) { case 'Array': e.expression = r(it, e.expression, { elements: [] }); break; case 'Object': e.expression = r(ot, e.expression, { properties: [] }); break; case 'String': e.expression = r(Et, e.expression, { value: '' }); } } let a = e.evaluate(t); return a !== e ? (a = i(a, e).optimize(t), N(t, a, e)) : e; }), e(it, j), e(ot, j), e(Ct, j), e(Oe, (e, t) => e.value && F(e.value, t) && (e.value = null), e), e(He, (e, t) => { const n = t.option('global_defs'); return n && E(n, e.name.name) && t.warn(`global_defs ${e.name.name} redefined [{file}:{line},{col}]`, e.start), e; });
      }()), (function () {
        function e(e) { if (e.type == 'Literal') return e.raw != null ? e.raw : `${e.value}`; } function t(t) {
          const n = t.loc; const r = n && n.start; const i = t.range; return new re({
            file: n && n.source, line: r && r.line, col: r && r.column, pos: i ? i[0] : t.start, endline: r && r.line, endcol: r && r.column, endpos: i ? i[0] : t.start, raw: e(t),
          });
        } function r(t) {
          const n = t.loc; const r = n && n.end; const i = t.range; return new re({
            file: n && n.source, line: r && r.line, col: r && r.column, pos: i ? i[1] : t.end, endline: r && r.line, endcol: r && r.column, endpos: i ? i[1] : t.end, raw: e(t),
          });
        } function i(e, i, s) { let p = `function From_Moz_${e}(M){\n`; p += `return new U2.${i.name}({\nstart: my_start_token(M),\nend: my_end_token(M)`; let f = `function To_Moz_${e}(M){\n`; f += `return {\ntype: ${JSON.stringify(e)}`, s && s.split(/\s*,\s*/).forEach((e) => { const t = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(e); if (!t) throw new Error(`Can't understand property map: ${e}`); const n = t[1]; const r = t[2]; const i = t[3]; switch (p += `,\n${i}: `, f += `,\n${n}: `, r) { case '@': p += `M.${n}.map(from_moz)`, f += `M.${i}.map(to_moz)`; break; case '>': p += `from_moz(M.${n})`, f += `to_moz(M.${i})`; break; case '=': p += `M.${n}`, f += `M.${i}`; break; case '%': p += `from_moz(M.${n}).body`, f += 'to_moz_block(M)'; break; default: throw new Error(`Can't understand operator in propmap: ${e}`); } }), p += '\n})\n}', f += '\n}\n}', p = new Function('U2', 'my_start_token', 'my_end_token', 'from_moz', `return(${p})`)(n, t, r, o), f = new Function('to_moz', 'to_moz_block', 'to_moz_scope', `return(${f})`)(u, c, l), h[e] = p, a(i, f); } function o(e) { f.push(e); const t = e != null ? h[e.type](e) : null; return f.pop(), t; } function s(e, t, n) { const r = e.start; const i = e.end; return r.pos != null && i.endpos != null && (t.range = [r.pos, i.endpos]), r.line && (t.loc = { start: { line: r.line, column: r.col }, end: i.endline ? { line: i.endline, column: i.endcol } : null }, r.file && (t.loc.source = r.file)), t; } function a(e, t) { e.DEFMETHOD('to_mozilla_ast', function () { return s(this, t(this)); }); } function u(e) { return e != null ? e.to_mozilla_ast() : null; } function c(e) { return { type: 'BlockStatement', body: e.body.map(u) }; } function l(e, t) { const n = t.body.map(u); return t.body[0] instanceof ue && t.body[0].body instanceof Et && n.unshift(u(new pe(t.body[0]))), { type: e, body: n }; } const p = function (e) { for (let t = !0, n = 0; n < e.length; n++)t && e[n] instanceof oe && e[n].body instanceof Et ? e[n] = new ae({ start: e[n].start, end: e[n].end, value: e[n].body.value }) : !t || e[n] instanceof oe && e[n].body instanceof Et || (t = !1); return e; }; var h = {
          Program(e) { return new we({ start: t(e), end: r(e), body: p(e.body.map(o)) }); },
          FunctionDeclaration(e) {
            return new Ce({
              start: t(e), end: r(e), name: o(e.id), argnames: e.params.map(o), body: p(o(e.body).body),
            });
          },
          FunctionExpression(e) {
            return new Ae({
              start: t(e), end: r(e), name: o(e.id), argnames: e.params.map(o), body: p(o(e.body).body),
            });
          },
          ExpressionStatement(e) { return new ue({ start: t(e), end: r(e), body: o(e.expression) }); },
          TryStatement(e) {
            const n = e.handlers || [e.handler]; if (n.length > 1 || e.guardedHandlers && e.guardedHandlers.length) throw new Error('Multiple catch clauses are not supported.'); return new je({
              start: t(e), end: r(e), body: o(e.block).body, bcatch: o(n[0]), bfinally: e.finalizer ? new ze(o(e.finalizer)) : null,
            });
          },
          Property(e) {
            const n = e.key; const i = {
              start: t(n), end: r(e.value), key: n.type == 'Identifier' ? n.name : n.value, value: o(e.value),
            }; return e.kind == 'init' ? new at(i) : (i.key = new pt({ name: i.key }), i.value = new Ee(i.value), e.kind == 'get' ? new ct(i) : e.kind == 'set' ? new ut(i) : void 0);
          },
          ArrayExpression(e) { return new it({ start: t(e), end: r(e), elements: e.elements.map(e => (e === null ? new Bt() : o(e))) }); },
          ObjectExpression(e) { return new ot({ start: t(e), end: r(e), properties: e.properties.map(e => e.type = 'Property', o(e)) }); },
          SequenceExpression(e) { return Ye.from_array(e.expressions.map(o)); },
          MemberExpression(e) {
            return new (e.computed ? Je : Ke)({
              start: t(e), end: r(e), property: e.computed ? o(e.property) : e.property.name, expression: o(e.object),
            });
          },
          SwitchCase(e) {
            return new (e.test ? Ie : Pe)({
              start: t(e), end: r(e), expression: o(e.test), body: e.consequent.map(o),
            });
          },
          VariableDeclaration(e) { return new (e.kind === 'const' ? qe : $e)({ start: t(e), end: r(e), definitions: e.declarations.map(o) }); },
          Literal(e) { const n = e.value; const i = { start: t(e), end: r(e) }; if (n === null) return new Tt(i); switch (typeof n) { case 'string': return i.value = n, new Et(i); case 'number': return i.value = n, new At(i); case 'boolean': return new (n ? Mt : Nt)(i); default: var o = e.regex; return o && o.pattern ? i.value = new RegExp(o.pattern, o.flags).toString() : i.value = e.regex && e.raw ? e.raw : n, new Ct(i); } },
          Identifier(e) { const n = f[f.length - 2]; return new (n.type == 'LabeledStatement' ? bt : n.type == 'VariableDeclarator' && n.id === e ? n.kind == 'const' ? dt : ft : n.type == 'FunctionExpression' ? n.id === e ? vt : mt : n.type == 'FunctionDeclaration' ? n.id === e ? gt : mt : n.type == 'CatchClause' ? yt : n.type == 'BreakStatement' || n.type == 'ContinueStatement' ? xt : _t)({ start: t(e), end: r(e), name: e.name }); },
        }; h.UpdateExpression = h.UnaryExpression = function (e) {
          return new (('prefix' in e ? e.prefix : e.type == 'UnaryExpression') ? Ze : et)({
            start: t(e), end: r(e), operator: e.operator, expression: o(e.argument),
          });
        }, i('EmptyStatement', pe), i('BlockStatement', le, 'body@body'), i('IfStatement', Ne, 'test>condition, consequent>body, alternate>alternative'), i('LabeledStatement', fe, 'label>label, body>body'), i('BreakStatement', De, 'label>label'), i('ContinueStatement', Le, 'label>label'), i('WithStatement', _e, 'object>expression, body>body'), i('SwitchStatement', Me, 'discriminant>expression, cases@body'), i('ReturnStatement', Oe, 'argument>value'), i('ThrowStatement', Fe, 'argument>value'), i('WhileStatement', ve, 'test>condition, body>body'), i('DoWhileStatement', ge, 'test>condition, body>body'), i('ForStatement', ye, 'init>init, test>condition, update>step, body>body'), i('ForInStatement', be, 'left>init, right>object, body>body'), i('DebuggerStatement', se), i('VariableDeclarator', He, 'id>name, init>value'), i('CatchClause', Ve, 'param>argname, body%body'), i('ThisExpression', wt), i('BinaryExpression', tt, 'operator=operator, left>left, right>right'), i('LogicalExpression', tt, 'operator=operator, left>left, right>right'), i('AssignmentExpression', rt, 'operator=operator, left>left, right>right'), i('ConditionalExpression', nt, 'test>condition, consequent>consequent, alternate>alternative'), i('NewExpression', Ge, 'callee>expression, arguments@args'), i('CallExpression', We, 'callee>expression, arguments@args'), a(we, e => l('Program', e)), a(Ce, e => ({
          type: 'FunctionDeclaration', id: u(e.name), params: e.argnames.map(u), body: l('BlockStatement', e),
        })), a(Ae, e => ({
          type: 'FunctionExpression', id: u(e.name), params: e.argnames.map(u), body: l('BlockStatement', e),
        })), a(ae, e => ({ type: 'ExpressionStatement', expression: { type: 'Literal', value: e.value } })), a(ue, e => ({ type: 'ExpressionStatement', expression: u(e.body) })), a(Re, e => ({ type: 'SwitchCase', test: u(e.expression), consequent: e.body.map(u) })), a(je, e => ({
          type: 'TryStatement', block: c(e), handler: u(e.bcatch), guardedHandlers: [], finalizer: u(e.bfinally),
        })), a(Ve, e => ({
          type: 'CatchClause', param: u(e.argname), guard: null, body: c(e),
        })), a(Ue, e => ({ type: 'VariableDeclaration', kind: e instanceof qe ? 'const' : 'var', declarations: e.definitions.map(u) })), a(Ye, e => ({ type: 'SequenceExpression', expressions: e.to_array().map(u) })), a(Xe, (e) => {
          const t = e instanceof Je; return {
            type: 'MemberExpression', object: u(e.expression), computed: t, property: t ? u(e.property) : { type: 'Identifier', name: e.property },
          };
        }), a(Qe, e => ({
          type: e.operator == '++' || e.operator == '--' ? 'UpdateExpression' : 'UnaryExpression', operator: e.operator, prefix: e instanceof Ze, argument: u(e.expression),
        })), a(tt, e => ({
          type: e.operator == '&&' || e.operator == '||' ? 'LogicalExpression' : 'BinaryExpression', left: u(e.left), operator: e.operator, right: u(e.right),
        })), a(it, e => ({ type: 'ArrayExpression', elements: e.elements.map(u) })), a(ot, e => ({ type: 'ObjectExpression', properties: e.properties.map(u) })), a(st, (e) => {
          let t; const n = { type: 'Literal', value: e.key instanceof pt ? e.key.name : e.key }; return e instanceof at ? t = 'init' : e instanceof ct ? t = 'get' : e instanceof ut && (t = 'set'), {
            type: 'Property', kind: t, key: n, value: u(e.value),
          };
        }), a(lt, (e) => { const t = e.definition(); return { type: 'Identifier', name: t ? t.mangled_name || t.name : e.name }; }), a(Ct, (e) => {
          const t = e.value; return {
            type: 'Literal', value: t, raw: t.toString(), regex: { pattern: t.source, flags: t.toString().match(/[gimuy]*$/)[0] },
          };
        }), a(kt, (e) => {
          const t = e.value; return typeof t === 'number' && (t < 0 || t === 0 && 1 / t < 0) ? {
            type: 'UnaryExpression', operator: '-', prefix: !0, argument: { type: 'Literal', value: -t, raw: e.start.raw },
          } : { type: 'Literal', value: t, raw: e.start.raw };
        }), a(St, e => ({ type: 'Identifier', name: String(e.value) })), Lt.DEFMETHOD('to_mozilla_ast', kt.prototype.to_mozilla_ast), Tt.DEFMETHOD('to_mozilla_ast', kt.prototype.to_mozilla_ast), Bt.DEFMETHOD('to_mozilla_ast', () => null), ce.DEFMETHOD('to_mozilla_ast', le.prototype.to_mozilla_ast), ke.DEFMETHOD('to_mozilla_ast', Ae.prototype.to_mozilla_ast); var f = null; ie.from_mozilla_ast = function (e) { const t = f; f = []; const n = o(e); return f = t, n; };
      }()), n.Compressor = X, n.DefaultsError = c, n.Dictionary = k, n.JS_Parse_Error = V, n.MAP = ne, n.OutputStream = Y, n.SourceMap = K, n.TreeTransformer = H, n.TreeWalker = T, n.base54 = rn, n.defaults = l, n.mangle_properties = Q, n.merge = p, n.parse = q, n.push_uniq = v, n.string_template = y, n.tokenizer = $, n.is_identifier = M, n.SymbolDef = W, n.sys = Z, n.MOZ_SourceMap = ee, n.UglifyJS = te, n.array_to_hash = r, n.slice = function (e, t) { return Array.prototype.slice.call(e, t || 0); }, n.characters = i, n.member = o, n.find_if = s, n.repeat_string = a, n.configure_error_stack = u, n.DefaultsError = c, n.defaults = l, n.merge = p, n.noop = h, n.return_false = f, n.return_true = d, n.return_this = m, n.return_null = g, n.MAP = ne, n.push_uniq = v, n.string_template = y, n.remove = b, n.mergeSort = _, n.set_difference = function (e, t) { return e.filter(e => t.indexOf(e) < 0); }, n.set_intersection = function (e, t) { return e.filter(e => t.indexOf(e) >= 0); }, n.makePredicate = x, n.all = w, n.Dictionary = k, n.HOP = E, n.first_in_statement = A, n.DEFNODE = C, n.AST_Token = re, n.AST_Node = ie, n.AST_Statement = oe, n.AST_Debugger = se, n.AST_Directive = ae, n.AST_SimpleStatement = ue, n.walk_body = S, n.AST_Block = ce, n.AST_BlockStatement = le, n.AST_EmptyStatement = pe, n.AST_StatementWithBody = he, n.AST_LabeledStatement = fe, n.AST_IterationStatement = de, n.AST_DWLoop = me, n.AST_Do = ge, n.AST_While = ve, n.AST_For = ye, n.AST_ForIn = be, n.AST_With = _e, n.AST_Scope = xe, n.AST_Toplevel = we, n.AST_Lambda = ke, n.AST_Accessor = Ee, n.AST_Function = Ae, n.AST_Defun = Ce, n.AST_Jump = Se, n.AST_Exit = Te, n.AST_Return = Oe, n.AST_Throw = Fe, n.AST_LoopControl = Be, n.AST_Break = De, n.AST_Continue = Le, n.AST_If = Ne, n.AST_Switch = Me, n.AST_SwitchBranch = Re, n.AST_Default = Pe, n.AST_Case = Ie, n.AST_Try = je, n.AST_Catch = Ve, n.AST_Finally = ze, n.AST_Definitions = Ue, n.AST_Var = $e, n.AST_Const = qe, n.AST_VarDef = He, n.AST_Call = We, n.AST_New = Ge, n.AST_Seq = Ye, n.AST_PropAccess = Xe, n.AST_Dot = Ke, n.AST_Sub = Je, n.AST_Unary = Qe, n.AST_UnaryPrefix = Ze, n.AST_UnaryPostfix = et, n.AST_Binary = tt, n.AST_Conditional = nt, n.AST_Assign = rt, n.AST_Array = it, n.AST_Object = ot, n.AST_ObjectProperty = st, n.AST_ObjectKeyVal = at, n.AST_ObjectSetter = ut, n.AST_ObjectGetter = ct, n.AST_Symbol = lt, n.AST_SymbolAccessor = pt, n.AST_SymbolDeclaration = ht, n.AST_SymbolVar = ft, n.AST_SymbolConst = dt, n.AST_SymbolFunarg = mt, n.AST_SymbolDefun = gt, n.AST_SymbolLambda = vt, n.AST_SymbolCatch = yt, n.AST_Label = bt, n.AST_SymbolRef = _t, n.AST_LabelRef = xt, n.AST_This = wt, n.AST_Constant = kt, n.AST_String = Et, n.AST_Number = At, n.AST_RegExp = Ct, n.AST_Atom = St, n.AST_Null = Tt, n.AST_NaN = Ot, n.AST_Undefined = Ft, n.AST_Hole = Bt, n.AST_Infinity = Dt, n.AST_Boolean = Lt, n.AST_False = Nt, n.AST_True = Mt, n.TreeWalker = T, n.KEYWORDS = Rt, n.KEYWORDS_ATOM = Pt, n.RESERVED_WORDS = It, n.KEYWORDS_BEFORE_EXPRESSION = jt, n.OPERATOR_CHARS = Vt, n.RE_HEX_NUMBER = zt, n.RE_OCT_NUMBER = Ut, n.OPERATORS = $t, n.WHITESPACE_CHARS = qt, n.NEWLINE_CHARS = Ht, n.PUNC_BEFORE_EXPRESSION = Wt, n.PUNC_CHARS = Gt, n.REGEXP_MODIFIERS = Yt, n.UNICODE = Xt, n.is_letter = O, n.is_digit = F, n.is_alphanumeric_char = B, n.is_unicode_digit = D, n.is_unicode_combining_mark = L, n.is_unicode_connector_punctuation = N, n.is_identifier = M, n.is_identifier_start = R, n.is_identifier_char = P, n.is_identifier_string = I, n.parse_js_number = j, n.JS_Parse_Error = V, n.js_error = z, n.is_token = U, n.EX_EOF = Kt, n.tokenizer = $, n.UNARY_PREFIX = Jt, n.UNARY_POSTFIX = Qt, n.ASSIGNMENT = Zt, n.PRECEDENCE = en, n.STATEMENTS_WITH_LABELS = tn, n.ATOMIC_START_TOKEN = nn, n.parse = q, n.TreeTransformer = H, n.SymbolDef = W, n.base54 = rn, n.EXPECT_DIRECTIVE = on, n.is_some_comments = G, n.OutputStream = Y, n.Compressor = X, n.SourceMap = K, n.find_builtins = J, n.mangle_properties = Q, n.AST_Node.warn_function = function (e) { typeof console !== 'undefined' && typeof console.warn === 'function' && console.warn(e); }, n.minify = function (e, n) {
        n = te.defaults(n, {
          compress: {}, fromString: !1, inSourceMap: null, mangle: {}, mangleProperties: !1, nameCache: null, outFileName: null, output: null, outSourceMap: null, parse: {}, sourceMapInline: !1, sourceMapUrl: null, sourceRoot: null, spidermonkey: !1, warnings: !1,
        }), te.base54.reset(); let r = n.inSourceMap; typeof r === 'string' && r != 'inline' && (r = JSON.parse(fs.readFileSync(r, 'utf8'))); let i = null; const o = {}; if (n.spidermonkey) { if (r == 'inline') throw new Error('inline source map only works with built-in parser'); i = te.AST_Node.from_mozilla_ast(e); } else { function s(e, t) { const s = n.fromString ? e : fs.readFileSync(e, 'utf8'); r == 'inline' && (r = read_source_map(s)), o[t] = s, i = te.parse(s, { filename: t, toplevel: i, bare_returns: n.parse ? n.parse.bare_returns : void 0 }); } if (!n.fromString && (e = te.simple_glob(e), r == 'inline' && e.length > 1)) throw new Error('inline source map only works with singular input'); [].concat(e).forEach((e, t) => { if (typeof e === 'string')s(e, n.fromString ? t : e); else for (const r in e)s(e[r], r); }); } if (n.wrap && (i = i.wrap_commonjs(n.wrap, n.exportAll)), n.compress) { const a = { warnings: n.warnings }; te.merge(a, n.compress), i.figure_out_scope(n.mangle); const u = te.Compressor(a); i = u.compress(i); }(n.mangleProperties || n.nameCache) && (n.mangleProperties.cache = te.readNameCache(n.nameCache, 'props'), i = te.mangle_properties(i, n.mangleProperties), te.writeNameCache(n.nameCache, 'props', n.mangleProperties.cache)), n.mangle && (i.figure_out_scope(n.mangle), i.compute_char_frequency(n.mangle), i.mangle_names(n.mangle)); const c = { max_line_len: 32e3 }; if ((n.outSourceMap || n.sourceMapInline) && (c.source_map = te.SourceMap({ file: n.outFileName || (typeof n.outSourceMap === 'string' ? n.outSourceMap.replace(/\.map$/i, '') : null), orig: r, root: n.sourceRoot }), n.sourceMapIncludeSources)) for (const l in o)o.hasOwnProperty(l) && c.source_map.get().setSourceContent(l, o[l]); n.output && te.merge(c, n.output); let p = te.OutputStream(c); i.print(p); let h = c.source_map; h && (h += ''); return n.sourceMapInline ? p += `\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${new t(h).toString('base64')}` : n.outSourceMap && typeof n.outSourceMap === 'string' && !1 !== n.sourceMapUrl && (p += `\n//# sourceMappingURL=${typeof n.sourceMapUrl === 'string' ? n.sourceMapUrl : n.outSourceMap}`), { code: `${p}`, map: h };
      }, n.describe_ast = function () { function e(n) { t.print(`AST_${n.TYPE}`); const r = n.SELF_PROPS.filter(e => !/^\$/.test(e)); r.length > 0 && (t.space(), t.with_parens(() => { r.forEach((e, n) => { n && t.space(), t.print(e); }); })), n.documentation && (t.space(), t.print_string(n.documentation)), n.SUBCLASSES.length > 0 && (t.space(), t.with_block(() => { n.SUBCLASSES.forEach((n, r) => { t.indent(), e(n), t.newline(); }); })); } var t = te.OutputStream({ beautify: !0 }); return e(te.AST_Node), `${t}`; };
    }).call(this, e('buffer').Buffer);
  }, { buffer: 11, 'source-map': 145, util: 152 }],
  148: [function (e, t, n) {
    function r() { this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null; } function i(e, t, n) { if (e && s.isObject(e) && e instanceof r) return e; const i = new r(); return i.parse(e, t, n), i; } const o = e('punycode'); var s = e('./util'); n.parse = i, n.resolve = function (e, t) { return i(e, !1, !0).resolve(t); }, n.resolveObject = function (e, t) { return e ? i(e, !1, !0).resolveObject(t) : t; }, n.format = function (e) { return s.isString(e) && (e = i(e)), e instanceof r ? e.format() : r.prototype.format.call(e); }, n.Url = r; const a = /^([a-z0-9.+-]+:)/i; const u = /:[0-9]*$/; const c = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/; const l = ['{', '}', '|', '\\', '^', '`'].concat(['<', '>', '"', '`', ' ', '\r', '\n', '\t']); const p = ["'"].concat(l); const h = ['%', '/', '?', ';', '#'].concat(p); const f = ['/', '?', '#']; const d = /^[+a-z0-9A-Z_-]{0,63}$/; const m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/; const g = { javascript: !0, 'javascript:': !0 }; const v = { javascript: !0, 'javascript:': !0 }; const y = {
      http: !0, https: !0, ftp: !0, gopher: !0, file: !0, 'http:': !0, 'https:': !0, 'ftp:': !0, 'gopher:': !0, 'file:': !0,
    }; const b = e('querystring'); r.prototype.parse = function (e, t, n) {
      if (!s.isString(e)) throw new TypeError(`Parameter 'url' must be a string, not ${typeof e}`); const r = e.indexOf('?'); const i = r !== -1 && r < e.indexOf('#') ? '?' : '#'; const u = e.split(i); u[0] = u[0].replace(/\\/g, '/'); let l = e = u.join(i); if (l = l.trim(), !n && e.split('#').length === 1) { const _ = c.exec(l); if (_) return this.path = l, this.href = l, this.pathname = _[1], _[2] ? (this.search = _[2], this.query = t ? b.parse(this.search.substr(1)) : this.search.substr(1)) : t && (this.search = '', this.query = {}), this; } let x = a.exec(l); if (x) { var w = (x = x[0]).toLowerCase(); this.protocol = w, l = l.substr(x.length); } if (n || x || l.match(/^\/\/[^@\/]+@[^@\/]+/)) { var k = l.substr(0, 2) === '//'; !k || x && v[x] || (l = l.substr(2), this.slashes = !0); } if (!v[x] && (k || x && !y[x])) {
        for (var E = -1, A = 0; A < f.length; A++)(T = l.indexOf(f[A])) !== -1 && (E === -1 || T < E) && (E = T); let C; let S; (S = E === -1 ? l.lastIndexOf('@') : l.lastIndexOf('@', E)) !== -1 && (C = l.slice(0, S), l = l.slice(S + 1), this.auth = decodeURIComponent(C)), E = -1; for (A = 0; A < h.length; A++) { var T = l.indexOf(h[A]); T !== -1 && (E === -1 || T < E) && (E = T); }E === -1 && (E = l.length), this.host = l.slice(0, E), l = l.slice(E), this.parseHost(), this.hostname = this.hostname || ''; const O = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; if (!O) for (var F = this.hostname.split(/\./), A = 0, B = F.length; A < B; A++) { const D = F[A]; if (D && !D.match(d)) { for (var L = '', N = 0, M = D.length; N < M; N++)D.charCodeAt(N) > 127 ? L += 'x' : L += D[N]; if (!L.match(d)) { const R = F.slice(0, A); const P = F.slice(A + 1); const I = D.match(m); I && (R.push(I[1]), P.unshift(I[2])), P.length && (l = `/${P.join('.')}${l}`), this.hostname = R.join('.'); break; } } } this.hostname.length > 255 ? this.hostname = '' : this.hostname = this.hostname.toLowerCase(), O || (this.hostname = o.toASCII(this.hostname)); var j = this.port ? `:${this.port}` : ''; const
          V = this.hostname || ''; this.host = V + j, this.href += this.host, O && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), l[0] !== '/' && (l = `/${l}`));
      } if (!g[w]) for (var A = 0, B = p.length; A < B; A++) { const z = p[A]; if (l.indexOf(z) !== -1) { let U = encodeURIComponent(z); U === z && (U = escape(z)), l = l.split(z).join(U); } } const $ = l.indexOf('#'); $ !== -1 && (this.hash = l.substr($), l = l.slice(0, $)); const q = l.indexOf('?'); if (q !== -1 ? (this.search = l.substr(q), this.query = l.substr(q + 1), t && (this.query = b.parse(this.query)), l = l.slice(0, q)) : t && (this.search = '', this.query = {}), l && (this.pathname = l), y[w] && this.hostname && !this.pathname && (this.pathname = '/'), this.pathname || this.search) { var j = this.pathname || ''; const H = this.search || ''; this.path = j + H; } return this.href = this.format(), this;
    }, r.prototype.format = function () { let e = this.auth || ''; e && (e = (e = encodeURIComponent(e)).replace(/%3A/i, ':'), e += '@'); let t = this.protocol || ''; let n = this.pathname || ''; let r = this.hash || ''; let i = !1; let o = ''; this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(':') === -1 ? this.hostname : `[${this.hostname}]`), this.port && (i += `:${this.port}`)), this.query && s.isObject(this.query) && Object.keys(this.query).length && (o = b.stringify(this.query)); let a = this.search || o && `?${o}` || ''; return t && t.substr(-1) !== ':' && (t += ':'), this.slashes || (!t || y[t]) && !1 !== i ? (i = `//${i || ''}`, n && n.charAt(0) !== '/' && (n = `/${n}`)) : i || (i = ''), r && r.charAt(0) !== '#' && (r = `#${r}`), a && a.charAt(0) !== '?' && (a = `?${a}`), n = n.replace(/[?#]/g, e => encodeURIComponent(e)), a = a.replace('#', '%23'), t + i + n + a + r; }, r.prototype.resolve = function (e) { return this.resolveObject(i(e, !1, !0)).format(); }, r.prototype.resolveObject = function (e) { if (s.isString(e)) { const t = new r(); t.parse(e, !1, !0), e = t; } for (var n = new r(), i = Object.keys(this), o = 0; o < i.length; o++) { const a = i[o]; n[a] = this[a]; } if (n.hash = e.hash, e.href === '') return n.href = n.format(), n; if (e.slashes && !e.protocol) { for (let u = Object.keys(e), c = 0; c < u.length; c++) { const l = u[c]; l !== 'protocol' && (n[l] = e[l]); } return y[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = '/'), n.href = n.format(), n; } if (e.protocol && e.protocol !== n.protocol) { if (!y[e.protocol]) { for (let p = Object.keys(e), h = 0; h < p.length; h++) { const f = p[h]; n[f] = e[f]; } return n.href = n.format(), n; } if (n.protocol = e.protocol, e.host || v[e.protocol])n.pathname = e.pathname; else { for (k = (e.pathname || '').split('/'); k.length && !(e.host = k.shift()););e.host || (e.host = ''), e.hostname || (e.hostname = ''), k[0] !== '' && k.unshift(''), k.length < 2 && k.unshift(''), n.pathname = k.join('/'); } if (n.search = e.search, n.query = e.query, n.host = e.host || '', n.auth = e.auth, n.hostname = e.hostname || e.host, n.port = e.port, n.pathname || n.search) { const d = n.pathname || ''; const m = n.search || ''; n.path = d + m; } return n.slashes = n.slashes || e.slashes, n.href = n.format(), n; } const g = n.pathname && n.pathname.charAt(0) === '/'; const b = e.host || e.pathname && e.pathname.charAt(0) === '/'; let _ = b || g || n.host && e.pathname; const x = _; let w = n.pathname && n.pathname.split('/') || []; var k = e.pathname && e.pathname.split('/') || []; const E = n.protocol && !y[n.protocol]; if (E && (n.hostname = '', n.port = null, n.host && (w[0] === '' ? w[0] = n.host : w.unshift(n.host)), n.host = '', e.protocol && (e.hostname = null, e.port = null, e.host && (k[0] === '' ? k[0] = e.host : k.unshift(e.host)), e.host = null), _ = _ && (k[0] === '' || w[0] === '')), b)n.host = e.host || e.host === '' ? e.host : n.host, n.hostname = e.hostname || e.hostname === '' ? e.hostname : n.hostname, n.search = e.search, n.query = e.query, w = k; else if (k.length)w || (w = []), w.pop(), w = w.concat(k), n.search = e.search, n.query = e.query; else if (!s.isNullOrUndefined(e.search)) return E && (n.hostname = n.host = w.shift(), (F = !!(n.host && n.host.indexOf('@') > 0) && n.host.split('@')) && (n.auth = F.shift(), n.host = n.hostname = F.shift())), n.search = e.search, n.query = e.query, s.isNull(n.pathname) && s.isNull(n.search) || (n.path = (n.pathname ? n.pathname : '') + (n.search ? n.search : '')), n.href = n.format(), n; if (!w.length) return n.pathname = null, n.search ? n.path = `/${n.search}` : n.path = null, n.href = n.format(), n; for (var A = w.slice(-1)[0], C = (n.host || e.host || w.length > 1) && (A === '.' || A === '..') || A === '', S = 0, T = w.length; T >= 0; T--)(A = w[T]) === '.' ? w.splice(T, 1) : A === '..' ? (w.splice(T, 1), S++) : S && (w.splice(T, 1), S--); if (!_ && !x) for (;S--; S)w.unshift('..'); !_ || w[0] === '' || w[0] && w[0].charAt(0) === '/' || w.unshift(''), C && w.join('/').substr(-1) !== '/' && w.push(''); const O = w[0] === '' || w[0] && w[0].charAt(0) === '/'; if (E) { n.hostname = n.host = O ? '' : w.length ? w.shift() : ''; var F = !!(n.host && n.host.indexOf('@') > 0) && n.host.split('@'); F && (n.auth = F.shift(), n.host = n.hostname = F.shift()); } return (_ = _ || n.host && w.length) && !O && w.unshift(''), w.length ? n.pathname = w.join('/') : (n.pathname = null, n.path = null), s.isNull(n.pathname) && s.isNull(n.search) || (n.path = (n.pathname ? n.pathname : '') + (n.search ? n.search : '')), n.auth = e.auth || n.auth, n.slashes = n.slashes || e.slashes, n.href = n.format(), n; }, r.prototype.parseHost = function () { let e = this.host; let t = u.exec(e); t && ((t = t[0]) !== ':' && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e); };
  }, { './util': 149, punycode: 131, querystring: 134 }],
  149: [function (e, t, n) {
    t.exports = {
      isString(e) { return typeof e === 'string'; }, isObject(e) { return typeof e === 'object' && e !== null; }, isNull(e) { return e === null; }, isNullOrUndefined(e) { return e == null; },
    };
  }, {}],
  150: [function (e, t, n) {
    typeof Object.create === 'function' ? t.exports = function (e, t) {
      e.super_ = t, e.prototype = Object.create(t.prototype, {
        constructor: {
          value: e, enumerable: !1, writable: !0, configurable: !0,
        },
      });
    } : t.exports = function (e, t) { e.super_ = t; const n = function () {}; n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e; };
  }, {}],
  151: [function (e, t, n) { t.exports = function (e) { return e && typeof e === 'object' && typeof e.copy === 'function' && typeof e.fill === 'function' && typeof e.readUInt8 === 'function'; }; }, {}],
  152: [function (e, t, n) {
    (function (t, r) {
      function i(e, t) { const r = { seen: [], stylize: s }; return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), m(t) ? r.showHidden = t : t && n._extend(r, t), b(r.showHidden) && (r.showHidden = !1), b(r.depth) && (r.depth = 2), b(r.colors) && (r.colors = !1), b(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = o), u(r, e, r.depth); } function o(e, t) { const n = i.styles[t]; return n ? `[${i.colors[n][0]}m${e}[${i.colors[n][1]}m` : e; } function s(e, t) { return e; } function a(e) { const t = {}; return e.forEach((e, n) => { t[e] = !0; }), t; } function u(e, t, r) { if (e.customInspect && t && E(t.inspect) && t.inspect !== n.inspect && (!t.constructor || t.constructor.prototype !== t)) { let i = t.inspect(r, e); return y(i) || (i = u(e, i, r)), i; } const o = c(e, t); if (o) return o; let s = Object.keys(t); const m = a(s); if (e.showHidden && (s = Object.getOwnPropertyNames(t)), k(t) && (s.indexOf('message') >= 0 || s.indexOf('description') >= 0)) return l(t); if (s.length === 0) { if (E(t)) { const g = t.name ? `: ${t.name}` : ''; return e.stylize(`[Function${g}]`, 'special'); } if (_(t)) return e.stylize(RegExp.prototype.toString.call(t), 'regexp'); if (w(t)) return e.stylize(Date.prototype.toString.call(t), 'date'); if (k(t)) return l(t); } let v = ''; let b = !1; let x = ['{', '}']; if (d(t) && (b = !0, x = ['[', ']']), E(t) && (v = ` [Function${t.name ? `: ${t.name}` : ''}]`), _(t) && (v = ` ${RegExp.prototype.toString.call(t)}`), w(t) && (v = ` ${Date.prototype.toUTCString.call(t)}`), k(t) && (v = ` ${l(t)}`), s.length === 0 && (!b || t.length == 0)) return x[0] + v + x[1]; if (r < 0) return _(t) ? e.stylize(RegExp.prototype.toString.call(t), 'regexp') : e.stylize('[Object]', 'special'); e.seen.push(t); let A; return A = b ? p(e, t, r, m, s) : s.map(n => h(e, t, r, m, n, b)), e.seen.pop(), f(A, v, x); } function c(e, t) { if (b(t)) return e.stylize('undefined', 'undefined'); if (y(t)) { const n = `'${JSON.stringify(t).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"')}'`; return e.stylize(n, 'string'); } return v(t) ? e.stylize(`${t}`, 'number') : m(t) ? e.stylize(`${t}`, 'boolean') : g(t) ? e.stylize('null', 'null') : void 0; } function l(e) { return `[${Error.prototype.toString.call(e)}]`; } function p(e, t, n, r, i) { for (var o = [], s = 0, a = t.length; s < a; ++s)T(t, String(s)) ? o.push(h(e, t, n, r, String(s), !0)) : o.push(''); return i.forEach((i) => { i.match(/^\d+$/) || o.push(h(e, t, n, r, i, !0)); }), o; } function h(e, t, n, r, i, o) { let s; let a; let c; if ((c = Object.getOwnPropertyDescriptor(t, i) || { value: t[i] }).get ? a = c.set ? e.stylize('[Getter/Setter]', 'special') : e.stylize('[Getter]', 'special') : c.set && (a = e.stylize('[Setter]', 'special')), T(r, i) || (s = `[${i}]`), a || (e.seen.indexOf(c.value) < 0 ? (a = g(n) ? u(e, c.value, null) : u(e, c.value, n - 1)).indexOf('\n') > -1 && (a = o ? a.split('\n').map(e => `  ${e}`).join('\n').substr(2) : `\n${a.split('\n').map(e => `   ${e}`).join('\n')}`) : a = e.stylize('[Circular]', 'special')), b(s)) { if (o && i.match(/^\d+$/)) return a; (s = JSON.stringify(`${i}`)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, 'name')) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, 'string')); } return `${s}: ${a}`; } function f(e, t, n) { let r = 0; return e.reduce((e, t) => r++, t.indexOf('\n') >= 0 && r++, e + t.replace(/\u001b\[\d\d?m/g, '').length + 1, 0) > 60 ? `${n[0] + (t === '' ? '' : `${t}\n `)} ${e.join(',\n  ')} ${n[1]}` : `${n[0] + t} ${e.join(', ')} ${n[1]}`; } function d(e) { return Array.isArray(e); } function m(e) { return typeof e === 'boolean'; } function g(e) { return e === null; } function v(e) { return typeof e === 'number'; } function y(e) { return typeof e === 'string'; } function b(e) { return void 0 === e; } function _(e) { return x(e) && A(e) === '[object RegExp]'; } function x(e) { return typeof e === 'object' && e !== null; } function w(e) { return x(e) && A(e) === '[object Date]'; } function k(e) { return x(e) && (A(e) === '[object Error]' || e instanceof Error); } function E(e) { return typeof e === 'function'; } function A(e) { return Object.prototype.toString.call(e); } function C(e) { return e < 10 ? `0${e.toString(10)}` : e.toString(10); } function S() {
        const e = new Date();


        const t = [C(e.getHours()), C(e.getMinutes()), C(e.getSeconds())].join(':'); return [e.getDate(), D[e.getMonth()], t].join(' ');
      } function T(e, t) { return Object.prototype.hasOwnProperty.call(e, t); } const O = /%[sdj%]/g; n.format = function (e) { if (!y(e)) { for (var t = [], n = 0; n < arguments.length; n++)t.push(i(arguments[n])); return t.join(' '); } for (var n = 1, r = arguments, o = r.length, s = String(e).replace(O, (e) => { if (e === '%%') return '%'; if (n >= o) return e; switch (e) { case '%s': return String(r[n++]); case '%d': return Number(r[n++]); case '%j': try { return JSON.stringify(r[n++]); } catch (e) { return '[Circular]'; } default: return e; } }), a = r[n]; n < o; a = r[++n])g(a) || !x(a) ? s += ` ${a}` : s += ` ${i(a)}`; return s; }, n.deprecate = function (e, i) { if (b(r.process)) return function () { return n.deprecate(e, i).apply(this, arguments); }; if (!0 === t.noDeprecation) return e; let o = !1; return function () { if (!o) { if (t.throwDeprecation) throw new Error(i); t.traceDeprecation ? console.trace(i) : console.error(i), o = !0; } return e.apply(this, arguments); }; }; let F; const B = {}; n.debuglog = function (e) { if (b(F) && (F = t.env.NODE_DEBUG || ''), e = e.toUpperCase(), !B[e]) if (new RegExp(`\\b${e}\\b`, 'i').test(F)) { const r = t.pid; B[e] = function () { const t = n.format(...arguments); console.error('%s %d: %s', e, r, t); }; } else B[e] = function () {}; return B[e]; }, n.inspect = i, i.colors = {
        bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39],
      }, i.styles = {
        special: 'cyan', number: 'yellow', boolean: 'yellow', undefined: 'grey', null: 'bold', string: 'green', date: 'magenta', regexp: 'red',
      }, n.isArray = d, n.isBoolean = m, n.isNull = g, n.isNullOrUndefined = function (e) { return e == null; }, n.isNumber = v, n.isString = y, n.isSymbol = function (e) { return typeof e === 'symbol'; }, n.isUndefined = b, n.isRegExp = _, n.isObject = x, n.isDate = w, n.isError = k, n.isFunction = E, n.isPrimitive = function (e) { return e === null || typeof e === 'boolean' || typeof e === 'number' || typeof e === 'string' || typeof e === 'symbol' || void 0 === e; }, n.isBuffer = e('./support/isBuffer'); var D = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; n.log = function () { console.log('%s - %s', S(), n.format(...arguments)); }, n.inherits = e('inherits'), n._extend = function (e, t) { if (!t || !x(t)) return e; for (let n = Object.keys(t), r = n.length; r--;)e[n[r]] = t[n[r]]; return e; };
    }).call(this, e('_process'), typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});
  }, { './support/isBuffer': 151, _process: 31, inherits: 150 }],
  153: [function (e, t, n) {
    t.exports = {
      area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, menuitem: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0,
    };
  }, {}],
  154: [function (e, t, n) {
    function r(e) { return s.parse(e, { ecmaVersion: 6, allowReturnOutsideFunction: !0 }); } function i(e, t) { function n(t) { return e.slice(t.start, t.end).join(''); } function i(t, n) { for (let r = t.start; r < t.end; r++)e[r] = ''; e[t.start] = n; } let o; const s = e; let u = !1; const c = r(e); if (e = e.split(''), (o = c.body).length !== 1 || (o = o[0]).type !== 'ExpressionStatement' || (o = o.expression).type !== 'CallExpression' || (o = o.callee).type !== 'MemberExpression' || !1 !== o.computed || o.property.name !== 'call' || (o = o.object).type !== 'FunctionExpression') throw new Error('AST does not seem to represent a self-calling function'); const l = o; return a.recursive(c, null, { Function(e, t, n) { e === l && n(e.body, t, 'ScopeBody'); }, ReturnStatement(e) { u = !0, i(e, `return {value: (${e.argument ? n(e.argument) : 'undefined'})};`); } }), u ? `var ${t}=${e.join('')};if (${t}) return ${t}.value` : s; } const o = e('acorn-globals'); var s = e('acorn'); var a = e('acorn/dist/walk'); t.exports = function (e, t, n) { e += '', t += '', n = (n = n || []).concat(o(e).map(e => e.name)); const r = o(t).map(e => e.name).filter(e => n.indexOf(e) === -1 && e !== 'undefined' && e !== 'this'); if (r.length === 0) return t; let s = ''; let a = 'locals_for_with'; let u = 'result_of_with'; if (/^[a-zA-Z0-9$_]+$/.test(e))a = e; else { for (;r.indexOf(a) != -1 || n.indexOf(a) != -1;)a += '_'; s = `var ${a} = (${e})`; } for (;r.indexOf(u) != -1 || n.indexOf(u) != -1;)u += '_'; const c = r.map(e => `${JSON.stringify(e)} in ${a}?${a}.${e}:typeof ${e}!=="undefined"?${e}:undefined`); return t = `(function (${r.join(', ')}) {${t}}.call(this${c.map(e => `,${e}`).join('')}))`, `;${s};${i(t, u)};`; };
  }, { acorn: 155, 'acorn-globals': 1, 'acorn/dist/walk': 156 }],
  155: [function (e, t, n) { arguments[4][14][0].apply(n, arguments); }, { dup: 14 }],
  156: [function (e, t, n) { arguments[4][15][0].apply(n, arguments); }, { dup: 15 }],
  pug: [function (e, t, n) {
    (function (t) {
      function r(e, t, n, r) { return n.reduce((e, n) => (n[r] ? n[r](e, t) : e), e); } function i(e, t) { const n = e.filter(e => e[t]); if (n.length > 1) throw new Error(`Two or more plugins all implement ${t} method.`); return n.length ? n[0][t].bind(n[0]) : null; } function o(e, t) {
        const o = {}; o[t.filename] = e; const s = []; const a = t.plugins || []; let g = h.string(e, {
          filename: t.filename,
          basedir: t.basedir,
          lex(e, t) { const n = {}; return Object.keys(t).forEach((e) => { n[e] = t[e]; }), n.plugins = a.filter(e => !!e.lex).map(e => e.lex), r(c(e, n), t, a, 'postLex'); },
          parse(e, t) {
            e = e.map(e => (e.type === 'path' && u.extname(e.val) === '' ? {
              type: 'path', line: e.line, col: e.col, val: `${e.val}.pug`,
            } : e)), e = r(e = l(e, t), t, a, 'preParse'); const n = {}; return Object.keys(t).forEach((e) => { n[e] = t[e]; }), n.plugins = a.filter(e => !!e.parse).map(e => e.parse), r(r(p(e, n), t, a, 'postParse'), t, a, 'preLoad');
          },
          resolve(e, n, r) { const o = i(a, 'resolve'); return o ? o(e, n, t) : h.resolve(e, n, r); },
          read(e, n) { s.push(e); let u; const c = i(a, 'read'); const l = r(u = c ? c(e, t) : h.read(e, n), { filename: e }, a, 'preLex'); return o[e] = l, l; },
        }); g = r(g = r(g, t, a, 'postLoad'), t, a, 'preFilters'); const v = {}; Object.keys(n.filters).forEach((e) => { v[e] = n.filters[e]; }), t.filters && Object.keys(t.filters).forEach((e) => { v[e] = t.filters[e]; }), g = r(g = r(g = f.handleFilters(g, v, t.filterOptions, t.filterAliases), t, a, 'postFilters'), t, a, 'preLink'), g = r(g = r(g = d(g), t, a, 'postLink'), t, a, 'preCodeGen'); let y = m(g, {
          pretty: t.pretty, compileDebug: t.compileDebug, doctype: t.doctype, inlineRuntimeFunctions: t.inlineRuntimeFunctions, globals: t.globals, self: t.self, includeSources: !!t.includeSources && o, templateName: t.templateName,
        }); return y = r(y, t, a, 'postCodeGen'), t.debug && console.error('\nCompiled Function:\n\n[90m%s[0m', y.replace(/^/gm, '  ')), { body: y, dependencies: s };
      } function s(e, t) { const r = e.filename; if (e.cache && n.cache[r]) return n.cache[r]; void 0 === t && (t = a.readFileSync(e.filename, 'utf8')); const i = n.compile(t, e); return e.cache && (n.cache[r] = i), i; } var a = e('fs'); var u = e('path'); var c = e('pug-lexer'); var l = e('pug-strip-comments'); var p = e('pug-parser'); var h = e('pug-load'); var f = e('pug-filters'); var d = e('pug-linker'); var m = e('pug-code-gen'); const g = e('pug-runtime'); const v = e('pug-runtime/wrap'); n.name = 'Pug', n.runtime = g, n.cache = {}, n.filters = {}, n.compile = function (e, t) {
        var t = t || {}; const n = o(e = String(e), {
          compileDebug: !1 !== t.compileDebug, filename: t.filename, basedir: t.basedir, pretty: t.pretty, doctype: t.doctype, inlineRuntimeFunctions: t.inlineRuntimeFunctions, globals: t.globals, self: t.self, includeSources: !0 === t.compileDebug, debug: t.debug, templateName: 'template', filters: t.filters, filterOptions: t.filterOptions, filterAliases: t.filterAliases, plugins: t.plugins,
        }); const r = t.inlineRuntimeFunctions ? new Function('', `${n.body};return template;`)() : v(n.body); return r.dependencies = n.dependencies, r;
      }, n.compileClientWithDependenciesTracked = function (e, t) {
        var t = t || {}; const n = o(e = String(e), {
          compileDebug: t.compileDebug, filename: t.filename, basedir: t.basedir, pretty: t.pretty, doctype: t.doctype, inlineRuntimeFunctions: !1 !== t.inlineRuntimeFunctions, globals: t.globals, self: t.self, includeSources: t.compileDebug, debug: t.debug, templateName: t.name || 'template', filters: t.filters, filterOptions: t.filterOptions, filterAliases: t.filterAliases, plugins: t.plugins,
        }); let r = n.body; return t.module && (!1 === t.inlineRuntimeFunctions && (r = `var pug = require("pug-runtime");${r}`), r += ` module.exports = ${t.name || 'template'};`), { body: r, dependencies: n.dependencies };
      }, n.compileClient = function (e, t) { return n.compileClientWithDependenciesTracked(e, t).body; }, n.compileFile = function (e, t) { return t = t || {}, t.filename = e, s(t); }, n.render = function (e, t, r) { if (typeof t === 'function' && (r = t, t = void 0), typeof r === 'function') { let i; try { i = n.render(e, t); } catch (e) { return r(e); } return r(null, i); } if ((t = t || {}).cache && !t.filename) throw new Error('the "filename" option is required for caching'); return s(t, e)(t); }, n.renderFile = function (e, t, r) { if (typeof t === 'function' && (r = t, t = void 0), typeof r === 'function') { let i; try { i = n.renderFile(e, t); } catch (e) { return r(e); } return r(null, i); } return t = t || {}, t.filename = e, s(t)(t); }, n.compileFileClient = function (e, t) { const r = `${e}:client`; if (t = t || {}, t.filename = e, t.cache && n.cache[r]) return n.cache[r]; const i = a.readFileSync(t.filename, 'utf8'); const o = n.compileClient(i, t); return t.cache && (n.cache[r] = o), o; }, n.__express = function (e, r, i) { void 0 == r.compileDebug && t.env.NODE_ENV === 'production' && (r.compileDebug = !1), n.renderFile(e, r, i); };
    }).call(this, e('_process'));
  }, {
    _process: 31, fs: 9, path: 30, 'pug-code-gen': 41, 'pug-filters': 43, 'pug-lexer': 130, 'pug-linker': 118, 'pug-load': 119, 'pug-parser': 120, 'pug-runtime': 123, 'pug-runtime/wrap': 127, 'pug-strip-comments': 128,
  }],
}, {}, []));
